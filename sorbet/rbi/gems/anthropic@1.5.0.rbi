# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `anthropic` gem.
# Please instead update this file by running `bin/tapioca gem anthropic`.


# frozen_string_literal: true
# typed: strong
# typed: true

module Anthropic
  APIErrorObject = Anthropic::Models::APIErrorObject
  AnthropicBeta = Anthropic::Models::AnthropicBeta
  AuthenticationError = Anthropic::Models::AuthenticationError
  Base64ImageSource = Anthropic::Models::Base64ImageSource
  Base64PDFSource = Anthropic::Models::Base64PDFSource
  BedrockClient = Anthropic::Helpers::Bedrock::Client
  Beta = Anthropic::Models::Beta
  BetaAPIError = Anthropic::Models::BetaAPIError
  BetaAuthenticationError = Anthropic::Models::BetaAuthenticationError
  BetaBillingError = Anthropic::Models::BetaBillingError
  BetaError = Anthropic::Models::BetaError
  BetaErrorResponse = Anthropic::Models::BetaErrorResponse
  BetaGatewayTimeoutError = Anthropic::Models::BetaGatewayTimeoutError
  BetaInvalidRequestError = Anthropic::Models::BetaInvalidRequestError
  BetaNotFoundError = Anthropic::Models::BetaNotFoundError
  BetaOverloadedError = Anthropic::Models::BetaOverloadedError
  BetaPermissionError = Anthropic::Models::BetaPermissionError
  BetaRateLimitError = Anthropic::Models::BetaRateLimitError
  BillingError = Anthropic::Models::BillingError
  CacheControlEphemeral = Anthropic::Models::CacheControlEphemeral
  CitationCharLocation = Anthropic::Models::CitationCharLocation
  CitationCharLocationParam = Anthropic::Models::CitationCharLocationParam
  CitationContentBlockLocation = Anthropic::Models::CitationContentBlockLocation

  CitationContentBlockLocationParam = Anthropic::Models::CitationContentBlockLocationParam

  CitationPageLocation = Anthropic::Models::CitationPageLocation
  CitationPageLocationParam = Anthropic::Models::CitationPageLocationParam

  CitationSearchResultLocationParam = Anthropic::Models::CitationSearchResultLocationParam

  CitationWebSearchResultLocationParam = Anthropic::Models::CitationWebSearchResultLocationParam

  CitationsConfigParam = Anthropic::Models::CitationsConfigParam
  CitationsDelta = Anthropic::Models::CitationsDelta

  CitationsSearchResultLocation = Anthropic::Models::CitationsSearchResultLocation

  CitationsWebSearchResultLocation = Anthropic::Models::CitationsWebSearchResultLocation

  class Client < Anthropic::Internal::Transport::BaseClient
    sig { returns(T.nilable(String)) }
    attr_reader :api_key

    sig { returns(T.nilable(String)) }
    attr_reader :auth_token

    sig { returns(Anthropic::Resources::Beta) }
    attr_reader :beta

    sig { returns(Anthropic::Resources::Completions) }
    attr_reader :completions

    sig { returns(Anthropic::Resources::Messages) }
    attr_reader :messages

    sig { returns(Anthropic::Resources::Models) }
    attr_reader :models

    private

    # @api private
    sig { returns(T::Hash[String, String]) }
    def api_key_auth; end

    # @api private
    sig { override.returns(T::Hash[String, String]) }
    def auth_headers; end

    # @api private
    sig { returns(T::Hash[String, String]) }
    def bearer_auth; end

    class << self
      # Creates and returns a new client for interacting with the API.
      sig do
        params(
          api_key: T.nilable(String),
          auth_token: T.nilable(String),
          base_url: T.nilable(String),
          max_retries: Integer,
          timeout: Float,
          initial_retry_delay: Float,
          max_retry_delay: Float
        ).returns(T.attached_class)
      end
      def new(
        api_key: ENV["ANTHROPIC_API_KEY"], # Defaults to `ENV["ANTHROPIC_API_KEY"]`
        auth_token: ENV["ANTHROPIC_AUTH_TOKEN"], # Defaults to `ENV["ANTHROPIC_AUTH_TOKEN"]`
        base_url: ENV["ANTHROPIC_BASE_URL"], # Override the default base URL for the API, e.g.,
                                             # `"https://api.example.com/v2/"`. Defaults to `ENV["ANTHROPIC_BASE_URL"]`
        max_retries: Anthropic::Client::DEFAULT_MAX_RETRIES, # Max number of retries to attempt after a failed retryable request.
        timeout: Anthropic::Client::DEFAULT_TIMEOUT_IN_SECONDS,
        initial_retry_delay: Anthropic::Client::DEFAULT_INITIAL_RETRY_DELAY,
        max_retry_delay: Anthropic::Client::DEFAULT_MAX_RETRY_DELAY
); end
    end

    DEFAULT_INITIAL_RETRY_DELAY = T.let(0.5, Float)
    DEFAULT_MAX_RETRIES = 2
    DEFAULT_MAX_RETRY_DELAY = T.let(8.0, Float)
    DEFAULT_TIMEOUT_IN_SECONDS = T.let(600.0, Float)
  end

  Completion = Anthropic::Models::Completion
  CompletionCreateParams = Anthropic::Models::CompletionCreateParams
  ContentBlock = Anthropic::Models::ContentBlock
  ContentBlockParam = Anthropic::Models::ContentBlockParam
  ContentBlockSource = Anthropic::Models::ContentBlockSource
  ContentBlockSourceContent = Anthropic::Models::ContentBlockSourceContent
  DocumentBlockParam = Anthropic::Models::DocumentBlockParam
  ErrorObject = Anthropic::Models::ErrorObject
  ErrorResponse = Anthropic::Models::ErrorResponse

  module Errors
    class APIConnectionError < Anthropic::Errors::APIError
      sig { void }
      attr_accessor :body

      sig { void }
      attr_accessor :status

      class << self
        # @api private
        sig do
          params(
            url: URI::Generic,
            status: NilClass,
            body: NilClass,
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def new(url:, status: nil, body: nil, request: nil, response: nil, message: "Connection error."); end
      end
    end

    class APIError < Anthropic::Errors::Error
      sig { returns(T.nilable(T.anything)) }
      attr_accessor :body

      sig { returns(T.nilable(Integer)) }
      attr_accessor :status

      sig { returns(URI::Generic) }
      attr_accessor :url

      class << self
        # @api private
        sig do
          params(
            url: URI::Generic,
            status: T.nilable(Integer),
            body: T.nilable(Object),
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def new(url:, status: nil, body: nil, request: nil, response: nil, message: nil); end
      end
    end

    class APIStatusError < Anthropic::Errors::APIError
      sig { returns(Integer) }
      attr_accessor :status

      class << self
        # @api private
        sig do
          params(
            url: URI::Generic,
            status: Integer,
            body: T.nilable(Object),
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def for(url:, status:, body:, request:, response:, message: nil); end

        # @api private
        sig do
          params(
            url: URI::Generic,
            status: Integer,
            body: T.nilable(Object),
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def new(url:, status:, body:, request:, response:, message: nil); end
      end
    end

    class APITimeoutError < Anthropic::Errors::APIConnectionError
      class << self
        # @api private
        sig do
          params(
            url: URI::Generic,
            status: NilClass,
            body: NilClass,
            request: NilClass,
            response: NilClass,
            message: T.nilable(String)
          ).returns(T.attached_class)
        end
        def new(url:, status: nil, body: nil, request: nil, response: nil, message: "Request timed out."); end
      end
    end

    class AuthenticationError < Anthropic::Errors::APIStatusError
      HTTP_STATUS = 401
    end

    class BadRequestError < Anthropic::Errors::APIStatusError
      HTTP_STATUS = 400
    end

    class ConflictError < Anthropic::Errors::APIStatusError
      HTTP_STATUS = 409
    end

    class ConversionError < Anthropic::Errors::Error
      sig { returns(T.nilable(StandardError)) }
      def cause; end

      class << self
        # @api private
        sig do
          params(
            on: T::Class[StandardError],
            method: Symbol,
            target: T.anything,
            value: T.anything,
            cause: T.nilable(StandardError)
          ).returns(T.attached_class)
        end
        def new(on:, method:, target:, value:, cause: nil); end
      end
    end

    class Error < StandardError
      sig { returns(T.nilable(StandardError)) }
      attr_accessor :cause
    end

    class InternalServerError < Anthropic::Errors::APIStatusError
      HTTP_STATUS = T.let((500..), T::Range[Integer])
    end

    class NotFoundError < Anthropic::Errors::APIStatusError
      HTTP_STATUS = 404
    end

    class PermissionDeniedError < Anthropic::Errors::APIStatusError
      HTTP_STATUS = 403
    end

    class RateLimitError < Anthropic::Errors::APIStatusError
      HTTP_STATUS = 429
    end

    class UnprocessableEntityError < Anthropic::Errors::APIStatusError
      HTTP_STATUS = 422
    end
  end

  class FilePart
    sig { returns(T.any(Pathname, StringIO, IO, String)) }
    attr_reader :content

    sig { returns(T.nilable(String)) }
    attr_reader :content_type

    sig { returns(T.nilable(String)) }
    attr_reader :filename

    sig { params(a: T.anything).returns(String) }
    def to_json(*a); end

    sig { params(a: T.anything).returns(String) }
    def to_yaml(*a); end

    private

    # @api private
    sig { returns(String) }
    def read; end

    class << self
      sig do
        params(
          content: T.any(Pathname, StringIO, IO, String),
          filename: T.nilable(String),
          content_type: T.nilable(String)
        ).returns(T.attached_class)
      end
      def new(content, filename: nil, content_type: nil); end
    end
  end

  GatewayTimeoutError = Anthropic::Models::GatewayTimeoutError

  module Helpers
    module Bedrock
      class Client < Anthropic::Client
        sig { returns(String) }
        attr_reader :aws_region

        sig { returns(Anthropic::Resources::Beta) }
        attr_reader :beta

        sig { returns(Anthropic::Resources::Completions) }
        attr_reader :completions

        sig { returns(Anthropic::Resources::Messages) }
        attr_reader :messages

        private

        # @api private
        sig do
          override
            .params(
              req: Anthropic::Internal::Transport::BaseClient::RequestComponents,
              opts: Anthropic::Internal::AnyHash
            ).returns(Anthropic::Internal::Transport::BaseClient::RequestInput)
        end
        def build_request(req, opts); end

        sig do
          params(
            request_components: Anthropic::Internal::Transport::BaseClient::RequestComponents
          ).returns(Anthropic::Internal::Transport::BaseClient::RequestComponents)
        end
        def fit_req_to_bedrock_specs!(request_components); end

        sig do
          params(
            aws_region: T.nilable(String),
            aws_access_key: T.nilable(String),
            aws_secret_key: T.nilable(String),
            aws_session_token: T.nilable(String),
            aws_profile: T.nilable(String)
          ).returns(T::Array[T.anything])
        end
        def resolve_region_and_credentials(aws_region:, aws_access_key:, aws_secret_key:, aws_session_token:, aws_profile:); end

        class << self
          sig do
            params(
              aws_region: T.nilable(String),
              base_url: T.nilable(String),
              max_retries: Integer,
              timeout: Float,
              initial_retry_delay: Float,
              max_retry_delay: Float,
              aws_access_key: T.nilable(String),
              aws_secret_key: T.nilable(String),
              aws_session_token: T.nilable(String),
              aws_profile: T.nilable(String)
            ).returns(T.attached_class)
          end
          def new(aws_region: nil, base_url: nil, max_retries: Anthropic::Client::DEFAULT_MAX_RETRIES, timeout: Anthropic::Client::DEFAULT_TIMEOUT_IN_SECONDS, initial_retry_delay: Anthropic::Client::DEFAULT_INITIAL_RETRY_DELAY, max_retry_delay: Anthropic::Client::DEFAULT_MAX_RETRY_DELAY, aws_access_key: nil, aws_secret_key: nil, aws_session_token: nil, aws_profile: nil); end
        end

        DEFAULT_VERSION = "bedrock-2023-05-31"
      end
    end

    module Streaming
      class CitationEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::CitationsDelta::Citation::Variants) }
        attr_accessor :citation

        sig { returns(T::Array[Anthropic::CitationsDelta::Citation::Variants]) }
        attr_accessor :snapshot

        sig { returns(Symbol) }
        attr_accessor :type
      end

      class ContentBlockStopEvent < Anthropic::Models::RawContentBlockStopEvent
        sig { returns(Anthropic::Models::ContentBlock) }
        attr_accessor :content_block

        sig { returns(Integer) }
        attr_accessor :index

        sig { returns(Symbol) }
        attr_accessor :type

        class << self
          sig do
            params(
              index: Integer,
              content_block: Anthropic::Models::ContentBlock,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(index:, content_block:, type: :content_block_stop); end
        end
      end

      class InputJsonEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :partial_json

        sig { returns(T.untyped) }
        attr_accessor :snapshot

        sig { returns(Symbol) }
        attr_accessor :type
      end

      class MessageStopEvent < Anthropic::Models::RawMessageStopEvent
        sig { returns(Anthropic::Models::Message) }
        attr_accessor :message

        class << self
          sig { params(message: Anthropic::Models::Message, type: Symbol).returns(T.attached_class) }
          def new(message:, type: :message_stop); end
        end
      end

      class MessageStream
        include Anthropic::Internal::Type::BaseStream

        Message = type_member(:in) { { fixed: Anthropic::Streaming::RawMessageEvent } }
        Elem = type_member(:out) { { fixed: Anthropic::Streaming::StreamEvent } }

        sig { params(raw_stream: Anthropic::Internal::Stream[RawMessageEvent]).void }
        def initialize(raw_stream:); end

        sig { returns(Anthropic::Models::Message) }
        def accumulated_message; end

        sig { returns(String) }
        def accumulated_text; end

        sig { returns(T::Enumerator[String]) }
        def text; end

        sig { void }
        def until_done; end

        private

        sig do
          params(
            event: Anthropic::Streaming::RawMessageEvent,
            current_snapshot: T.nilable(Anthropic::Models::Message)
          ).returns(Anthropic::Models::Message)
        end
        def accumulate_event(event:, current_snapshot:); end
      end

      RawMessageEvent = T.type_alias do
          T.any(
            Anthropic::Models::RawMessageStartEvent,
            Anthropic::Models::RawMessageDeltaEvent,
            Anthropic::Models::RawMessageStopEvent,
            Anthropic::Models::RawContentBlockStartEvent,
            Anthropic::Models::RawContentBlockDeltaEvent,
            Anthropic::Models::RawContentBlockStopEvent
          )
        end

      class SignatureEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :signature

        sig { returns(Symbol) }
        attr_accessor :type
      end

      StreamEvent = T.type_alias do
          T.any(
            Anthropic::Streaming::RawMessageEvent,
            Anthropic::Streaming::TextEvent,
            Anthropic::Streaming::CitationEvent,
            Anthropic::Streaming::ThinkingEvent,
            Anthropic::Streaming::SignatureEvent,
            Anthropic::Streaming::InputJsonEvent,
            Anthropic::Streaming::MessageStopEvent,
            Anthropic::Streaming::ContentBlockStopEvent
          )
        end

      class TextEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :snapshot

        sig { returns(String) }
        attr_accessor :text

        sig { returns(Symbol) }
        attr_accessor :type
      end

      class ThinkingEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :snapshot

        sig { returns(String) }
        attr_accessor :thinking

        sig { returns(Symbol) }
        attr_accessor :type
      end
    end

    module Vertex
      class Client < Anthropic::Client
        sig { returns(Anthropic::Resources::Beta) }
        attr_reader :beta

        sig { returns(Anthropic::Resources::Messages) }
        attr_reader :messages

        sig { returns(String) }
        attr_reader :project_id

        sig { returns(String) }
        attr_reader :region

        private

        # @api private
        sig do
          override
            .params(
              req: Anthropic::Internal::Transport::BaseClient::RequestComponents,
              opts: Anthropic::Internal::AnyHash
            ).returns(Anthropic::Internal::Transport::BaseClient::RequestInput)
        end
        def build_request(req, opts); end

        sig do
          params(
            request_components: Anthropic::Internal::Transport::BaseClient::RequestComponents
          ).returns(Anthropic::Internal::Transport::BaseClient::RequestComponents)
        end
        def fit_req_to_vertex_specs!(request_components); end

        class << self
          sig do
            params(
              region: T.nilable(String),
              project_id: T.nilable(String),
              base_url: T.nilable(String),
              max_retries: Integer,
              timeout: Float,
              initial_retry_delay: Float,
              max_retry_delay: Float
            ).returns(T.attached_class)
          end
          def new(region: ENV["CLOUD_ML_REGION"], project_id: ENV["ANTHROPIC_VERTEX_PROJECT_ID"], base_url: nil, max_retries: Anthropic::Client::DEFAULT_MAX_RETRIES, timeout: Anthropic::Client::DEFAULT_TIMEOUT_IN_SECONDS, initial_retry_delay: Anthropic::Client::DEFAULT_INITIAL_RETRY_DELAY, max_retry_delay: Anthropic::Client::DEFAULT_MAX_RETRY_DELAY); end
        end

        DEFAULT_VERSION = "vertex-2023-10-16"
      end
    end
  end

  ImageBlockParam = Anthropic::Models::ImageBlockParam
  InputJSONDelta = Anthropic::Models::InputJSONDelta

  module Internal
    extend Anthropic::Internal::Util::SorbetRuntimeSupport

    # Due to the current WIP status of Shapes support in Sorbet, types referencing
    # this alias might be refined in the future.
    AnyHash = T.type_alias { T::Hash[Symbol, T.anything] }

    FileInput = T.type_alias do
        T.any(Pathname, StringIO, IO, String, Anthropic::FilePart)
      end

    class JsonLStream
      include Anthropic::Internal::Type::BaseStream

      Message = type_member(:in) { { fixed: T.anything } }
      Elem = type_member(:out)

      private

      # @api private
      sig { override.returns(T::Enumerable[Elem]) }
      def iterator; end
    end

    OMIT = T.let(Object.new.freeze, T.anything)

    class Page
      include Anthropic::Internal::Type::BasePage

      Elem = type_member

      sig { returns(T.nilable(T::Array[Elem])) }
      attr_accessor :data

      sig { returns(T.nilable(String)) }
      attr_accessor :first_id

      sig { returns(T::Boolean) }
      attr_accessor :has_more

      sig { returns(T.nilable(String)) }
      attr_accessor :last_id

      # @api private
      sig { returns(String) }
      def inspect; end
    end

    class Stream
      include Anthropic::Internal::Type::BaseStream

      Message = type_member(:in) do
          { fixed: Anthropic::Internal::Util::ServerSentEvent }
        end
      Elem = type_member(:out)

      private

      # @api private
      sig { override.returns(T::Enumerable[Elem]) }
      def iterator; end
    end

    module Transport
      # @api private
      class BaseClient
        extend Anthropic::Internal::Util::SorbetRuntimeSupport

        abstract!

        sig { returns(URI::Generic) }
        attr_reader :base_url

        sig { returns(T::Hash[String, String]) }
        attr_reader :headers

        sig { returns(T.nilable(String)) }
        attr_reader :idempotency_header

        sig { returns(Float) }
        attr_reader :initial_retry_delay

        sig { returns(Integer) }
        attr_reader :max_retries

        sig { returns(Float) }
        attr_reader :max_retry_delay

        # @api private
        sig { returns(Anthropic::Internal::Transport::PooledNetRequester) }
        attr_reader :requester

        sig { returns(Float) }
        attr_reader :timeout

        # @api private
        sig { returns(String) }
        def inspect; end

        # Execute the request specified by `req`. This is the method that all resource
        # methods call into.
        #
        # @overload request(method, path, query: {}, headers: {}, body: nil, unwrap: nil, page: nil, stream: nil, model: Anthropic::Internal::Type::Unknown, options: {})
        sig do
          params(
            method: Symbol,
            path: T.any(String, T::Array[String]),
            query: T.nilable(
                T::Hash[String, T.nilable(T.any(T::Array[String], String))]
              ),
            headers: T.nilable(
                T::Hash[
                  String,
                  T.nilable(
                    T.any(
                      String,
                      Integer,
                      T::Array[T.nilable(T.any(String, Integer))]
                    )
                  )
                ]
              ),
            body: T.nilable(T.anything),
            unwrap: T.nilable(
                T.any(
                  Symbol,
                  Integer,
                  T::Array[T.any(Symbol, Integer)],
                  T.proc.params(arg0: T.anything).returns(T.anything)
                )
              ),
            page: T.nilable(
                T::Class[
                  Anthropic::Internal::Type::BasePage[
                    Anthropic::Internal::Type::BaseModel
                  ]
                ]
              ),
            stream: T.nilable(
                T::Class[
                  Anthropic::Internal::Type::BaseStream[
                    T.anything,
                    Anthropic::Internal::Type::BaseModel
                  ]
                ]
              ),
            model: T.nilable(Anthropic::Internal::Type::Converter::Input),
            options: T.nilable(Anthropic::RequestOptions::OrHash)
          ).returns(T.anything)
        end
        def request(method, path, query: {}, headers: {}, body: nil, unwrap: nil, page: nil, stream: nil, model: Anthropic::Internal::Type::Unknown, options: {}); end

        # @api private
        sig do
          params(
            request: Anthropic::Internal::Transport::BaseClient::RequestInput,
            redirect_count: Integer,
            retry_count: Integer,
            send_retry_header: T::Boolean
          ).returns([Integer, Net::HTTPResponse, T::Enumerable[String]])
        end
        def send_request(request, redirect_count:, retry_count:, send_retry_header:); end

        private

        # @api private
        sig { overridable.returns(T::Hash[String, String]) }
        def auth_headers; end

        # @api private
        sig do
          overridable
            .params(
              req: Anthropic::Internal::Transport::BaseClient::RequestComponents,
              opts: Anthropic::Internal::AnyHash
            ).returns(Anthropic::Internal::Transport::BaseClient::RequestInput)
        end
        def build_request(req, opts); end

        # @api private
        sig { returns(String) }
        def generate_idempotency_key; end

        # @api private
        sig { params(headers: T::Hash[String, String], retry_count: Integer).returns(Float) }
        def retry_delay(headers, retry_count:); end

        class << self
          # @api private
          sig do
            params(
              request: Anthropic::Internal::Transport::BaseClient::RequestInput,
              status: Integer,
              response_headers: T.any(T::Hash[String, String], Net::HTTPHeader)
            ).returns(Anthropic::Internal::Transport::BaseClient::RequestInput)
          end
          def follow_redirect(request, status:, response_headers:); end

          # @api private
          sig do
            params(
              status: T.any(Integer, Anthropic::Errors::APIConnectionError),
              stream: T.nilable(T::Enumerable[String])
            ).void
          end
          def reap_connection!(status, stream:); end

          # @api private
          sig { params(status: Integer, headers: T.any(T::Hash[String, String], Net::HTTPHeader)).returns(T::Boolean) }
          def should_retry?(status, headers:); end

          # @api private
          sig { params(req: Anthropic::Internal::Transport::BaseClient::RequestComponents).void }
          def validate!(req); end
        end

        class << self
          # @api private
          sig do
            params(
              base_url: String,
              timeout: Float,
              max_retries: Integer,
              initial_retry_delay: Float,
              max_retry_delay: Float,
              headers: T::Hash[
                String,
                T.nilable(
                  T.any(
                    String,
                    Integer,
                    T::Array[T.nilable(T.any(String, Integer))]
                  )
                )
              ],
              idempotency_header: T.nilable(String)
            ).returns(T.attached_class)
          end
          def new(base_url:, timeout: 0.0, max_retries: 0, initial_retry_delay: 0.0, max_retry_delay: 0.0, headers: {}, idempotency_header: nil); end
        end

        # from whatwg fetch spec
        MAX_REDIRECTS = 20

        PLATFORM_HEADERS = T::Hash[String, String]

        RequestComponents = T.type_alias do
            {
              method: Symbol,
              path: T.any(String, T::Array[String]),
              query:
                T.nilable(
                  T::Hash[String, T.nilable(T.any(T::Array[String], String))]
                ),
              headers:
                T.nilable(
                  T::Hash[
                    String,
                    T.nilable(
                      T.any(
                        String,
                        Integer,
                        T::Array[T.nilable(T.any(String, Integer))]
                      )
                    )
                  ]
                ),
              body: T.nilable(T.anything),
              unwrap:
                T.nilable(
                  T.any(
                    Symbol,
                    Integer,
                    T::Array[T.any(Symbol, Integer)],
                    T.proc.params(arg0: T.anything).returns(T.anything)
                  )
                ),
              page:
                T.nilable(
                  T::Class[
                    Anthropic::Internal::Type::BasePage[
                      Anthropic::Internal::Type::BaseModel
                    ]
                  ]
                ),
              stream:
                T.nilable(
                  T::Class[
                    Anthropic::Internal::Type::BaseStream[
                      T.anything,
                      Anthropic::Internal::Type::BaseModel
                    ]
                  ]
                ),
              model: T.nilable(Anthropic::Internal::Type::Converter::Input),
              options: T.nilable(Anthropic::RequestOptions::OrHash)
            }
          end

        RequestInput = T.type_alias do
            {
              method: Symbol,
              url: URI::Generic,
              headers: T::Hash[String, String],
              body: T.anything,
              max_retries: Integer,
              timeout: Float
            }
          end
      end

      # @api private
      class PooledNetRequester
        extend Anthropic::Internal::Util::SorbetRuntimeSupport

        # @api private
        sig do
          params(
            request: Anthropic::Internal::Transport::PooledNetRequester::Request
          ).returns([Integer, Net::HTTPResponse, T::Enumerable[String]])
        end
        def execute(request); end

        private

        # @api private
        sig { params(url: URI::Generic, deadline: Float, blk: T.proc.params(arg0: Net::HTTP).void).void }
        def with_pool(url, deadline:, &blk); end

        class << self
          # @api private
          sig do
            params(
              request: Anthropic::Internal::Transport::PooledNetRequester::Request,
              blk: T.proc.params(arg0: String).void
            ).returns([Net::HTTPGenericRequest, T.proc.void])
          end
          def build_request(request, &blk); end

          # @api private
          sig { params(conn: Net::HTTP, deadline: Float).void }
          def calibrate_socket_timeout(conn, deadline); end

          # @api private
          sig { params(url: URI::Generic).returns(Net::HTTP) }
          def connect(url); end
        end

        class << self
          # @api private
          sig { params(size: Integer).returns(T.attached_class) }
          def new(size: Anthropic::Internal::Transport::PooledNetRequester::DEFAULT_MAX_CONNECTIONS); end
        end

        DEFAULT_MAX_CONNECTIONS = T.let(T.unsafe(nil), Integer)

        # from the golang stdlib
        # https://github.com/golang/go/blob/c8eced8580028328fde7c03cbfcb720ce15b2358/src/net/http/transport.go#L49
        KEEP_ALIVE_TIMEOUT = 30

        Request = T.type_alias do
            {
              method: Symbol,
              url: URI::Generic,
              headers: T::Hash[String, String],
              body: T.anything,
              deadline: Float
            }
          end
      end
    end

    module Type
      # @api private
      #
      # Array of items of a given type.
      class ArrayOf
        include Anthropic::Internal::Type::Converter
        include Anthropic::Internal::Util::SorbetRuntimeSupport

        abstract!

        Elem = type_member(:out)

        # @api private
        sig do
          params(
            type_info: T.any(
                Anthropic::Internal::AnyHash,
                T.proc.returns(Anthropic::Internal::Type::Converter::Input),
                Anthropic::Internal::Type::Converter::Input
              ),
            spec: Anthropic::Internal::AnyHash
          ).void
        end
        def initialize(type_info, spec = {}); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ===(other); end

        # @api private
        sig do
          override
            .params(
              value: T.any(T::Array[T.anything], T.anything),
              state: Anthropic::Internal::Type::Converter::CoerceState
            ).returns(T.any(T::Array[T.anything], T.anything))
        end
        def coerce(value, state:); end

        # @api private
        sig do
          override
            .params(
              value: T.any(T::Array[T.anything], T.anything),
              state: Anthropic::Internal::Type::Converter::DumpState
            ).returns(T.any(T::Array[T.anything], T.anything))
        end
        def dump(value, state:); end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        protected

        # @api private
        sig { returns(Elem) }
        def item_type; end

        # @api private
        sig { returns(T::Boolean) }
        def nilable?; end

        class << self
          sig do
            params(
              type_info: T.any(
                Anthropic::Internal::AnyHash,
                T.proc.returns(Anthropic::Internal::Type::Converter::Input),
                Anthropic::Internal::Type::Converter::Input
              ),
              spec: Anthropic::Internal::AnyHash
            ).returns(T.attached_class)
          end
          def [](type_info, spec = {}); end
        end
      end

      class BaseModel
        extend Anthropic::Internal::Type::Converter
        extend Anthropic::Internal::Util::SorbetRuntimeSupport

        abstract!

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        # Returns the raw value associated with the given key, if found. Otherwise, nil is
        # returned.
        #
        # It is valid to lookup keys that are not in the API spec, for example to access
        # undocumented features. This method does not parse response data into
        # higher-level types. Lookup by anything other than a Symbol is an ArgumentError.
        sig { params(key: Symbol).returns(T.nilable(T.anything)) }
        def [](key); end

        sig { params(keys: T.nilable(T::Array[Symbol])).returns(Anthropic::Internal::AnyHash) }
        def deconstruct_keys(keys); end

        # In addition to the behaviour of `#to_h`, this method will recursively call
        # `#to_h` on nested models.
        sig { overridable.returns(Anthropic::Internal::AnyHash) }
        def deep_to_h; end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { returns(String) }
        def inspect; end

        # Returns a Hash of the data underlying this object. O(1)
        #
        # Keys are Symbols and values are the raw values from the response. The return
        # value indicates which values were ever set on the object. i.e. there will be a
        # key in this hash if they ever were, even if the set value was nil.
        #
        # This method is not recursive. The returned value is shared by the object, so it
        # should not be mutated.
        sig { overridable.returns(Anthropic::Internal::AnyHash) }
        def to_h; end

        # Returns a Hash of the data underlying this object. O(1)
        #
        # Keys are Symbols and values are the raw values from the response. The return
        # value indicates which values were ever set on the object. i.e. there will be a
        # key in this hash if they ever were, even if the set value was nil.
        #
        # This method is not recursive. The returned value is shared by the object, so it
        # should not be mutated.
        sig { overridable.returns(Anthropic::Internal::AnyHash) }
        def to_hash; end

        sig { params(a: T.anything).returns(String) }
        def to_json(*a); end

        sig { returns(String) }
        def to_s; end

        sig { params(a: T.anything).returns(String) }
        def to_yaml(*a); end

        class << self
          sig { params(other: T.anything).returns(T::Boolean) }
          def ==(other); end

          # @api private
          sig do
            returns(T::Hash[
                Symbol,
                T.all(
                  Anthropic::Internal::Type::BaseModel::KnownField,
                  { type: Anthropic::Internal::Type::Converter::Input }
                )
              ])
          end
          def fields; end

          sig { returns(Integer) }
          def hash; end

          # @api private
          #
          # Assumes superclass fields are totally defined before fields are accessed /
          # defined on subclasses.
          sig { params(child: T.self_type).void }
          def inherited(child); end

          # @api private
          sig do
            returns(T::Hash[
                Symbol,
                T.all(
                  Anthropic::Internal::Type::BaseModel::KnownField,
                  {
                    type_fn:
                      T.proc.returns(
                        Anthropic::Internal::Type::Converter::Input
                      )
                  }
                )
              ])
          end
          def known_fields; end

          # @api private
          sig do
            params(
              name_sym: Symbol,
              type_info: T.any(
                  Anthropic::Internal::AnyHash,
                  T.proc.returns(Anthropic::Internal::Type::Converter::Input),
                  Anthropic::Internal::Type::Converter::Input
                ),
              spec: Anthropic::Internal::AnyHash
            ).void
          end
          def optional(name_sym, type_info, spec = {}); end

          # @api private
          sig do
            params(
              name_sym: Symbol,
              type_info: T.any(
                  Anthropic::Internal::AnyHash,
                  T.proc.returns(Anthropic::Internal::Type::Converter::Input),
                  Anthropic::Internal::Type::Converter::Input
                ),
              spec: Anthropic::Internal::AnyHash
            ).void
          end
          def required(name_sym, type_info, spec = {}); end

          private

          # @api private
          sig do
            params(
              name_sym: Symbol,
              required: T::Boolean,
              type_info: T.any(
                  {
                    const:
                      T.nilable(
                        T.any(NilClass, T::Boolean, Integer, Float, Symbol)
                      ),
                    enum:
                      T.nilable(
                        T.proc.returns(
                          Anthropic::Internal::Type::Converter::Input
                        )
                      ),
                    union:
                      T.nilable(
                        T.proc.returns(
                          Anthropic::Internal::Type::Converter::Input
                        )
                      ),
                    api_name: Symbol,
                    nil?: T::Boolean
                  },
                  T.proc.returns(Anthropic::Internal::Type::Converter::Input),
                  Anthropic::Internal::Type::Converter::Input
                ),
              spec: Anthropic::Internal::AnyHash
            ).void
          end
          def add_field(name_sym, required:, type_info:, spec:); end

          # @api private
          #
          # `request_only` attributes not excluded from `.#coerce` when receiving responses
          # even if well behaved servers should not send them
          sig { params(blk: T.proc.void).void }
          def request_only(&blk); end

          # @api private
          #
          # `response_only` attributes are omitted from `.#dump` when making requests
          sig { params(blk: T.proc.void).void }
          def response_only(&blk); end
        end

        class << self
          # @api private
          sig do
            override
              .params(
                value: T.any(
                    Anthropic::Internal::Type::BaseModel,
                    T::Hash[T.anything, T.anything],
                    T.anything
                  ),
                state: Anthropic::Internal::Type::Converter::CoerceState
              ).returns(T.any(T.attached_class, T.anything))
          end
          def coerce(value, state:); end

          # @api private
          sig do
            override
              .params(
                value: T.any(T.attached_class, T.anything),
                state: Anthropic::Internal::Type::Converter::DumpState
              ).returns(T.any(T::Hash[T.anything, T.anything], T.anything))
          end
          def dump(value, state:); end

          # @api private
          sig { returns(T.anything) }
          def to_sorbet_type; end
        end

        class << self
          # @api private
          sig do
            params(
              model: Anthropic::Internal::Type::BaseModel,
              convert: T::Boolean
            ).returns(Anthropic::Internal::AnyHash)
          end
          def recursively_to_h(model, convert:); end
        end

        class << self
          # @api private
          sig { params(depth: Integer).returns(String) }
          def inspect(depth: 0); end
        end

        class << self
          # Create a new instance of a model.
          sig { params(data: T.any(T::Hash[Symbol, T.anything], T.self_type)).returns(T.attached_class) }
          def new(data = {}); end
        end

        KnownField = T.type_alias do
            {
              mode: T.nilable(Symbol),
              required: T::Boolean,
              nilable: T::Boolean
            }
          end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Internal::Type::BaseModel,
              Anthropic::Internal::AnyHash
            )
          end
      end

      # @api private
      #
      # This module provides a base implementation for paginated responses in the SDK.
      module BasePage
        Elem = type_member(:out)

        # @api private
        sig do
          params(
            client: Anthropic::Internal::Transport::BaseClient,
            req: Anthropic::Internal::Transport::BaseClient::RequestComponents,
            headers: T.any(T::Hash[String, String], Net::HTTPHeader),
            page_data: T.anything
          ).void
        end
        def initialize(client:, req:, headers:, page_data:); end

        sig { overridable.params(blk: T.proc.params(arg0: Elem).void).void }
        def auto_paging_each(&blk); end

        sig { overridable.returns(T.self_type) }
        def next_page; end

        sig { overridable.returns(T::Boolean) }
        def next_page?; end

        sig { returns(T::Enumerable[Elem]) }
        def to_enum; end
      end

      # @api private
      #
      # This module provides a base implementation for streaming responses in the SDK.
      module BaseStream
        include Enumerable

        Message = type_member(:in)
        Elem = type_member(:out)

        # @api private
        sig do
          params(
            model: T.any(T::Class[T.anything], Anthropic::Internal::Type::Converter),
            url: URI::Generic,
            status: Integer,
            response: Net::HTTPResponse,
            unwrap: T.any(
                Symbol,
                Integer,
                T::Array[T.any(Symbol, Integer)],
                T.proc.params(arg0: T.anything).returns(T.anything)
              ),
            stream: T::Enumerable[Message]
          ).void
        end
        def initialize(model:, url:, status:, response:, unwrap:, stream:); end

        sig { void }
        def close; end

        sig { params(blk: T.proc.params(arg0: Elem).void).void }
        def each(&blk); end

        # @api private
        sig { returns(String) }
        def inspect; end

        sig { returns(T::Enumerator[Elem]) }
        def to_enum; end

        private

        # @api private
        sig { overridable.returns(T::Enumerable[Elem]) }
        def iterator; end

        class << self
          # Attempt to close the underlying transport when the stream itself is garbage
          # collected.
          #
          # This should not be relied upon for resource clean up, as the garbage collector
          # is not guaranteed to run.
          sig { params(stream: T::Enumerable[T.anything]).returns(T.proc.params(arg0: Integer).void) }
          def defer_closing(stream); end
        end
      end

      # @api private
      #
      # Ruby has no Boolean class; this is something for models to refer to.
      class Boolean
        extend Anthropic::Internal::Type::Converter
        extend Anthropic::Internal::Util::SorbetRuntimeSupport

        abstract!

        class << self
          # @api private
          #
          # Coerce value to Boolean if possible, otherwise return the original value.
          sig do
            override
              .params(
                value: T.any(T::Boolean, T.anything),
                state: Anthropic::Internal::Type::Converter::CoerceState
              ).returns(T.any(T::Boolean, T.anything))
          end
          def coerce(value, state:); end

          # @api private
          sig do
            override
              .params(
                value: T.any(T::Boolean, T.anything),
                state: Anthropic::Internal::Type::Converter::DumpState
              ).returns(T.any(T::Boolean, T.anything))
          end
          def dump(value, state:); end

          # @api private
          sig { returns(T.anything) }
          def to_sorbet_type; end
        end

        class << self
          sig { params(other: T.anything).returns(T::Boolean) }
          def ==(other); end

          sig { params(other: T.anything).returns(T::Boolean) }
          def ===(other); end
        end
      end

      # @api private
      module Converter
        extend Anthropic::Internal::Util::SorbetRuntimeSupport

        # @api private
        sig do
          overridable
            .params(
              value: T.anything,
              state: Anthropic::Internal::Type::Converter::CoerceState
            ).returns(T.anything)
        end
        def coerce(value, state:); end

        # @api private
        sig do
          overridable
            .params(
              value: T.anything,
              state: Anthropic::Internal::Type::Converter::DumpState
            ).returns(T.anything)
        end
        def dump(value, state:); end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        class << self
          class << self
            # @api private
            #
            # Based on `target`, transform `value` into `target`, to the extent possible:
            #
            # 1. if the given `value` conforms to `target` already, return the given `value`
            # 2. if it's possible and safe to convert the given `value` to `target`, then the
            #    converted value
            # 3. otherwise, the given `value` unaltered
            #
            # The coercion process is subject to improvement between minor release versions.
            # See https://docs.pydantic.dev/latest/concepts/unions/#smart-mode
            sig do
              params(
                target: Anthropic::Internal::Type::Converter::Input,
                value: T.anything,
                state: Anthropic::Internal::Type::Converter::CoerceState
              ).returns(T.anything)
            end
            def coerce(
              target,
              value,
              state: Anthropic::Internal::Type::Converter.new_coerce_state # The `strictness` is one of `true`, `false`. This informs the coercion strategy
                                                                           # when we have to decide between multiple possible conversion targets:
                                                                           # - `true`: the conversion must be exact, with minimum coercion.
                                                                           # - `false`: the conversion can be approximate, with some coercion.
                                                                           # The `exactness` is `Hash` with keys being one of `yes`, `no`, or `maybe`. For
                                                                           # any given conversion attempt, the exactness will be updated based on how closely
                                                                           # the value recursively matches the target type:
                                                                           # - `yes`: the value can be converted to the target type with minimum coercion.
                                                                           # - `maybe`: the value can be converted to the target type with some reasonable
                                                                           #   coercion.
                                                                           # - `no`: the value cannot be converted to the target type.
                                                                           # See implementation below for more details.
); end

            # @api private
            sig do
              params(
                target: Anthropic::Internal::Type::Converter::Input,
                value: T.anything,
                state: Anthropic::Internal::Type::Converter::DumpState
              ).returns(T.anything)
            end
            def dump(target, value, state: { can_retry: true }); end

            # @api private
            sig { params(target: T.anything, depth: Integer).returns(String) }
            def inspect(target, depth:); end

            # @api private
            sig { params(translate_names: T::Boolean).returns(Anthropic::Internal::Type::Converter::CoerceState) }
            def new_coerce_state(translate_names: true); end

            # @api private
            sig do
              params(
                spec: T.any(
                  {
                    const:
                      T.nilable(
                        T.any(NilClass, T::Boolean, Integer, Float, Symbol)
                      ),
                    enum:
                      T.nilable(
                        T.proc.returns(
                          Anthropic::Internal::Type::Converter::Input
                        )
                      ),
                    union:
                      T.nilable(
                        T.proc.returns(
                          Anthropic::Internal::Type::Converter::Input
                        )
                      )
                  },
                  T.proc.returns(Anthropic::Internal::Type::Converter::Input),
                  Anthropic::Internal::Type::Converter::Input
                )
              ).returns(T.proc.returns(T.anything))
            end
            def type_info(spec); end
          end
        end

        CoerceState = T.type_alias do
            {
              translate_names: T::Boolean,
              strictness: T::Boolean,
              exactness: {
                yes: Integer,
                no: Integer,
                maybe: Integer
              },
              error: T::Class[StandardError],
              branched: Integer
            }
          end

        DumpState = T.type_alias { { can_retry: T::Boolean } }

        Input = T.type_alias do
            T.any(Anthropic::Internal::Type::Converter, T::Class[T.anything])
          end
      end

      # @api private
      #
      # A value from among a specified list of options. OpenAPI enum values map to Ruby
      # values in the SDK as follows:
      #
      # 1. boolean => true | false
      # 2. integer => Integer
      # 3. float => Float
      # 4. string => Symbol
      #
      # We can therefore convert string values to Symbols, but can't convert other
      # values safely.
      module Enum
        include Anthropic::Internal::Type::Converter
        include Anthropic::Internal::Util::SorbetRuntimeSupport

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ===(other); end

        # @api private
        #
        # Unlike with primitives, `Enum` additionally validates that the value is a member
        # of the enum.
        sig do
          override
            .params(
              value: T.any(String, Symbol, T.anything),
              state: Anthropic::Internal::Type::Converter::CoerceState
            ).returns(T.any(Symbol, T.anything))
        end
        def coerce(value, state:); end

        # @api private
        sig do
          override
            .params(
              value: T.any(Symbol, T.anything),
              state: Anthropic::Internal::Type::Converter::DumpState
            ).returns(T.any(Symbol, T.anything))
        end
        def dump(value, state:); end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        # All of the valid Symbol values for this enum.
        sig { overridable.returns(T::Array[T.any(NilClass, T::Boolean, Integer, Float, Symbol)]) }
        def values; end
      end

      # @api private
      #
      # Either `Pathname` or `StringIO`, or `IO`, or
      # `Anthropic::Internal::Type::FileInput`.
      #
      # Note: when `IO` is used, all retries are disabled, since many IO` streams are
      # not rewindable.
      class FileInput
        extend Anthropic::Internal::Type::Converter

        abstract!

        class << self
          # @api private
          sig do
            override
              .params(
                value: T.any(StringIO, String, T.anything),
                state: Anthropic::Internal::Type::Converter::CoerceState
              ).returns(T.any(StringIO, T.anything))
          end
          def coerce(value, state:); end

          # @api private
          sig do
            override
              .params(
                value: T.any(Pathname, StringIO, IO, String, T.anything),
                state: Anthropic::Internal::Type::Converter::DumpState
              ).returns(T.any(Pathname, StringIO, IO, String, T.anything))
          end
          def dump(value, state:); end

          # @api private
          sig { returns(T.anything) }
          def to_sorbet_type; end
        end

        class << self
          sig { params(other: T.anything).returns(T::Boolean) }
          def ==(other); end

          sig { params(other: T.anything).returns(T::Boolean) }
          def ===(other); end
        end
      end

      # @api private
      #
      # Hash of items of a given type.
      class HashOf
        include Anthropic::Internal::Type::Converter
        include Anthropic::Internal::Util::SorbetRuntimeSupport

        abstract!

        Elem = type_member(:out)

        # @api private
        sig do
          params(
            type_info: T.any(
                Anthropic::Internal::AnyHash,
                T.proc.returns(Anthropic::Internal::Type::Converter::Input),
                Anthropic::Internal::Type::Converter::Input
              ),
            spec: Anthropic::Internal::AnyHash
          ).void
        end
        def initialize(type_info, spec = {}); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ===(other); end

        # @api private
        sig do
          override
            .params(
              value: T.any(T::Hash[T.anything, T.anything], T.anything),
              state: Anthropic::Internal::Type::Converter::CoerceState
            ).returns(T.any(Anthropic::Internal::AnyHash, T.anything))
        end
        def coerce(value, state:); end

        # @api private
        sig do
          override
            .params(
              value: T.any(T::Hash[T.anything, T.anything], T.anything),
              state: Anthropic::Internal::Type::Converter::DumpState
            ).returns(T.any(Anthropic::Internal::AnyHash, T.anything))
        end
        def dump(value, state:); end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        protected

        # @api private
        sig { returns(Elem) }
        def item_type; end

        # @api private
        sig { returns(T::Boolean) }
        def nilable?; end

        class << self
          sig do
            params(
              type_info: T.any(
                Anthropic::Internal::AnyHash,
                T.proc.returns(Anthropic::Internal::Type::Converter::Input),
                Anthropic::Internal::Type::Converter::Input
              ),
              spec: Anthropic::Internal::AnyHash
            ).returns(T.attached_class)
          end
          def [](type_info, spec = {}); end
        end
      end

      # @api private
      module RequestParameters
        # Options to specify HTTP behaviour for this request.
        sig { returns(Anthropic::RequestOptions) }
        attr_reader :request_options

        sig { params(request_options: Anthropic::RequestOptions::OrHash).void }
        attr_writer :request_options

        # @api private
        module Converter
          # @api private
          sig { params(params: T.anything).returns([T.anything, Anthropic::Internal::AnyHash]) }
          def dump_request(params); end
        end
      end

      # @api private
      module Union
        include Anthropic::Internal::Type::Converter
        include Anthropic::Internal::Util::SorbetRuntimeSupport

        sig { params(other: T.anything).returns(T::Boolean) }
        def ==(other); end

        sig { params(other: T.anything).returns(T::Boolean) }
        def ===(other); end

        # @api private
        #
        # Tries to efficiently coerce the given value to one of the known variants.
        #
        # If the value cannot match any of the known variants, the coercion is considered
        # non-viable and returns the original value.
        sig do
          override
            .params(
              value: T.anything,
              state: Anthropic::Internal::Type::Converter::CoerceState
            ).returns(T.anything)
        end
        def coerce(value, state:); end

        # @api private
        sig do
          override
            .params(
              value: T.anything,
              state: Anthropic::Internal::Type::Converter::DumpState
            ).returns(T.anything)
        end
        def dump(value, state:); end

        sig { returns(Integer) }
        def hash; end

        # @api private
        sig { params(depth: Integer).returns(String) }
        def inspect(depth: 0); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        # All of the specified variants for this union.
        sig { overridable.returns(T::Array[T.anything]) }
        def variants; end

        protected

        # @api private
        sig { returns(T::Array[[T.nilable(Symbol), T.anything]]) }
        def derefed_variants; end

        private

        # @api private
        sig { params(property: Symbol).void }
        def discriminator(property); end

        # @api private
        #
        # All of the specified variant info for this union.
        sig do
          returns(T::Array[
              [
                T.nilable(Symbol),
                T.proc.returns(Anthropic::Internal::Type::Converter::Input)
              ]
            ])
        end
        def known_variants; end

        # @api private
        sig { params(value: T.anything).returns(T.nilable(T.anything)) }
        def resolve_variant(value); end

        # @api private
        sig do
          params(
            key: T.any(
                Symbol,
                Anthropic::Internal::AnyHash,
                T.proc.returns(T.anything),
                T.anything
              ),
            spec: T.any(
                Anthropic::Internal::AnyHash,
                T.proc.returns(T.anything),
                T.anything
              )
          ).void
        end
        def variant(key, spec = nil); end
      end

      # @api private
      #
      # When we don't know what to expect for the value.
      class Unknown
        extend Anthropic::Internal::Type::Converter
        extend Anthropic::Internal::Util::SorbetRuntimeSupport

        abstract!

        class << self
          # @api private
          #
          # No coercion needed for Unknown type.
          sig do
            override
              .params(
                value: T.anything,
                state: Anthropic::Internal::Type::Converter::CoerceState
              ).returns(T.anything)
          end
          def coerce(value, state:); end

          # @api private
          sig do
            override
              .params(
                value: T.anything,
                state: Anthropic::Internal::Type::Converter::DumpState
              ).returns(T.anything)
          end
          def dump(value, state:); end

          # @api private
          sig { returns(T.anything) }
          def to_sorbet_type; end
        end

        class << self
          sig { params(other: T.anything).returns(T::Boolean) }
          def ==(other); end

          sig { params(other: T.anything).returns(T::Boolean) }
          def ===(other); end
        end
      end
    end

    # @api private
    module Util
      extend Anthropic::Internal::Util::SorbetRuntimeSupport

      class << self
        # @api private
        sig { returns(String) }
        def arch; end

        # @api private
        sig { returns(String) }
        def os; end
      end

      class << self
        # @api private
        sig { params(input: T.any(String, T::Boolean)).returns(T.any(T::Boolean, T.anything)) }
        def coerce_boolean(input); end

        # @api private
        sig { params(input: T.any(String, T::Boolean)).returns(T.nilable(T::Boolean)) }
        def coerce_boolean!(input); end

        # @api private
        sig { params(input: T.any(String, Integer, Float)).returns(T.any(Float, T.anything)) }
        def coerce_float(input); end

        # @api private
        sig { params(input: T.anything).returns(T.any(T::Hash[T.anything, T.anything], T.anything)) }
        def coerce_hash(input); end

        # @api private
        sig { params(input: T.anything).returns(T.nilable(T::Hash[T.anything, T.anything])) }
        def coerce_hash!(input); end

        # @api private
        sig { params(input: T.any(String, Integer)).returns(T.any(Integer, T.anything)) }
        def coerce_integer(input); end

        # @api private
        sig { params(input: T.anything).returns(T::Boolean) }
        def primitive?(input); end
      end

      class << self
        # @api private
        #
        # Recursively merge one hash with another. If the values at a given key are not
        # both hashes, just take the new value.
        sig do
          params(
            values: T::Array[T.anything],
            sentinel: T.nilable(T.anything),
            concat: T::Boolean
          ).returns(T.anything)
        end
        def deep_merge(
          *values,
          sentinel: nil, # the value to return if no values are provided.
          concat: false # whether to merge sequences by concatenation.
); end

        # @api private
        sig do
          params(
            data: T.any(
                Anthropic::Internal::AnyHash,
                T::Array[T.anything],
                T.anything
              ),
            pick: T.nilable(
                T.any(
                  Symbol,
                  Integer,
                  T::Array[T.any(Symbol, Integer)],
                  T.proc.params(arg0: T.anything).returns(T.anything)
                )
              ),
            blk: T.nilable(T.proc.returns(T.anything))
          ).returns(T.nilable(T.anything))
        end
        def dig(data, pick, &blk); end

        private

        # @api private
        sig { params(lhs: T.anything, rhs: T.anything, concat: T::Boolean).returns(T.anything) }
        def deep_merge_lr(lhs, rhs, concat: false); end
      end

      class << self
        # @api private
        sig { params(path: T.any(String, T::Array[String])).returns(String) }
        def interpolate_path(path); end

        # @api private
        sig { params(uri: URI::Generic).returns(String) }
        def uri_origin(uri); end
      end

      class << self
        # @api private
        sig { params(query: T.nilable(String)).returns(T::Hash[String, T::Array[String]]) }
        def decode_query(query); end

        # @api private
        sig do
          params(
            query: T.nilable(
                T::Hash[String, T.nilable(T.any(T::Array[String], String))]
              )
          ).returns(T.nilable(String))
        end
        def encode_query(query); end
      end

      class << self
        # @api private
        sig do
          params(
            lhs: Anthropic::Internal::Util::ParsedUri,
            rhs: Anthropic::Internal::Util::ParsedUri
          ).returns(URI::Generic)
        end
        def join_parsed_uri(lhs, rhs); end

        # @api private
        sig { params(url: T.any(URI::Generic, String)).returns(Anthropic::Internal::Util::ParsedUri) }
        def parse_uri(url); end

        # @api private
        sig { params(parsed: Anthropic::Internal::Util::ParsedUri).returns(URI::Generic) }
        def unparse_uri(parsed); end
      end

      class << self
        # @api private
        sig do
          params(
            headers: T::Hash[
                String,
                T.nilable(
                  T.any(
                    String,
                    Integer,
                    T::Array[T.nilable(T.any(String, Integer))]
                  )
                )
              ]
          ).returns(T::Hash[String, String])
        end
        def normalized_headers(*headers); end
      end

      class << self
        sig { params(blk: T.proc.params(y: Enumerator::Yielder).void).returns(T::Enumerable[String]) }
        def writable_enum(&blk); end
      end

      class << self
        # @api private
        #
        # Assumes each chunk in stream has `Encoding::BINARY`.
        sig do
          params(
            headers: T.any(T::Hash[String, String], Net::HTTPHeader),
            stream: T::Enumerable[String],
            suppress_error: T::Boolean
          ).returns(T.anything)
        end
        def decode_content(headers, stream:, suppress_error: false); end

        # @api private
        sig { params(headers: T::Hash[String, String], body: T.anything).returns(T.anything) }
        def encode_content(headers, body); end

        # @api private
        #
        # https://www.iana.org/assignments/character-sets/character-sets.xhtml
        sig { params(content_type: String, text: String).void }
        def force_charset!(content_type, text:); end

        private

        # @api private
        #
        # https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.1.md#special-considerations-for-multipart-content
        sig { params(body: T.anything).returns([String, T::Enumerable[String]]) }
        def encode_multipart_streaming(body); end

        # @api private
        sig do
          params(
            y: Enumerator::Yielder,
            boundary: String,
            key: T.any(Symbol, String),
            val: T.anything,
            closing: T::Array[T.proc.void]
          ).void
        end
        def write_multipart_chunk(y, boundary:, key:, val:, closing:); end

        # @api private
        sig do
          params(
            y: Enumerator::Yielder,
            val: T.anything,
            closing: T::Array[T.proc.void],
            content_type: T.nilable(String)
          ).void
        end
        def write_multipart_content(y, val:, closing:, content_type: nil); end
      end

      class << self
        # @api private
        sig do
          params(
            enum: T.nilable(T::Enumerable[T.anything]),
            blk: T.proc.params(arg0: Enumerator::Yielder).void
          ).returns(T::Enumerable[T.anything])
        end
        def chain_fused(enum, &blk); end

        # @api private
        sig { params(enum: T.nilable(T::Enumerable[T.anything])).void }
        def close_fused!(enum); end

        # @api private
        #
        # https://doc.rust-lang.org/std/iter/trait.FusedIterator.html
        sig do
          params(
            enum: T::Enumerable[T.anything],
            external: T::Boolean,
            close: T.proc.void
          ).returns(T::Enumerable[T.anything])
        end
        def fused_enum(enum, external: false, &close); end
      end

      class << self
        # @api private
        #
        # Assumes Strings have been forced into having `Encoding::BINARY`.
        #
        # This decoder is responsible for reassembling lines split across multiple
        # fragments.
        sig { params(enum: T::Enumerable[String]).returns(T::Enumerable[String]) }
        def decode_lines(enum); end

        # @api private
        #
        # https://html.spec.whatwg.org/multipage/server-sent-events.html#parsing-an-event-stream
        #
        # Assumes that `lines` has been decoded with `#decode_lines`.
        sig { params(lines: T::Enumerable[String]).returns(T::Enumerable[Anthropic::Internal::Util::ServerSentEvent]) }
        def decode_sse(lines); end
      end

      class << self
        # @api private
        sig { returns(Float) }
        def monotonic_secs; end

        # @api private
        sig do
          params(
            ns: T.any(Module, T::Class[T.anything])
          ).returns(T::Enumerable[T.any(Module, T::Class[T.anything])])
        end
        def walk_namespaces(ns); end
      end

      JSONL_CONTENT = T.let(%r{^application/(:?x-(?:n|l)djson)|(:?(?:x-)?jsonl)}, Regexp)

      JSON_CONTENT = T.let(%r{^application/(?:vnd(?:\.[^.]+)*\+)?json(?!l)}, Regexp)

      ParsedUri = T.type_alias do
          {
            scheme: T.nilable(String),
            host: T.nilable(String),
            port: T.nilable(Integer),
            path: T.nilable(String),
            query: T::Hash[String, T::Array[String]]
          }
        end

      # @api private
      #
      # An adapter that satisfies the IO interface required by `::IO.copy_stream`
      class ReadIOAdapter
        # @api private
        sig { void }
        def close; end

        # @api private
        sig { returns(T.nilable(T::Boolean)) }
        def close?; end

        # @api private
        sig { params(max_len: T.nilable(Integer), out_string: T.nilable(String)).returns(T.nilable(String)) }
        def read(max_len = nil, out_string = nil); end

        private

        # @api private
        sig { params(max_len: T.nilable(Integer)).returns(String) }
        def read_enum(max_len); end

        class << self
          # @api private
          sig do
            params(
              src: T.any(String, Pathname, StringIO, T::Enumerable[String]),
              blk: T.proc.params(arg0: String).void
            ).returns(T.attached_class)
          end
          def new(src, &blk); end
        end
      end

      ServerSentEvent = T.type_alias do
          {
            event: T.nilable(String),
            data: T.nilable(String),
            id: T.nilable(String),
            retry: T.nilable(Integer)
          }
        end

      # @api private
      module SorbetRuntimeSupport
        # @api private
        sig { params(name: Symbol).void }
        def const_missing(name); end

        # @api private
        sig { params(name: Symbol, blk: T.proc.returns(T.anything)).void }
        def define_sorbet_constant!(name, &blk); end

        # @api private
        sig { params(name: Symbol).returns(T::Boolean) }
        def sorbet_constant_defined?(name); end

        # @api private
        sig { returns(T.anything) }
        def to_sorbet_type; end

        private

        # @api private
        sig { returns(T::Hash[Symbol, T.anything]) }
        def sorbet_runtime_constants; end

        class << self
          # @api private
          sig do
            params(
              type: T.any(
                  Anthropic::Internal::Util::SorbetRuntimeSupport,
                  T.anything
                )
            ).returns(T.anything)
          end
          def to_sorbet_type(type); end
        end

        class MissingSorbetRuntimeError < ::RuntimeError; end
      end
    end
  end

  InvalidRequestError = Anthropic::Models::InvalidRequestError
  Message = Anthropic::Models::Message
  MessageCountTokensParams = Anthropic::Models::MessageCountTokensParams
  MessageCountTokensTool = Anthropic::Models::MessageCountTokensTool
  MessageCreateParams = Anthropic::Models::MessageCreateParams
  MessageDeltaUsage = Anthropic::Models::MessageDeltaUsage
  MessageParam = Anthropic::Models::MessageParam
  MessageTokensCount = Anthropic::Models::MessageTokensCount
  Messages = Anthropic::Models::Messages
  Metadata = Anthropic::Models::Metadata
  Model = Anthropic::Models::Model
  ModelInfo = Anthropic::Models::ModelInfo
  ModelListParams = Anthropic::Models::ModelListParams
  ModelRetrieveParams = Anthropic::Models::ModelRetrieveParams

  module Models
    class APIErrorObject < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :api_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::APIErrorObject, Anthropic::Internal::AnyHash)
        end
    end

    module AnthropicBeta
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::AnthropicBeta::Variants]) }
        def variants; end
      end

      CODE_EXECUTION_2025_05_22 = T.let(
          :"code-execution-2025-05-22",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      COMPUTER_USE_2024_10_22 = T.let(
          :"computer-use-2024-10-22",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      COMPUTER_USE_2025_01_24 = T.let(
          :"computer-use-2025-01-24",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      DEV_FULL_THINKING_2025_05_14 = T.let(
          :"dev-full-thinking-2025-05-14",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      EXTENDED_CACHE_TTL_2025_04_11 = T.let(
          :"extended-cache-ttl-2025-04-11",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      FILES_API_2025_04_14 = T.let(:"files-api-2025-04-14", Anthropic::AnthropicBeta::TaggedSymbol)

      INTERLEAVED_THINKING_2025_05_14 = T.let(
          :"interleaved-thinking-2025-05-14",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      MCP_CLIENT_2025_04_04 = T.let(:"mcp-client-2025-04-04", Anthropic::AnthropicBeta::TaggedSymbol)

      MESSAGE_BATCHES_2024_09_24 = T.let(
          :"message-batches-2024-09-24",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      OUTPUT_128K_2025_02_19 = T.let(:"output-128k-2025-02-19", Anthropic::AnthropicBeta::TaggedSymbol)

      OrSymbol = T.type_alias { T.any(Symbol, String) }

      PDFS_2024_09_25 = T.let(:"pdfs-2024-09-25", Anthropic::AnthropicBeta::TaggedSymbol)

      PROMPT_CACHING_2024_07_31 = T.let(
          :"prompt-caching-2024-07-31",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      TOKEN_COUNTING_2024_11_01 = T.let(
          :"token-counting-2024-11-01",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      TOKEN_EFFICIENT_TOOLS_2025_02_19 = T.let(
          :"token-efficient-tools-2025-02-19",
          Anthropic::AnthropicBeta::TaggedSymbol
        )

      TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::AnthropicBeta) }

      Variants = T.type_alias { T.any(String, Anthropic::AnthropicBeta::TaggedSymbol) }
    end

    class AuthenticationError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :authentication_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::AuthenticationError, Anthropic::Internal::AnyHash)
        end
    end

    class Base64ImageSource < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :data

      sig { returns(Anthropic::Base64ImageSource::MediaType::OrSymbol) }
      attr_accessor :media_type

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            data: String,
            media_type: Anthropic::Base64ImageSource::MediaType::OrSymbol,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            data: String,
            media_type: Anthropic::Base64ImageSource::MediaType::OrSymbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(data:, media_type:, type: :base64); end
      end

      module MediaType
        extend Anthropic::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Anthropic::Base64ImageSource::MediaType::TaggedSymbol]) }
          def values; end
        end

        IMAGE_GIF = T.let(
            :"image/gif",
            Anthropic::Base64ImageSource::MediaType::TaggedSymbol
          )

        IMAGE_JPEG = T.let(
            :"image/jpeg",
            Anthropic::Base64ImageSource::MediaType::TaggedSymbol
          )

        IMAGE_PNG = T.let(
            :"image/png",
            Anthropic::Base64ImageSource::MediaType::TaggedSymbol
          )

        IMAGE_WEBP = T.let(
            :"image/webp",
            Anthropic::Base64ImageSource::MediaType::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Anthropic::Base64ImageSource::MediaType)
          end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::Base64ImageSource, Anthropic::Internal::AnyHash)
        end
    end

    class Base64PDFSource < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :data

      sig { returns(Symbol) }
      attr_accessor :media_type

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ data: String, media_type: Symbol, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(data: String, media_type: Symbol, type: Symbol).returns(T.attached_class) }
        def new(data:, media_type: :"application/pdf", type: :base64); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::Base64PDFSource, Anthropic::Internal::AnyHash)
        end
    end

    module Beta
      class BetaBase64ImageSource < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :data

        sig { returns(Anthropic::Beta::BetaBase64ImageSource::MediaType::OrSymbol) }
        attr_accessor :media_type

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              data: String,
              media_type:
                Anthropic::Beta::BetaBase64ImageSource::MediaType::OrSymbol,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              data: String,
              media_type: Anthropic::Beta::BetaBase64ImageSource::MediaType::OrSymbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(data:, media_type:, type: :base64); end
        end

        module MediaType
          extend Anthropic::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaBase64ImageSource::MediaType::TaggedSymbol
              ])
            end
            def values; end
          end

          IMAGE_GIF = T.let(
              :"image/gif",
              Anthropic::Beta::BetaBase64ImageSource::MediaType::TaggedSymbol
            )

          IMAGE_JPEG = T.let(
              :"image/jpeg",
              Anthropic::Beta::BetaBase64ImageSource::MediaType::TaggedSymbol
            )

          IMAGE_PNG = T.let(
              :"image/png",
              Anthropic::Beta::BetaBase64ImageSource::MediaType::TaggedSymbol
            )

          IMAGE_WEBP = T.let(
              :"image/webp",
              Anthropic::Beta::BetaBase64ImageSource::MediaType::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Anthropic::Beta::BetaBase64ImageSource::MediaType)
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaBase64ImageSource,
              Anthropic::Internal::AnyHash
            )
          end
      end

      BetaBase64PDFBlock = Anthropic::Models::Beta::BetaRequestDocumentBlock

      class BetaBase64PDFSource < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :data

        sig { returns(Symbol) }
        attr_accessor :media_type

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ data: String, media_type: Symbol, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(data: String, media_type: Symbol, type: Symbol).returns(T.attached_class) }
          def new(data:, media_type: :"application/pdf", type: :base64); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaBase64PDFSource,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCacheControlEphemeral < Anthropic::Internal::Type::BaseModel
        # The time-to-live for the cache control breakpoint.
        #
        # This may be one the following values:
        #
        # - `5m`: 5 minutes
        # - `1h`: 1 hour
        #
        # Defaults to `5m`.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::TTL::OrSymbol)) }
        attr_reader :ttl

        sig { params(ttl: Anthropic::Beta::BetaCacheControlEphemeral::TTL::OrSymbol).void }
        attr_writer :ttl

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              type: Symbol,
              ttl: Anthropic::Beta::BetaCacheControlEphemeral::TTL::OrSymbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              ttl: Anthropic::Beta::BetaCacheControlEphemeral::TTL::OrSymbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            ttl: nil, # The time-to-live for the cache control breakpoint.
                      # This may be one the following values:
                      # - `5m`: 5 minutes
                      # - `1h`: 1 hour
                      # Defaults to `5m`.
            type: :ephemeral
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCacheControlEphemeral,
              Anthropic::Internal::AnyHash
            )
          end

        # The time-to-live for the cache control breakpoint.
        #
        # This may be one the following values:
        #
        # - `5m`: 5 minutes
        # - `1h`: 1 hour
        #
        # Defaults to `5m`.
        module TTL
          extend Anthropic::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaCacheControlEphemeral::TTL::TaggedSymbol
              ])
            end
            def values; end
          end

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TTL_1H = T.let(
              :"1h",
              Anthropic::Beta::BetaCacheControlEphemeral::TTL::TaggedSymbol
            )

          TTL_5M = T.let(
              :"5m",
              Anthropic::Beta::BetaCacheControlEphemeral::TTL::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Anthropic::Beta::BetaCacheControlEphemeral::TTL)
            end
        end
      end

      class BetaCacheCreation < Anthropic::Internal::Type::BaseModel
        # The number of input tokens used to create the 1 hour cache entry.
        sig { returns(Integer) }
        attr_accessor :ephemeral_1h_input_tokens

        # The number of input tokens used to create the 5 minute cache entry.
        sig { returns(Integer) }
        attr_accessor :ephemeral_5m_input_tokens

        sig do
          override
            .returns({
              ephemeral_1h_input_tokens: Integer,
              ephemeral_5m_input_tokens: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              ephemeral_1h_input_tokens: Integer,
              ephemeral_5m_input_tokens: Integer
            ).returns(T.attached_class)
          end
          def new(
            ephemeral_1h_input_tokens:, # The number of input tokens used to create the 1 hour cache entry.
            ephemeral_5m_input_tokens: # The number of input tokens used to create the 5 minute cache entry.
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCacheCreation,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationCharLocation < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(Integer) }
        attr_accessor :document_index

        sig { returns(T.nilable(String)) }
        attr_accessor :document_title

        sig { returns(Integer) }
        attr_accessor :end_char_index

        sig { returns(T.nilable(String)) }
        attr_accessor :file_id

        sig { returns(Integer) }
        attr_accessor :start_char_index

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_char_index: Integer,
              file_id: T.nilable(String),
              start_char_index: Integer,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_char_index: Integer,
              file_id: T.nilable(String),
              start_char_index: Integer,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, document_index:, document_title:, end_char_index:, file_id:, start_char_index:, type: :char_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationCharLocation,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationCharLocationParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(Integer) }
        attr_accessor :document_index

        sig { returns(T.nilable(String)) }
        attr_accessor :document_title

        sig { returns(Integer) }
        attr_accessor :end_char_index

        sig { returns(Integer) }
        attr_accessor :start_char_index

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_char_index: Integer,
              start_char_index: Integer,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_char_index: Integer,
              start_char_index: Integer,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, document_index:, document_title:, end_char_index:, start_char_index:, type: :char_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationCharLocationParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationContentBlockLocation < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(Integer) }
        attr_accessor :document_index

        sig { returns(T.nilable(String)) }
        attr_accessor :document_title

        sig { returns(Integer) }
        attr_accessor :end_block_index

        sig { returns(T.nilable(String)) }
        attr_accessor :file_id

        sig { returns(Integer) }
        attr_accessor :start_block_index

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_block_index: Integer,
              file_id: T.nilable(String),
              start_block_index: Integer,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_block_index: Integer,
              file_id: T.nilable(String),
              start_block_index: Integer,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, document_index:, document_title:, end_block_index:, file_id:, start_block_index:, type: :content_block_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationContentBlockLocation,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationContentBlockLocationParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(Integer) }
        attr_accessor :document_index

        sig { returns(T.nilable(String)) }
        attr_accessor :document_title

        sig { returns(Integer) }
        attr_accessor :end_block_index

        sig { returns(Integer) }
        attr_accessor :start_block_index

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_block_index: Integer,
              start_block_index: Integer,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_block_index: Integer,
              start_block_index: Integer,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, document_index:, document_title:, end_block_index:, start_block_index:, type: :content_block_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationContentBlockLocationParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationPageLocation < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(Integer) }
        attr_accessor :document_index

        sig { returns(T.nilable(String)) }
        attr_accessor :document_title

        sig { returns(Integer) }
        attr_accessor :end_page_number

        sig { returns(T.nilable(String)) }
        attr_accessor :file_id

        sig { returns(Integer) }
        attr_accessor :start_page_number

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_page_number: Integer,
              file_id: T.nilable(String),
              start_page_number: Integer,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_page_number: Integer,
              file_id: T.nilable(String),
              start_page_number: Integer,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, document_index:, document_title:, end_page_number:, file_id:, start_page_number:, type: :page_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationPageLocation,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationPageLocationParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(Integer) }
        attr_accessor :document_index

        sig { returns(T.nilable(String)) }
        attr_accessor :document_title

        sig { returns(Integer) }
        attr_accessor :end_page_number

        sig { returns(Integer) }
        attr_accessor :start_page_number

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_page_number: Integer,
              start_page_number: Integer,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              document_index: Integer,
              document_title: T.nilable(String),
              end_page_number: Integer,
              start_page_number: Integer,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, document_index:, document_title:, end_page_number:, start_page_number:, type: :page_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationPageLocationParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationSearchResultLocation < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(Integer) }
        attr_accessor :end_block_index

        sig { returns(Integer) }
        attr_accessor :search_result_index

        sig { returns(String) }
        attr_accessor :source

        sig { returns(Integer) }
        attr_accessor :start_block_index

        sig { returns(T.nilable(String)) }
        attr_accessor :title

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              cited_text: String,
              end_block_index: Integer,
              search_result_index: Integer,
              source: String,
              start_block_index: Integer,
              title: T.nilable(String),
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              end_block_index: Integer,
              search_result_index: Integer,
              source: String,
              start_block_index: Integer,
              title: T.nilable(String),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, end_block_index:, search_result_index:, source:, start_block_index:, title:, type: :search_result_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationSearchResultLocation,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationSearchResultLocationParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(Integer) }
        attr_accessor :end_block_index

        sig { returns(Integer) }
        attr_accessor :search_result_index

        sig { returns(String) }
        attr_accessor :source

        sig { returns(Integer) }
        attr_accessor :start_block_index

        sig { returns(T.nilable(String)) }
        attr_accessor :title

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              cited_text: String,
              end_block_index: Integer,
              search_result_index: Integer,
              source: String,
              start_block_index: Integer,
              title: T.nilable(String),
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              end_block_index: Integer,
              search_result_index: Integer,
              source: String,
              start_block_index: Integer,
              title: T.nilable(String),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, end_block_index:, search_result_index:, source:, start_block_index:, title:, type: :search_result_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationSearchResultLocationParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationWebSearchResultLocationParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(String) }
        attr_accessor :encrypted_index

        sig { returns(T.nilable(String)) }
        attr_accessor :title

        sig { returns(Symbol) }
        attr_accessor :type

        sig { returns(String) }
        attr_accessor :url

        sig do
          override
            .returns({
              cited_text: String,
              encrypted_index: String,
              title: T.nilable(String),
              type: Symbol,
              url: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              encrypted_index: String,
              title: T.nilable(String),
              url: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, encrypted_index:, title:, url:, type: :web_search_result_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationWebSearchResultLocationParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationsConfigParam < Anthropic::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :enabled

        sig { params(enabled: T::Boolean).void }
        attr_writer :enabled

        sig { override.returns({ enabled: T::Boolean }) }
        def to_hash; end

        class << self
          sig { params(enabled: T::Boolean).returns(T.attached_class) }
          def new(enabled: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationsConfigParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationsDelta < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaCitationsDelta::Citation::Variants) }
        attr_accessor :citation

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              citation: Anthropic::Beta::BetaCitationsDelta::Citation::Variants,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              citation: T.any(
                Anthropic::Beta::BetaCitationCharLocation::OrHash,
                Anthropic::Beta::BetaCitationPageLocation::OrHash,
                Anthropic::Beta::BetaCitationContentBlockLocation::OrHash,
                Anthropic::Beta::BetaCitationsWebSearchResultLocation::OrHash,
                Anthropic::Beta::BetaCitationSearchResultLocation::OrHash
              ),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(citation:, type: :citations_delta); end
        end

        module Citation
          extend Anthropic::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Anthropic::Beta::BetaCitationsDelta::Citation::Variants]) }
            def variants; end
          end

          Variants = T.type_alias do
              T.any(
                Anthropic::Beta::BetaCitationCharLocation,
                Anthropic::Beta::BetaCitationPageLocation,
                Anthropic::Beta::BetaCitationContentBlockLocation,
                Anthropic::Beta::BetaCitationsWebSearchResultLocation,
                Anthropic::Beta::BetaCitationSearchResultLocation
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationsDelta,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCitationsWebSearchResultLocation < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :cited_text

        sig { returns(String) }
        attr_accessor :encrypted_index

        sig { returns(T.nilable(String)) }
        attr_accessor :title

        sig { returns(Symbol) }
        attr_accessor :type

        sig { returns(String) }
        attr_accessor :url

        sig do
          override
            .returns({
              cited_text: String,
              encrypted_index: String,
              title: T.nilable(String),
              type: Symbol,
              url: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cited_text: String,
              encrypted_index: String,
              title: T.nilable(String),
              url: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(cited_text:, encrypted_index:, title:, url:, type: :web_search_result_location); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationsWebSearchResultLocation,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCodeExecutionOutputBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :file_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ file_id: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(file_id: String, type: Symbol).returns(T.attached_class) }
          def new(file_id:, type: :code_execution_output); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionOutputBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCodeExecutionOutputBlockParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :file_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ file_id: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(file_id: String, type: Symbol).returns(T.attached_class) }
          def new(file_id:, type: :code_execution_output); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionOutputBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCodeExecutionResultBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(T::Array[Anthropic::Beta::BetaCodeExecutionOutputBlock]) }
        attr_accessor :content

        sig { returns(Integer) }
        attr_accessor :return_code

        sig { returns(String) }
        attr_accessor :stderr

        sig { returns(String) }
        attr_accessor :stdout

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content: T::Array[Anthropic::Beta::BetaCodeExecutionOutputBlock],
              return_code: Integer,
              stderr: String,
              stdout: String,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: T::Array[Anthropic::Beta::BetaCodeExecutionOutputBlock::OrHash],
              return_code: Integer,
              stderr: String,
              stdout: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(content:, return_code:, stderr:, stdout:, type: :code_execution_result); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionResultBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCodeExecutionResultBlockParam < Anthropic::Internal::Type::BaseModel
        sig { returns(T::Array[Anthropic::Beta::BetaCodeExecutionOutputBlockParam]) }
        attr_accessor :content

        sig { returns(Integer) }
        attr_accessor :return_code

        sig { returns(String) }
        attr_accessor :stderr

        sig { returns(String) }
        attr_accessor :stdout

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content:
                T::Array[Anthropic::Beta::BetaCodeExecutionOutputBlockParam],
              return_code: Integer,
              stderr: String,
              stdout: String,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: T::Array[
                Anthropic::Beta::BetaCodeExecutionOutputBlockParam::OrHash
              ],
              return_code: Integer,
              stderr: String,
              stdout: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(content:, return_code:, stderr:, stdout:, type: :code_execution_result); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionResultBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCodeExecutionTool20250522 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            cache_control: nil, # Create a cache control breakpoint at this content block.
            name: :code_execution, # Name of the tool.
                                   # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :code_execution_20250522
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionTool20250522,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaCodeExecutionToolResultBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaCodeExecutionToolResultBlockContent::Variants) }
        attr_accessor :content

        sig { returns(String) }
        attr_accessor :tool_use_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content:
                Anthropic::Beta::BetaCodeExecutionToolResultBlockContent::Variants,
              tool_use_id: String,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: T.any(
                Anthropic::Beta::BetaCodeExecutionToolResultError::OrHash,
                Anthropic::Beta::BetaCodeExecutionResultBlock::OrHash
              ),
              tool_use_id: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(content:, tool_use_id:, type: :code_execution_tool_result); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionToolResultBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaCodeExecutionToolResultBlockContent
        extend Anthropic::Internal::Type::Union

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::Beta::BetaCodeExecutionToolResultBlockContent::Variants
            ])
          end
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionToolResultError,
              Anthropic::Beta::BetaCodeExecutionResultBlock
            )
          end
      end

      class BetaCodeExecutionToolResultBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig do
          returns(T.any(
              Anthropic::Beta::BetaCodeExecutionToolResultErrorParam,
              Anthropic::Beta::BetaCodeExecutionResultBlockParam
            ))
        end
        attr_accessor :content

        sig { returns(String) }
        attr_accessor :tool_use_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content:
                T.any(
                  Anthropic::Beta::BetaCodeExecutionToolResultErrorParam,
                  Anthropic::Beta::BetaCodeExecutionResultBlockParam
                ),
              tool_use_id: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: T.any(
                Anthropic::Beta::BetaCodeExecutionToolResultErrorParam::OrHash,
                Anthropic::Beta::BetaCodeExecutionResultBlockParam::OrHash
              ),
              tool_use_id: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            content:,
            tool_use_id:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            type: :code_execution_tool_result
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionToolResultBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaCodeExecutionToolResultBlockParamContent
        extend Anthropic::Internal::Type::Union

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::Beta::BetaCodeExecutionToolResultBlockParamContent::Variants
            ])
          end
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionToolResultErrorParam,
              Anthropic::Beta::BetaCodeExecutionResultBlockParam
            )
          end
      end

      class BetaCodeExecutionToolResultError < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::TaggedSymbol) }
        attr_accessor :error_code

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              error_code:
                Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::TaggedSymbol,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              error_code: Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::OrSymbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(error_code:, type: :code_execution_tool_result_error); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionToolResultError,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaCodeExecutionToolResultErrorCode
        extend Anthropic::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::TaggedSymbol
            ])
          end
          def values; end
        end

        EXECUTION_TIME_EXCEEDED = T.let(
            :execution_time_exceeded,
            Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::TaggedSymbol
          )

        INVALID_TOOL_INPUT = T.let(
            :invalid_tool_input,
            Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TOO_MANY_REQUESTS = T.let(
            :too_many_requests,
            Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::TaggedSymbol
          )

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Anthropic::Beta::BetaCodeExecutionToolResultErrorCode)
          end

        UNAVAILABLE = T.let(
            :unavailable,
            Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::TaggedSymbol
          )
      end

      class BetaCodeExecutionToolResultErrorParam < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::OrSymbol) }
        attr_accessor :error_code

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              error_code:
                Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::OrSymbol,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              error_code: Anthropic::Beta::BetaCodeExecutionToolResultErrorCode::OrSymbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(error_code:, type: :code_execution_tool_result_error); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCodeExecutionToolResultErrorParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaContainer < Anthropic::Internal::Type::BaseModel
        # The time at which the container will expire.
        sig { returns(Time) }
        attr_accessor :expires_at

        # Identifier for the container used in this request
        sig { returns(String) }
        attr_accessor :id

        sig { override.returns({ id: String, expires_at: Time }) }
        def to_hash; end

        class << self
          # Information about the container used in the request (for the code execution
          # tool)
          sig { params(id: String, expires_at: Time).returns(T.attached_class) }
          def new(
            id:, # Identifier for the container used in this request
            expires_at: # The time at which the container will expire.
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::BetaContainer, Anthropic::Internal::AnyHash)
          end
      end

      class BetaContainerUploadBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :file_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ file_id: String, type: Symbol }) }
        def to_hash; end

        class << self
          # Response model for a file uploaded to the container.
          sig { params(file_id: String, type: Symbol).returns(T.attached_class) }
          def new(file_id:, type: :container_upload); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaContainerUploadBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaContainerUploadBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig { returns(String) }
        attr_accessor :file_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              file_id: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          # A content block that represents a file to be uploaded to the container Files
          # uploaded via this block will be available in the container's input directory.
          sig do
            params(
              file_id: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            file_id:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            type: :container_upload
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaContainerUploadBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      # Response model for a file uploaded to the container.
      module BetaContentBlock
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaContentBlock::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaTextBlock,
              Anthropic::Beta::BetaThinkingBlock,
              Anthropic::Beta::BetaRedactedThinkingBlock,
              Anthropic::Beta::BetaToolUseBlock,
              Anthropic::Beta::BetaServerToolUseBlock,
              Anthropic::Beta::BetaWebSearchToolResultBlock,
              Anthropic::Beta::BetaCodeExecutionToolResultBlock,
              Anthropic::Beta::BetaMCPToolUseBlock,
              Anthropic::Beta::BetaMCPToolResultBlock,
              Anthropic::Beta::BetaContainerUploadBlock
            )
          end
      end

      # Regular text content.
      module BetaContentBlockParam
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaContentBlockParam::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaTextBlockParam,
              Anthropic::Beta::BetaImageBlockParam,
              Anthropic::Beta::BetaRequestDocumentBlock,
              Anthropic::Beta::BetaSearchResultBlockParam,
              Anthropic::Beta::BetaThinkingBlockParam,
              Anthropic::Beta::BetaRedactedThinkingBlockParam,
              Anthropic::Beta::BetaToolUseBlockParam,
              Anthropic::Beta::BetaToolResultBlockParam,
              Anthropic::Beta::BetaServerToolUseBlockParam,
              Anthropic::Beta::BetaWebSearchToolResultBlockParam,
              Anthropic::Beta::BetaCodeExecutionToolResultBlockParam,
              Anthropic::Beta::BetaMCPToolUseBlockParam,
              Anthropic::Beta::BetaRequestMCPToolResultBlockParam,
              Anthropic::Beta::BetaContainerUploadBlockParam
            )
          end
      end

      class BetaContentBlockSource < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaContentBlockSource::Content::Variants) }
        attr_accessor :content

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content:
                Anthropic::Beta::BetaContentBlockSource::Content::Variants,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: Anthropic::Beta::BetaContentBlockSource::Content::Variants,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(content:, type: :content); end
        end

        module Content
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaContentBlockSource::Content::Variants
              ])
            end
            def variants; end
          end

          BetaContentBlockSourceContentArray = T.let(
              Anthropic::Internal::Type::ArrayOf[
                union: Anthropic::Beta::BetaContentBlockSourceContent
              ],
              Anthropic::Internal::Type::Converter
            )

          Variants = T.type_alias do
              T.any(
                String,
                T::Array[
                  Anthropic::Beta::BetaContentBlockSourceContent::Variants
                ]
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaContentBlockSource,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaContentBlockSourceContent
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaContentBlockSourceContent::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaTextBlockParam,
              Anthropic::Beta::BetaImageBlockParam
            )
          end
      end

      class BetaFileDocumentSource < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :file_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ file_id: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(file_id: String, type: Symbol).returns(T.attached_class) }
          def new(file_id:, type: :file); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaFileDocumentSource,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaFileImageSource < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :file_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ file_id: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(file_id: String, type: Symbol).returns(T.attached_class) }
          def new(file_id:, type: :file); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaFileImageSource,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaImageBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig do
          returns(T.any(
              Anthropic::Beta::BetaBase64ImageSource,
              Anthropic::Beta::BetaURLImageSource,
              Anthropic::Beta::BetaFileImageSource
            ))
        end
        attr_accessor :source

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              source:
                T.any(
                  Anthropic::Beta::BetaBase64ImageSource,
                  Anthropic::Beta::BetaURLImageSource,
                  Anthropic::Beta::BetaFileImageSource
                ),
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              source: T.any(
                Anthropic::Beta::BetaBase64ImageSource::OrHash,
                Anthropic::Beta::BetaURLImageSource::OrHash,
                Anthropic::Beta::BetaFileImageSource::OrHash
              ),
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            source:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            type: :image
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaImageBlockParam,
              Anthropic::Internal::AnyHash
            )
          end

        module Source
          extend Anthropic::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Anthropic::Beta::BetaImageBlockParam::Source::Variants]) }
            def variants; end
          end

          Variants = T.type_alias do
              T.any(
                Anthropic::Beta::BetaBase64ImageSource,
                Anthropic::Beta::BetaURLImageSource,
                Anthropic::Beta::BetaFileImageSource
              )
            end
        end
      end

      class BetaInputJSONDelta < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :partial_json

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ partial_json: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(partial_json: String, type: Symbol).returns(T.attached_class) }
          def new(partial_json:, type: :input_json_delta); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaInputJSONDelta,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaMCPToolResultBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaMCPToolResultBlock::Content::Variants) }
        attr_accessor :content

        sig { returns(T::Boolean) }
        attr_accessor :is_error

        sig { returns(String) }
        attr_accessor :tool_use_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content:
                Anthropic::Beta::BetaMCPToolResultBlock::Content::Variants,
              is_error: T::Boolean,
              tool_use_id: String,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: Anthropic::Beta::BetaMCPToolResultBlock::Content::Variants,
              is_error: T::Boolean,
              tool_use_id: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(content:, is_error:, tool_use_id:, type: :mcp_tool_result); end
        end

        module Content
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaMCPToolResultBlock::Content::Variants
              ])
            end
            def variants; end
          end

          BetaTextBlockArray = T.let(
              Anthropic::Internal::Type::ArrayOf[
                Anthropic::Beta::BetaTextBlock
              ],
              Anthropic::Internal::Type::Converter
            )

          Variants = T.type_alias do
              T.any(String, T::Array[Anthropic::Beta::BetaTextBlock])
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaMCPToolResultBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaMCPToolUseBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :id

        sig { returns(T.anything) }
        attr_accessor :input

        # The name of the MCP tool
        sig { returns(String) }
        attr_accessor :name

        # The name of the MCP server
        sig { returns(String) }
        attr_accessor :server_name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              id: String,
              input: T.anything,
              name: String,
              server_name: String,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: String,
              input: T.anything,
              name: String,
              server_name: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            id:,
            input:,
            name:, # The name of the MCP tool
            server_name:, # The name of the MCP server
            type: :mcp_tool_use
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaMCPToolUseBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaMCPToolUseBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig { returns(String) }
        attr_accessor :id

        sig { returns(T.anything) }
        attr_accessor :input

        sig { returns(String) }
        attr_accessor :name

        # The name of the MCP server
        sig { returns(String) }
        attr_accessor :server_name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              id: String,
              input: T.anything,
              name: String,
              server_name: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: String,
              input: T.anything,
              name: String,
              server_name: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            id:,
            input:,
            name:,
            server_name:, # The name of the MCP server
            cache_control: nil, # Create a cache control breakpoint at this content block.
            type: :mcp_tool_use
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaMCPToolUseBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaMessage < Anthropic::Internal::Type::BaseModel
        # Information about the container used in the request (for the code execution
        # tool)
        sig { returns(T.nilable(Anthropic::Beta::BetaContainer)) }
        attr_reader :container

        sig { params(container: T.nilable(Anthropic::Beta::BetaContainer::OrHash)).void }
        attr_writer :container

        # Content generated by the model.
        #
        # This is an array of content blocks, each of which has a `type` that determines
        # its shape.
        #
        # Example:
        #
        # ```json
        # [{ "type": "text", "text": "Hi, I'm Claude." }]
        # ```
        #
        # If the request input `messages` ended with an `assistant` turn, then the
        # response `content` will continue directly from that last turn. You can use this
        # to constrain the model's output.
        #
        # For example, if the input `messages` were:
        #
        # ```json
        # [
        #   {
        #     "role": "user",
        #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
        #   },
        #   { "role": "assistant", "content": "The best answer is (" }
        # ]
        # ```
        #
        # Then the response `content` might be:
        #
        # ```json
        # [{ "type": "text", "text": "B)" }]
        # ```
        sig { returns(T::Array[Anthropic::Beta::BetaContentBlock::Variants]) }
        attr_accessor :content

        # Unique object identifier.
        #
        # The format and length of IDs may change over time.
        sig { returns(String) }
        attr_accessor :id

        # The model that will complete your prompt.\n\nSee
        # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
        # details and options.
        sig { returns(Anthropic::Model::Variants) }
        attr_accessor :model

        # Conversational role of the generated message.
        #
        # This will always be `"assistant"`.
        sig { returns(Symbol) }
        attr_accessor :role

        # The reason that we stopped.
        #
        # This may be one the following values:
        #
        # - `"end_turn"`: the model reached a natural stopping point
        # - `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
        # - `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
        # - `"tool_use"`: the model invoked one or more tools
        # - `"pause_turn"`: we paused a long-running turn. You may provide the response
        #   back as-is in a subsequent request to let the model continue.
        # - `"refusal"`: when streaming classifiers intervene to handle potential policy
        #   violations
        #
        # In non-streaming mode this value is always non-null. In streaming mode, it is
        # null in the `message_start` event and non-null otherwise.
        sig { returns(T.nilable(Anthropic::Beta::BetaStopReason::TaggedSymbol)) }
        attr_accessor :stop_reason

        # Which custom stop sequence was generated, if any.
        #
        # This value will be a non-null string if one of your custom stop sequences was
        # generated.
        sig { returns(T.nilable(String)) }
        attr_accessor :stop_sequence

        # Object type.
        #
        # For Messages, this is always `"message"`.
        sig { returns(Symbol) }
        attr_accessor :type

        # Billing and rate-limit usage.
        #
        # Anthropic's API bills and rate-limits by token counts, as tokens represent the
        # underlying cost to our systems.
        #
        # Under the hood, the API transforms requests into a format suitable for the
        # model. The model's output then goes through a parsing stage before becoming an
        # API response. As a result, the token counts in `usage` will not match one-to-one
        # with the exact visible content of an API request or response.
        #
        # For example, `output_tokens` will be non-zero, even for an empty string response
        # from Claude.
        #
        # Total input tokens in a request is the summation of `input_tokens`,
        # `cache_creation_input_tokens`, and `cache_read_input_tokens`.
        sig { returns(Anthropic::Beta::BetaUsage) }
        attr_reader :usage

        sig { params(usage: Anthropic::Beta::BetaUsage::OrHash).void }
        attr_writer :usage

        sig do
          override
            .returns({
              id: String,
              container: T.nilable(Anthropic::Beta::BetaContainer),
              content: T::Array[Anthropic::Beta::BetaContentBlock::Variants],
              model: Anthropic::Model::Variants,
              role: Symbol,
              stop_reason:
                T.nilable(Anthropic::Beta::BetaStopReason::TaggedSymbol),
              stop_sequence: T.nilable(String),
              type: Symbol,
              usage: Anthropic::Beta::BetaUsage
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: String,
              container: T.nilable(Anthropic::Beta::BetaContainer::OrHash),
              content: T::Array[
                T.any(
                  Anthropic::Beta::BetaTextBlock::OrHash,
                  Anthropic::Beta::BetaThinkingBlock::OrHash,
                  Anthropic::Beta::BetaRedactedThinkingBlock::OrHash,
                  Anthropic::Beta::BetaToolUseBlock::OrHash,
                  Anthropic::Beta::BetaServerToolUseBlock::OrHash,
                  Anthropic::Beta::BetaWebSearchToolResultBlock::OrHash,
                  Anthropic::Beta::BetaCodeExecutionToolResultBlock::OrHash,
                  Anthropic::Beta::BetaMCPToolUseBlock::OrHash,
                  Anthropic::Beta::BetaMCPToolResultBlock::OrHash,
                  Anthropic::Beta::BetaContainerUploadBlock::OrHash
                )
              ],
              model: T.any(Anthropic::Model::OrSymbol, String),
              stop_reason: T.nilable(Anthropic::Beta::BetaStopReason::OrSymbol),
              stop_sequence: T.nilable(String),
              usage: Anthropic::Beta::BetaUsage::OrHash,
              role: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            id:, # Unique object identifier.
                 # The format and length of IDs may change over time.
            container:, # Information about the container used in the request (for the code execution
                        # tool)
            content:, # Content generated by the model.
                      # This is an array of content blocks, each of which has a `type` that determines
                      # its shape.
                      # Example:
                      # ```json
                      # [{ "type": "text", "text": "Hi, I'm Claude." }]
                      # ```
                      # If the request input `messages` ended with an `assistant` turn, then the
                      # response `content` will continue directly from that last turn. You can use this
                      # to constrain the model's output.
                      # For example, if the input `messages` were:
                      # ```json
                      # [
                      #   {
                      #     "role": "user",
                      #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                      #   },
                      #   { "role": "assistant", "content": "The best answer is (" }
                      # ]
                      # ```
                      # Then the response `content` might be:
                      # ```json
                      # [{ "type": "text", "text": "B)" }]
                      # ```
            model:, # The model that will complete your prompt.\n\nSee
                    # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                    # details and options.
            stop_reason:, # The reason that we stopped.
                          # This may be one the following values:
                          # - `"end_turn"`: the model reached a natural stopping point
                          # - `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
                          # - `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
                          # - `"tool_use"`: the model invoked one or more tools
                          # - `"pause_turn"`: we paused a long-running turn. You may provide the response
                          #   back as-is in a subsequent request to let the model continue.
                          # - `"refusal"`: when streaming classifiers intervene to handle potential policy
                          #   violations
                          # In non-streaming mode this value is always non-null. In streaming mode, it is
                          # null in the `message_start` event and non-null otherwise.
            stop_sequence:, # Which custom stop sequence was generated, if any.
                            # This value will be a non-null string if one of your custom stop sequences was
                            # generated.
            usage:, # Billing and rate-limit usage.
                    # Anthropic's API bills and rate-limits by token counts, as tokens represent the
                    # underlying cost to our systems.
                    # Under the hood, the API transforms requests into a format suitable for the
                    # model. The model's output then goes through a parsing stage before becoming an
                    # API response. As a result, the token counts in `usage` will not match one-to-one
                    # with the exact visible content of an API request or response.
                    # For example, `output_tokens` will be non-zero, even for an empty string response
                    # from Claude.
                    # Total input tokens in a request is the summation of `input_tokens`,
                    # `cache_creation_input_tokens`, and `cache_read_input_tokens`.
            role: :assistant, # Conversational role of the generated message.
                              # This will always be `"assistant"`.
            type: :message # Object type.
                           # For Messages, this is always `"message"`.
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::BetaMessage, Anthropic::Internal::AnyHash)
          end
      end

      class BetaMessageDeltaUsage < Anthropic::Internal::Type::BaseModel
        # The cumulative number of input tokens used to create the cache entry.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :cache_creation_input_tokens

        # The cumulative number of input tokens read from the cache.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :cache_read_input_tokens

        # The cumulative number of input tokens which were used.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :input_tokens

        # The cumulative number of output tokens which were used.
        sig { returns(Integer) }
        attr_accessor :output_tokens

        # The number of server tool requests.
        sig { returns(T.nilable(Anthropic::Beta::BetaServerToolUsage)) }
        attr_reader :server_tool_use

        sig { params(server_tool_use: T.nilable(Anthropic::Beta::BetaServerToolUsage::OrHash)).void }
        attr_writer :server_tool_use

        sig do
          override
            .returns({
              cache_creation_input_tokens: T.nilable(Integer),
              cache_read_input_tokens: T.nilable(Integer),
              input_tokens: T.nilable(Integer),
              output_tokens: Integer,
              server_tool_use: T.nilable(Anthropic::Beta::BetaServerToolUsage)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_creation_input_tokens: T.nilable(Integer),
              cache_read_input_tokens: T.nilable(Integer),
              input_tokens: T.nilable(Integer),
              output_tokens: Integer,
              server_tool_use: T.nilable(Anthropic::Beta::BetaServerToolUsage::OrHash)
            ).returns(T.attached_class)
          end
          def new(
            cache_creation_input_tokens:, # The cumulative number of input tokens used to create the cache entry.
            cache_read_input_tokens:, # The cumulative number of input tokens read from the cache.
            input_tokens:, # The cumulative number of input tokens which were used.
            output_tokens:, # The cumulative number of output tokens which were used.
            server_tool_use: # The number of server tool requests.
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaMessageDeltaUsage,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaMessageParam < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaMessageParam::Content::Variants) }
        attr_accessor :content

        sig { returns(Anthropic::Beta::BetaMessageParam::Role::OrSymbol) }
        attr_accessor :role

        sig do
          override
            .returns({
              content: Anthropic::Beta::BetaMessageParam::Content::Variants,
              role: Anthropic::Beta::BetaMessageParam::Role::OrSymbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: Anthropic::Beta::BetaMessageParam::Content::Variants,
              role: Anthropic::Beta::BetaMessageParam::Role::OrSymbol
            ).returns(T.attached_class)
          end
          def new(content:, role:); end
        end

        module Content
          extend Anthropic::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Anthropic::Beta::BetaMessageParam::Content::Variants]) }
            def variants; end
          end

          BetaContentBlockParamArray = T.let(
              Anthropic::Internal::Type::ArrayOf[
                union: Anthropic::Beta::BetaContentBlockParam
              ],
              Anthropic::Internal::Type::Converter
            )

          Variants = T.type_alias do
              T.any(
                String,
                T::Array[Anthropic::Beta::BetaContentBlockParam::Variants]
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaMessageParam,
              Anthropic::Internal::AnyHash
            )
          end

        module Role
          extend Anthropic::Internal::Type::Enum

          class << self
            sig { override.returns(T::Array[Anthropic::Beta::BetaMessageParam::Role::TaggedSymbol]) }
            def values; end
          end

          ASSISTANT = T.let(
              :assistant,
              Anthropic::Beta::BetaMessageParam::Role::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Anthropic::Beta::BetaMessageParam::Role)
            end

          USER = T.let(:user, Anthropic::Beta::BetaMessageParam::Role::TaggedSymbol)
        end
      end

      class BetaMessageTokensCount < Anthropic::Internal::Type::BaseModel
        # The total number of tokens across the provided list of messages, system prompt,
        # and tools.
        sig { returns(Integer) }
        attr_accessor :input_tokens

        sig { override.returns({ input_tokens: Integer }) }
        def to_hash; end

        class << self
          sig { params(input_tokens: Integer).returns(T.attached_class) }
          def new(
            input_tokens: # The total number of tokens across the provided list of messages, system prompt,
                          # and tools.
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaMessageTokensCount,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaMetadata < Anthropic::Internal::Type::BaseModel
        # An external identifier for the user who is associated with the request.
        #
        # This should be a uuid, hash value, or other opaque identifier. Anthropic may use
        # this id to help detect abuse. Do not include any identifying information such as
        # name, email address, or phone number.
        sig { returns(T.nilable(String)) }
        attr_accessor :user_id

        sig { override.returns({ user_id: T.nilable(String) }) }
        def to_hash; end

        class << self
          sig { params(user_id: T.nilable(String)).returns(T.attached_class) }
          def new(
            user_id: nil # An external identifier for the user who is associated with the request.
                         # This should be a uuid, hash value, or other opaque identifier. Anthropic may use
                         # this id to help detect abuse. Do not include any identifying information such as
                         # name, email address, or phone number.
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::BetaMetadata, Anthropic::Internal::AnyHash)
          end
      end

      class BetaModelInfo < Anthropic::Internal::Type::BaseModel
        # RFC 3339 datetime string representing the time at which the model was released.
        # May be set to an epoch value if the release date is unknown.
        sig { returns(Time) }
        attr_accessor :created_at

        # A human-readable name for the model.
        sig { returns(String) }
        attr_accessor :display_name

        # Unique model identifier.
        sig { returns(String) }
        attr_accessor :id

        # Object type.
        #
        # For Models, this is always `"model"`.
        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ id: String, created_at: Time, display_name: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(id: String, created_at: Time, display_name: String, type: Symbol).returns(T.attached_class) }
          def new(
            id:, # Unique model identifier.
            created_at:, # RFC 3339 datetime string representing the time at which the model was released.
                         # May be set to an epoch value if the release date is unknown.
            display_name:, # A human-readable name for the model.
            type: :model # Object type.
                         # For Models, this is always `"model"`.
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::BetaModelInfo, Anthropic::Internal::AnyHash)
          end
      end

      class BetaPlainTextSource < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :data

        sig { returns(Symbol) }
        attr_accessor :media_type

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ data: String, media_type: Symbol, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(data: String, media_type: Symbol, type: Symbol).returns(T.attached_class) }
          def new(data:, media_type: :"text/plain", type: :text); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaPlainTextSource,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaRawContentBlockDelta
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaRawContentBlockDelta::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaTextDelta,
              Anthropic::Beta::BetaInputJSONDelta,
              Anthropic::Beta::BetaCitationsDelta,
              Anthropic::Beta::BetaThinkingDelta,
              Anthropic::Beta::BetaSignatureDelta
            )
          end
      end

      class BetaRawContentBlockDeltaEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaRawContentBlockDelta::Variants) }
        attr_accessor :delta

        sig { returns(Integer) }
        attr_accessor :index

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              delta: Anthropic::Beta::BetaRawContentBlockDelta::Variants,
              index: Integer,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              delta: T.any(
                Anthropic::Beta::BetaTextDelta::OrHash,
                Anthropic::Beta::BetaInputJSONDelta::OrHash,
                Anthropic::Beta::BetaCitationsDelta::OrHash,
                Anthropic::Beta::BetaThinkingDelta::OrHash,
                Anthropic::Beta::BetaSignatureDelta::OrHash
              ),
              index: Integer,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(delta:, index:, type: :content_block_delta); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRawContentBlockDeltaEvent,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRawContentBlockStartEvent < Anthropic::Internal::Type::BaseModel
        # Response model for a file uploaded to the container.
        sig { returns(Anthropic::Beta::BetaRawContentBlockStartEvent::ContentBlock::Variants) }
        attr_accessor :content_block

        sig { returns(Integer) }
        attr_accessor :index

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content_block:
                Anthropic::Beta::BetaRawContentBlockStartEvent::ContentBlock::Variants,
              index: Integer,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content_block: T.any(
                Anthropic::Beta::BetaTextBlock::OrHash,
                Anthropic::Beta::BetaThinkingBlock::OrHash,
                Anthropic::Beta::BetaRedactedThinkingBlock::OrHash,
                Anthropic::Beta::BetaToolUseBlock::OrHash,
                Anthropic::Beta::BetaServerToolUseBlock::OrHash,
                Anthropic::Beta::BetaWebSearchToolResultBlock::OrHash,
                Anthropic::Beta::BetaCodeExecutionToolResultBlock::OrHash,
                Anthropic::Beta::BetaMCPToolUseBlock::OrHash,
                Anthropic::Beta::BetaMCPToolResultBlock::OrHash,
                Anthropic::Beta::BetaContainerUploadBlock::OrHash
              ),
              index: Integer,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            content_block:, # Response model for a file uploaded to the container.
            index:,
            type: :content_block_start
); end
        end

        # Response model for a file uploaded to the container.
        module ContentBlock
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaRawContentBlockStartEvent::ContentBlock::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias do
              T.any(
                Anthropic::Beta::BetaTextBlock,
                Anthropic::Beta::BetaThinkingBlock,
                Anthropic::Beta::BetaRedactedThinkingBlock,
                Anthropic::Beta::BetaToolUseBlock,
                Anthropic::Beta::BetaServerToolUseBlock,
                Anthropic::Beta::BetaWebSearchToolResultBlock,
                Anthropic::Beta::BetaCodeExecutionToolResultBlock,
                Anthropic::Beta::BetaMCPToolUseBlock,
                Anthropic::Beta::BetaMCPToolResultBlock,
                Anthropic::Beta::BetaContainerUploadBlock
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRawContentBlockStartEvent,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRawContentBlockStopEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(Integer) }
        attr_accessor :index

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ index: Integer, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(index: Integer, type: Symbol).returns(T.attached_class) }
          def new(index:, type: :content_block_stop); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRawContentBlockStopEvent,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRawMessageDeltaEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaRawMessageDeltaEvent::Delta) }
        attr_reader :delta

        sig { params(delta: Anthropic::Beta::BetaRawMessageDeltaEvent::Delta::OrHash).void }
        attr_writer :delta

        sig { returns(Symbol) }
        attr_accessor :type

        # Billing and rate-limit usage.
        #
        # Anthropic's API bills and rate-limits by token counts, as tokens represent the
        # underlying cost to our systems.
        #
        # Under the hood, the API transforms requests into a format suitable for the
        # model. The model's output then goes through a parsing stage before becoming an
        # API response. As a result, the token counts in `usage` will not match one-to-one
        # with the exact visible content of an API request or response.
        #
        # For example, `output_tokens` will be non-zero, even for an empty string response
        # from Claude.
        #
        # Total input tokens in a request is the summation of `input_tokens`,
        # `cache_creation_input_tokens`, and `cache_read_input_tokens`.
        sig { returns(Anthropic::Beta::BetaMessageDeltaUsage) }
        attr_reader :usage

        sig { params(usage: Anthropic::Beta::BetaMessageDeltaUsage::OrHash).void }
        attr_writer :usage

        sig do
          override
            .returns({
              delta: Anthropic::Beta::BetaRawMessageDeltaEvent::Delta,
              type: Symbol,
              usage: Anthropic::Beta::BetaMessageDeltaUsage
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              delta: Anthropic::Beta::BetaRawMessageDeltaEvent::Delta::OrHash,
              usage: Anthropic::Beta::BetaMessageDeltaUsage::OrHash,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            delta:,
            usage:, # Billing and rate-limit usage.
                    # Anthropic's API bills and rate-limits by token counts, as tokens represent the
                    # underlying cost to our systems.
                    # Under the hood, the API transforms requests into a format suitable for the
                    # model. The model's output then goes through a parsing stage before becoming an
                    # API response. As a result, the token counts in `usage` will not match one-to-one
                    # with the exact visible content of an API request or response.
                    # For example, `output_tokens` will be non-zero, even for an empty string response
                    # from Claude.
                    # Total input tokens in a request is the summation of `input_tokens`,
                    # `cache_creation_input_tokens`, and `cache_read_input_tokens`.
            type: :message_delta
); end
        end

        class Delta < Anthropic::Internal::Type::BaseModel
          # Information about the container used in the request (for the code execution
          # tool)
          sig { returns(T.nilable(Anthropic::Beta::BetaContainer)) }
          attr_reader :container

          sig { params(container: T.nilable(Anthropic::Beta::BetaContainer::OrHash)).void }
          attr_writer :container

          sig { returns(T.nilable(Anthropic::Beta::BetaStopReason::TaggedSymbol)) }
          attr_accessor :stop_reason

          sig { returns(T.nilable(String)) }
          attr_accessor :stop_sequence

          sig do
            override
              .returns({
                container: T.nilable(Anthropic::Beta::BetaContainer),
                stop_reason:
                  T.nilable(Anthropic::Beta::BetaStopReason::TaggedSymbol),
                stop_sequence: T.nilable(String)
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                container: T.nilable(Anthropic::Beta::BetaContainer::OrHash),
                stop_reason: T.nilable(Anthropic::Beta::BetaStopReason::OrSymbol),
                stop_sequence: T.nilable(String)
              ).returns(T.attached_class)
            end
            def new(
              container:, # Information about the container used in the request (for the code execution
                          # tool)
              stop_reason:,
              stop_sequence:
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::BetaRawMessageDeltaEvent::Delta,
                Anthropic::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRawMessageDeltaEvent,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRawMessageStartEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaMessage) }
        attr_reader :message

        sig { params(message: Anthropic::Beta::BetaMessage::OrHash).void }
        attr_writer :message

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ message: Anthropic::Beta::BetaMessage, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(message: Anthropic::Beta::BetaMessage::OrHash, type: Symbol).returns(T.attached_class) }
          def new(message:, type: :message_start); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRawMessageStartEvent,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRawMessageStopEvent < Anthropic::Internal::Type::BaseModel
        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(type: Symbol).returns(T.attached_class) }
          def new(type: :message_stop); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRawMessageStopEvent,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaRawMessageStreamEvent
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaRawMessageStreamEvent::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRawMessageStartEvent,
              Anthropic::Beta::BetaRawMessageDeltaEvent,
              Anthropic::Beta::BetaRawMessageStopEvent,
              Anthropic::Beta::BetaRawContentBlockStartEvent,
              Anthropic::Beta::BetaRawContentBlockDeltaEvent,
              Anthropic::Beta::BetaRawContentBlockStopEvent
            )
          end
      end

      class BetaRedactedThinkingBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :data

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ data: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(data: String, type: Symbol).returns(T.attached_class) }
          def new(data:, type: :redacted_thinking); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRedactedThinkingBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRedactedThinkingBlockParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :data

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ data: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(data: String, type: Symbol).returns(T.attached_class) }
          def new(data:, type: :redacted_thinking); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRedactedThinkingBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRequestDocumentBlock < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig { returns(T.nilable(Anthropic::Beta::BetaCitationsConfigParam)) }
        attr_reader :citations

        sig { params(citations: Anthropic::Beta::BetaCitationsConfigParam::OrHash).void }
        attr_writer :citations

        sig { returns(T.nilable(String)) }
        attr_accessor :context

        sig do
          returns(T.any(
              Anthropic::Beta::BetaBase64PDFSource,
              Anthropic::Beta::BetaPlainTextSource,
              Anthropic::Beta::BetaContentBlockSource,
              Anthropic::Beta::BetaURLPDFSource,
              Anthropic::Beta::BetaFileDocumentSource
            ))
        end
        attr_accessor :source

        sig { returns(T.nilable(String)) }
        attr_accessor :title

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              source:
                T.any(
                  Anthropic::Beta::BetaBase64PDFSource,
                  Anthropic::Beta::BetaPlainTextSource,
                  Anthropic::Beta::BetaContentBlockSource,
                  Anthropic::Beta::BetaURLPDFSource,
                  Anthropic::Beta::BetaFileDocumentSource
                ),
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              citations: Anthropic::Beta::BetaCitationsConfigParam,
              context: T.nilable(String),
              title: T.nilable(String)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              source: T.any(
                Anthropic::Beta::BetaBase64PDFSource::OrHash,
                Anthropic::Beta::BetaPlainTextSource::OrHash,
                Anthropic::Beta::BetaContentBlockSource::OrHash,
                Anthropic::Beta::BetaURLPDFSource::OrHash,
                Anthropic::Beta::BetaFileDocumentSource::OrHash
              ),
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              citations: Anthropic::Beta::BetaCitationsConfigParam::OrHash,
              context: T.nilable(String),
              title: T.nilable(String),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            source:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            citations: nil,
            context: nil,
            title: nil,
            type: :document
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRequestDocumentBlock,
              Anthropic::Internal::AnyHash
            )
          end

        module Source
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaRequestDocumentBlock::Source::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias do
              T.any(
                Anthropic::Beta::BetaBase64PDFSource,
                Anthropic::Beta::BetaPlainTextSource,
                Anthropic::Beta::BetaContentBlockSource,
                Anthropic::Beta::BetaURLPDFSource,
                Anthropic::Beta::BetaFileDocumentSource
              )
            end
        end
      end

      class BetaRequestMCPServerToolConfiguration < Anthropic::Internal::Type::BaseModel
        sig { returns(T.nilable(T::Array[String])) }
        attr_accessor :allowed_tools

        sig { returns(T.nilable(T::Boolean)) }
        attr_accessor :enabled

        sig do
          override
            .returns({
              allowed_tools: T.nilable(T::Array[String]),
              enabled: T.nilable(T::Boolean)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              allowed_tools: T.nilable(T::Array[String]),
              enabled: T.nilable(T::Boolean)
            ).returns(T.attached_class)
          end
          def new(allowed_tools: nil, enabled: nil); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRequestMCPServerToolConfiguration,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRequestMCPServerURLDefinition < Anthropic::Internal::Type::BaseModel
        sig { returns(T.nilable(String)) }
        attr_accessor :authorization_token

        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(Anthropic::Beta::BetaRequestMCPServerToolConfiguration)) }
        attr_reader :tool_configuration

        sig do
          params(
            tool_configuration: T.nilable(
                Anthropic::Beta::BetaRequestMCPServerToolConfiguration::OrHash
              )
          ).void
        end
        attr_writer :tool_configuration

        sig { returns(Symbol) }
        attr_accessor :type

        sig { returns(String) }
        attr_accessor :url

        sig do
          override
            .returns({
              name: String,
              type: Symbol,
              url: String,
              authorization_token: T.nilable(String),
              tool_configuration:
                T.nilable(
                  Anthropic::Beta::BetaRequestMCPServerToolConfiguration
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              name: String,
              url: String,
              authorization_token: T.nilable(String),
              tool_configuration: T.nilable(
                Anthropic::Beta::BetaRequestMCPServerToolConfiguration::OrHash
              ),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(name:, url:, authorization_token: nil, tool_configuration: nil, type: :url); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRequestMCPServerURLDefinition,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaRequestMCPToolResultBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig do
          returns(T.nilable(
              Anthropic::Beta::BetaRequestMCPToolResultBlockParam::Content::Variants
            ))
        end
        attr_reader :content

        sig { params(content: Anthropic::Beta::BetaRequestMCPToolResultBlockParam::Content::Variants).void }
        attr_writer :content

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_error

        sig { params(is_error: T::Boolean).void }
        attr_writer :is_error

        sig { returns(String) }
        attr_accessor :tool_use_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              tool_use_id: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              content:
                Anthropic::Beta::BetaRequestMCPToolResultBlockParam::Content::Variants,
              is_error: T::Boolean
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              tool_use_id: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              content: Anthropic::Beta::BetaRequestMCPToolResultBlockParam::Content::Variants,
              is_error: T::Boolean,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            tool_use_id:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            content: nil,
            is_error: nil,
            type: :mcp_tool_result
); end
        end

        module Content
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaRequestMCPToolResultBlockParam::Content::Variants
              ])
            end
            def variants; end
          end

          BetaTextBlockParamArray = T.let(
              Anthropic::Internal::Type::ArrayOf[
                Anthropic::Beta::BetaTextBlockParam
              ],
              Anthropic::Internal::Type::Converter
            )

          Variants = T.type_alias do
              T.any(String, T::Array[Anthropic::Beta::BetaTextBlockParam])
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaRequestMCPToolResultBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaSearchResultBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig { returns(T.nilable(Anthropic::Beta::BetaCitationsConfigParam)) }
        attr_reader :citations

        sig { params(citations: Anthropic::Beta::BetaCitationsConfigParam::OrHash).void }
        attr_writer :citations

        sig { returns(T::Array[Anthropic::Beta::BetaTextBlockParam]) }
        attr_accessor :content

        sig { returns(String) }
        attr_accessor :source

        sig { returns(String) }
        attr_accessor :title

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content: T::Array[Anthropic::Beta::BetaTextBlockParam],
              source: String,
              title: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              citations: Anthropic::Beta::BetaCitationsConfigParam
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: T::Array[Anthropic::Beta::BetaTextBlockParam::OrHash],
              source: String,
              title: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              citations: Anthropic::Beta::BetaCitationsConfigParam::OrHash,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            content:,
            source:,
            title:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            citations: nil,
            type: :search_result
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaSearchResultBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaServerToolUsage < Anthropic::Internal::Type::BaseModel
        # The number of web search tool requests.
        sig { returns(Integer) }
        attr_accessor :web_search_requests

        sig { override.returns({ web_search_requests: Integer }) }
        def to_hash; end

        class << self
          sig { params(web_search_requests: Integer).returns(T.attached_class) }
          def new(
            web_search_requests: # The number of web search tool requests.
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaServerToolUsage,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaServerToolUseBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :id

        sig { returns(T.anything) }
        attr_accessor :input

        sig { returns(Anthropic::Beta::BetaServerToolUseBlock::Name::TaggedSymbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              id: String,
              input: T.anything,
              name: Anthropic::Beta::BetaServerToolUseBlock::Name::TaggedSymbol,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: String,
              input: T.anything,
              name: Anthropic::Beta::BetaServerToolUseBlock::Name::OrSymbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(id:, input:, name:, type: :server_tool_use); end
        end

        module Name
          extend Anthropic::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaServerToolUseBlock::Name::TaggedSymbol
              ])
            end
            def values; end
          end

          CODE_EXECUTION = T.let(
              :code_execution,
              Anthropic::Beta::BetaServerToolUseBlock::Name::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Anthropic::Beta::BetaServerToolUseBlock::Name)
            end

          WEB_SEARCH = T.let(
              :web_search,
              Anthropic::Beta::BetaServerToolUseBlock::Name::TaggedSymbol
            )
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaServerToolUseBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaServerToolUseBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig { returns(String) }
        attr_accessor :id

        sig { returns(T.anything) }
        attr_accessor :input

        sig { returns(Anthropic::Beta::BetaServerToolUseBlockParam::Name::OrSymbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              id: String,
              input: T.anything,
              name:
                Anthropic::Beta::BetaServerToolUseBlockParam::Name::OrSymbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: String,
              input: T.anything,
              name: Anthropic::Beta::BetaServerToolUseBlockParam::Name::OrSymbol,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            id:,
            input:,
            name:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            type: :server_tool_use
); end
        end

        module Name
          extend Anthropic::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaServerToolUseBlockParam::Name::TaggedSymbol
              ])
            end
            def values; end
          end

          CODE_EXECUTION = T.let(
              :code_execution,
              Anthropic::Beta::BetaServerToolUseBlockParam::Name::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Anthropic::Beta::BetaServerToolUseBlockParam::Name)
            end

          WEB_SEARCH = T.let(
              :web_search,
              Anthropic::Beta::BetaServerToolUseBlockParam::Name::TaggedSymbol
            )
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaServerToolUseBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaSignatureDelta < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :signature

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ signature: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(signature: String, type: Symbol).returns(T.attached_class) }
          def new(signature:, type: :signature_delta); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaSignatureDelta,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaStopReason
        extend Anthropic::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaStopReason::TaggedSymbol]) }
          def values; end
        end

        END_TURN = T.let(:end_turn, Anthropic::Beta::BetaStopReason::TaggedSymbol)

        MAX_TOKENS = T.let(:max_tokens, Anthropic::Beta::BetaStopReason::TaggedSymbol)

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        PAUSE_TURN = T.let(:pause_turn, Anthropic::Beta::BetaStopReason::TaggedSymbol)

        REFUSAL = T.let(:refusal, Anthropic::Beta::BetaStopReason::TaggedSymbol)

        STOP_SEQUENCE = T.let(:stop_sequence, Anthropic::Beta::BetaStopReason::TaggedSymbol)

        TOOL_USE = T.let(:tool_use, Anthropic::Beta::BetaStopReason::TaggedSymbol)

        TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::Beta::BetaStopReason) }
      end

      class BetaTextBlock < Anthropic::Internal::Type::BaseModel
        # Citations supporting the text block.
        #
        # The type of citation returned will depend on the type of document being cited.
        # Citing a PDF results in `page_location`, plain text results in `char_location`,
        # and content document results in `content_block_location`.
        sig { returns(T.nilable(T::Array[Anthropic::Beta::BetaTextCitation::Variants])) }
        attr_accessor :citations

        sig { returns(String) }
        attr_accessor :text

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              citations:
                T.nilable(
                  T::Array[Anthropic::Beta::BetaTextCitation::Variants]
                ),
              text: String,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              citations: T.nilable(
                T::Array[
                  T.any(
                    Anthropic::Beta::BetaCitationCharLocation::OrHash,
                    Anthropic::Beta::BetaCitationPageLocation::OrHash,
                    Anthropic::Beta::BetaCitationContentBlockLocation::OrHash,
                    Anthropic::Beta::BetaCitationsWebSearchResultLocation::OrHash,
                    Anthropic::Beta::BetaCitationSearchResultLocation::OrHash
                  )
                ]
              ),
              text: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            citations:, # Citations supporting the text block.
                        # The type of citation returned will depend on the type of document being cited.
                        # Citing a PDF results in `page_location`, plain text results in `char_location`,
                        # and content document results in `content_block_location`.
            text:,
            type: :text
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::BetaTextBlock, Anthropic::Internal::AnyHash)
          end
      end

      class BetaTextBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig do
          returns(T.nilable(
              T::Array[
                T.any(
                  Anthropic::Beta::BetaCitationCharLocationParam,
                  Anthropic::Beta::BetaCitationPageLocationParam,
                  Anthropic::Beta::BetaCitationContentBlockLocationParam,
                  Anthropic::Beta::BetaCitationWebSearchResultLocationParam,
                  Anthropic::Beta::BetaCitationSearchResultLocationParam
                )
              ]
            ))
        end
        attr_accessor :citations

        sig { returns(String) }
        attr_accessor :text

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              text: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              citations:
                T.nilable(
                  T::Array[
                    T.any(
                      Anthropic::Beta::BetaCitationCharLocationParam,
                      Anthropic::Beta::BetaCitationPageLocationParam,
                      Anthropic::Beta::BetaCitationContentBlockLocationParam,
                      Anthropic::Beta::BetaCitationWebSearchResultLocationParam,
                      Anthropic::Beta::BetaCitationSearchResultLocationParam
                    )
                  ]
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              text: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              citations: T.nilable(
                T::Array[
                  T.any(
                    Anthropic::Beta::BetaCitationCharLocationParam::OrHash,
                    Anthropic::Beta::BetaCitationPageLocationParam::OrHash,
                    Anthropic::Beta::BetaCitationContentBlockLocationParam::OrHash,
                    Anthropic::Beta::BetaCitationWebSearchResultLocationParam::OrHash,
                    Anthropic::Beta::BetaCitationSearchResultLocationParam::OrHash
                  )
                ]
              ),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            text:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            citations: nil,
            type: :text
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaTextBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaTextCitation
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaTextCitation::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationCharLocation,
              Anthropic::Beta::BetaCitationPageLocation,
              Anthropic::Beta::BetaCitationContentBlockLocation,
              Anthropic::Beta::BetaCitationsWebSearchResultLocation,
              Anthropic::Beta::BetaCitationSearchResultLocation
            )
          end
      end

      module BetaTextCitationParam
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaTextCitationParam::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaCitationCharLocationParam,
              Anthropic::Beta::BetaCitationPageLocationParam,
              Anthropic::Beta::BetaCitationContentBlockLocationParam,
              Anthropic::Beta::BetaCitationWebSearchResultLocationParam,
              Anthropic::Beta::BetaCitationSearchResultLocationParam
            )
          end
      end

      class BetaTextDelta < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :text

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ text: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(text: String, type: Symbol).returns(T.attached_class) }
          def new(text:, type: :text_delta); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::BetaTextDelta, Anthropic::Internal::AnyHash)
          end
      end

      class BetaThinkingBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :signature

        sig { returns(String) }
        attr_accessor :thinking

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ signature: String, thinking: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(signature: String, thinking: String, type: Symbol).returns(T.attached_class) }
          def new(signature:, thinking:, type: :thinking); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaThinkingBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaThinkingBlockParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :signature

        sig { returns(String) }
        attr_accessor :thinking

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ signature: String, thinking: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(signature: String, thinking: String, type: Symbol).returns(T.attached_class) }
          def new(signature:, thinking:, type: :thinking); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaThinkingBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaThinkingConfigDisabled < Anthropic::Internal::Type::BaseModel
        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(type: Symbol).returns(T.attached_class) }
          def new(type: :disabled); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaThinkingConfigDisabled,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaThinkingConfigEnabled < Anthropic::Internal::Type::BaseModel
        # Determines how many tokens Claude can use for its internal reasoning process.
        # Larger budgets can enable more thorough analysis for complex problems, improving
        # response quality.
        #
        # Must be 1024 and less than `max_tokens`.
        #
        # See
        # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
        # for details.
        sig { returns(Integer) }
        attr_accessor :budget_tokens

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ budget_tokens: Integer, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(budget_tokens: Integer, type: Symbol).returns(T.attached_class) }
          def new(
            budget_tokens:, # Determines how many tokens Claude can use for its internal reasoning process.
                            # Larger budgets can enable more thorough analysis for complex problems, improving
                            # response quality.
                            # Must be 1024 and less than `max_tokens`.
                            # See
                            # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                            # for details.
            type: :enabled
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaThinkingConfigEnabled,
              Anthropic::Internal::AnyHash
            )
          end
      end

      # Configuration for enabling Claude's extended thinking.
      #
      # When enabled, responses include `thinking` content blocks showing Claude's
      # thinking process before the final answer. Requires a minimum budget of 1,024
      # tokens and counts towards your `max_tokens` limit.
      #
      # See
      # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
      # for details.
      module BetaThinkingConfigParam
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaThinkingConfigParam::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaThinkingConfigEnabled,
              Anthropic::Beta::BetaThinkingConfigDisabled
            )
          end
      end

      class BetaThinkingDelta < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :thinking

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ thinking: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(thinking: String, type: Symbol).returns(T.attached_class) }
          def new(thinking:, type: :thinking_delta); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaThinkingDelta,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaTool < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Description of what this tool does.
        #
        # Tool descriptions should be as detailed as possible. The more information that
        # the model has about what the tool is and how to use it, the better it will
        # perform. You can use natural language descriptions to reinforce important
        # aspects of the tool input JSON schema.
        sig { returns(T.nilable(String)) }
        attr_reader :description

        sig { params(description: String).void }
        attr_writer :description

        # [JSON schema](https://json-schema.org/draft/2020-12) for this tool's input.
        #
        # This defines the shape of the `input` that your tool accepts and that the model
        # will produce.
        sig { returns(Anthropic::Beta::BetaTool::InputSchema) }
        attr_reader :input_schema

        sig { params(input_schema: Anthropic::Beta::BetaTool::InputSchema::OrHash).void }
        attr_writer :input_schema

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(String) }
        attr_accessor :name

        sig { returns(T.nilable(Anthropic::Beta::BetaTool::Type::OrSymbol)) }
        attr_accessor :type

        sig do
          override
            .returns({
              input_schema: Anthropic::Beta::BetaTool::InputSchema,
              name: String,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              description: String,
              type: T.nilable(Anthropic::Beta::BetaTool::Type::OrSymbol)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              input_schema: Anthropic::Beta::BetaTool::InputSchema::OrHash,
              name: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              description: String,
              type: T.nilable(Anthropic::Beta::BetaTool::Type::OrSymbol)
            ).returns(T.attached_class)
          end
          def new(
            input_schema:, # [JSON schema](https://json-schema.org/draft/2020-12) for this tool's input.
                           # This defines the shape of the `input` that your tool accepts and that the model
                           # will produce.
            name:, # Name of the tool.
                   # This is how the tool will be called by the model and in `tool_use` blocks.
            cache_control: nil, # Create a cache control breakpoint at this content block.
            description: nil, # Description of what this tool does.
                              # Tool descriptions should be as detailed as possible. The more information that
                              # the model has about what the tool is and how to use it, the better it will
                              # perform. You can use natural language descriptions to reinforce important
                              # aspects of the tool input JSON schema.
            type: nil
); end
        end

        class InputSchema < Anthropic::Internal::Type::BaseModel
          sig { returns(T.nilable(T.anything)) }
          attr_accessor :properties

          sig { returns(T.nilable(T::Array[String])) }
          attr_accessor :required

          sig { returns(Symbol) }
          attr_accessor :type

          sig do
            override
              .returns({
                type: Symbol,
                properties: T.nilable(T.anything),
                required: T.nilable(T::Array[String])
              })
          end
          def to_hash; end

          class << self
            # [JSON schema](https://json-schema.org/draft/2020-12) for this tool's input.
            #
            # This defines the shape of the `input` that your tool accepts and that the model
            # will produce.
            sig do
              params(
                properties: T.nilable(T.anything),
                required: T.nilable(T::Array[String]),
                type: Symbol
              ).returns(T.attached_class)
            end
            def new(properties: nil, required: nil, type: :object); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::BetaTool::InputSchema,
                Anthropic::Internal::AnyHash
              )
            end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::BetaTool, Anthropic::Internal::AnyHash)
          end

        module Type
          extend Anthropic::Internal::Type::Enum

          class << self
            sig { override.returns(T::Array[Anthropic::Beta::BetaTool::Type::TaggedSymbol]) }
            def values; end
          end

          CUSTOM = T.let(:custom, Anthropic::Beta::BetaTool::Type::TaggedSymbol)
          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::Beta::BetaTool::Type) }
        end
      end

      class BetaToolBash20241022 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            cache_control: nil, # Create a cache control breakpoint at this content block.
            name: :bash, # Name of the tool.
                         # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :bash_20241022
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolBash20241022,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolBash20250124 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            cache_control: nil, # Create a cache control breakpoint at this content block.
            name: :bash, # Name of the tool.
                         # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :bash_20250124
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolBash20250124,
              Anthropic::Internal::AnyHash
            )
          end
      end

      # How the model should use the provided tools. The model can use a specific tool,
      # any available tool, decide by itself, or not use tools at all.
      module BetaToolChoice
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaToolChoice::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolChoiceAuto,
              Anthropic::Beta::BetaToolChoiceAny,
              Anthropic::Beta::BetaToolChoiceTool,
              Anthropic::Beta::BetaToolChoiceNone
            )
          end
      end

      class BetaToolChoiceAny < Anthropic::Internal::Type::BaseModel
        # Whether to disable parallel tool use.
        #
        # Defaults to `false`. If set to `true`, the model will output exactly one tool
        # use.
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :disable_parallel_tool_use

        sig { params(disable_parallel_tool_use: T::Boolean).void }
        attr_writer :disable_parallel_tool_use

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ type: Symbol, disable_parallel_tool_use: T::Boolean }) }
        def to_hash; end

        class << self
          # The model will use any available tools.
          sig { params(disable_parallel_tool_use: T::Boolean, type: Symbol).returns(T.attached_class) }
          def new(
            disable_parallel_tool_use: nil, # Whether to disable parallel tool use.
                                            # Defaults to `false`. If set to `true`, the model will output exactly one tool
                                            # use.
            type: :any
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolChoiceAny,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolChoiceAuto < Anthropic::Internal::Type::BaseModel
        # Whether to disable parallel tool use.
        #
        # Defaults to `false`. If set to `true`, the model will output at most one tool
        # use.
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :disable_parallel_tool_use

        sig { params(disable_parallel_tool_use: T::Boolean).void }
        attr_writer :disable_parallel_tool_use

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ type: Symbol, disable_parallel_tool_use: T::Boolean }) }
        def to_hash; end

        class << self
          # The model will automatically decide whether to use tools.
          sig { params(disable_parallel_tool_use: T::Boolean, type: Symbol).returns(T.attached_class) }
          def new(
            disable_parallel_tool_use: nil, # Whether to disable parallel tool use.
                                            # Defaults to `false`. If set to `true`, the model will output at most one tool
                                            # use.
            type: :auto
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolChoiceAuto,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolChoiceNone < Anthropic::Internal::Type::BaseModel
        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ type: Symbol }) }
        def to_hash; end

        class << self
          # The model will not be allowed to use tools.
          sig { params(type: Symbol).returns(T.attached_class) }
          def new(type: :none); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolChoiceNone,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolChoiceTool < Anthropic::Internal::Type::BaseModel
        # Whether to disable parallel tool use.
        #
        # Defaults to `false`. If set to `true`, the model will output exactly one tool
        # use.
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :disable_parallel_tool_use

        sig { params(disable_parallel_tool_use: T::Boolean).void }
        attr_writer :disable_parallel_tool_use

        # The name of the tool to use.
        sig { returns(String) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: String,
              type: Symbol,
              disable_parallel_tool_use: T::Boolean
            })
        end
        def to_hash; end

        class << self
          # The model will use the specified tool with `tool_choice.name`.
          sig { params(name: String, disable_parallel_tool_use: T::Boolean, type: Symbol).returns(T.attached_class) }
          def new(
            name:, # The name of the tool to use.
            disable_parallel_tool_use: nil, # Whether to disable parallel tool use.
                                            # Defaults to `false`. If set to `true`, the model will output exactly one tool
                                            # use.
            type: :tool
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolChoiceTool,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolComputerUse20241022 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # The height of the display in pixels.
        sig { returns(Integer) }
        attr_accessor :display_height_px

        # The X11 display number (e.g. 0, 1) for the display.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :display_number

        # The width of the display in pixels.
        sig { returns(Integer) }
        attr_accessor :display_width_px

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              display_height_px: Integer,
              display_width_px: Integer,
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              display_number: T.nilable(Integer)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              display_height_px: Integer,
              display_width_px: Integer,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              display_number: T.nilable(Integer),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            display_height_px:, # The height of the display in pixels.
            display_width_px:, # The width of the display in pixels.
            cache_control: nil, # Create a cache control breakpoint at this content block.
            display_number: nil, # The X11 display number (e.g. 0, 1) for the display.
            name: :computer, # Name of the tool.
                             # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :computer_20241022
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolComputerUse20241022,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolComputerUse20250124 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # The height of the display in pixels.
        sig { returns(Integer) }
        attr_accessor :display_height_px

        # The X11 display number (e.g. 0, 1) for the display.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :display_number

        # The width of the display in pixels.
        sig { returns(Integer) }
        attr_accessor :display_width_px

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              display_height_px: Integer,
              display_width_px: Integer,
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              display_number: T.nilable(Integer)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              display_height_px: Integer,
              display_width_px: Integer,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              display_number: T.nilable(Integer),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            display_height_px:, # The height of the display in pixels.
            display_width_px:, # The width of the display in pixels.
            cache_control: nil, # Create a cache control breakpoint at this content block.
            display_number: nil, # The X11 display number (e.g. 0, 1) for the display.
            name: :computer, # Name of the tool.
                             # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :computer_20250124
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolComputerUse20250124,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolResultBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig do
          returns(T.nilable(
              Anthropic::Beta::BetaToolResultBlockParam::Content::Variants
            ))
        end
        attr_reader :content

        sig { params(content: Anthropic::Beta::BetaToolResultBlockParam::Content::Variants).void }
        attr_writer :content

        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :is_error

        sig { params(is_error: T::Boolean).void }
        attr_writer :is_error

        sig { returns(String) }
        attr_accessor :tool_use_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              tool_use_id: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              content:
                Anthropic::Beta::BetaToolResultBlockParam::Content::Variants,
              is_error: T::Boolean
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              tool_use_id: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              content: Anthropic::Beta::BetaToolResultBlockParam::Content::Variants,
              is_error: T::Boolean,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            tool_use_id:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            content: nil,
            is_error: nil,
            type: :tool_result
); end
        end

        module Content
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::BetaToolResultBlockParam::Content::Variants
              ])
            end
            def variants; end
          end

          module Content
            extend Anthropic::Internal::Type::Union

            class << self
              sig do
                override
                  .returns(T::Array[
                  Anthropic::Beta::BetaToolResultBlockParam::Content::Content::Variants
                ])
              end
              def variants; end
            end

            Variants = T.type_alias do
                T.any(
                  Anthropic::Beta::BetaTextBlockParam,
                  Anthropic::Beta::BetaImageBlockParam,
                  Anthropic::Beta::BetaSearchResultBlockParam
                )
              end
          end

          ContentArray = T.let(
              Anthropic::Internal::Type::ArrayOf[
                union:
                  Anthropic::Beta::BetaToolResultBlockParam::Content::Content
              ],
              Anthropic::Internal::Type::Converter
            )

          Variants = T.type_alias do
              T.any(
                String,
                T::Array[
                  Anthropic::Beta::BetaToolResultBlockParam::Content::Content::Variants
                ]
              )
            end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolResultBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolTextEditor20241022 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            cache_control: nil, # Create a cache control breakpoint at this content block.
            name: :str_replace_editor, # Name of the tool.
                                       # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :text_editor_20241022
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolTextEditor20241022,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolTextEditor20250124 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            cache_control: nil, # Create a cache control breakpoint at this content block.
            name: :str_replace_editor, # Name of the tool.
                                       # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :text_editor_20250124
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolTextEditor20250124,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolTextEditor20250429 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            cache_control: nil, # Create a cache control breakpoint at this content block.
            name: :str_replace_based_edit_tool, # Name of the tool.
                                                # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :text_editor_20250429
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolTextEditor20250429,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolTextEditor20250728 < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Maximum number of characters to display when viewing a file. If not specified,
        # defaults to displaying the full file.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :max_characters

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              name: Symbol,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              max_characters: T.nilable(Integer)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              max_characters: T.nilable(Integer),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            cache_control: nil, # Create a cache control breakpoint at this content block.
            max_characters: nil, # Maximum number of characters to display when viewing a file. If not specified,
                                 # defaults to displaying the full file.
            name: :str_replace_based_edit_tool, # Name of the tool.
                                                # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :text_editor_20250728
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolTextEditor20250728,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaToolUnion
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Beta::BetaToolUnion::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaTool,
              Anthropic::Beta::BetaToolBash20241022,
              Anthropic::Beta::BetaToolBash20250124,
              Anthropic::Beta::BetaCodeExecutionTool20250522,
              Anthropic::Beta::BetaToolComputerUse20241022,
              Anthropic::Beta::BetaToolComputerUse20250124,
              Anthropic::Beta::BetaToolTextEditor20241022,
              Anthropic::Beta::BetaToolTextEditor20250124,
              Anthropic::Beta::BetaToolTextEditor20250429,
              Anthropic::Beta::BetaToolTextEditor20250728,
              Anthropic::Beta::BetaWebSearchTool20250305
            )
          end
      end

      class BetaToolUseBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :id

        sig { returns(T.anything) }
        attr_accessor :input

        sig { returns(String) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ id: String, input: T.anything, name: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(id: String, input: T.anything, name: String, type: Symbol).returns(T.attached_class) }
          def new(id:, input:, name:, type: :tool_use); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolUseBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaToolUseBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig { returns(String) }
        attr_accessor :id

        sig { returns(T.anything) }
        attr_accessor :input

        sig { returns(String) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              id: String,
              input: T.anything,
              name: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: String,
              input: T.anything,
              name: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            id:,
            input:,
            name:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            type: :tool_use
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaToolUseBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaURLImageSource < Anthropic::Internal::Type::BaseModel
        sig { returns(Symbol) }
        attr_accessor :type

        sig { returns(String) }
        attr_accessor :url

        sig { override.returns({ type: Symbol, url: String }) }
        def to_hash; end

        class << self
          sig { params(url: String, type: Symbol).returns(T.attached_class) }
          def new(url:, type: :url); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaURLImageSource,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaURLPDFSource < Anthropic::Internal::Type::BaseModel
        sig { returns(Symbol) }
        attr_accessor :type

        sig { returns(String) }
        attr_accessor :url

        sig { override.returns({ type: Symbol, url: String }) }
        def to_hash; end

        class << self
          sig { params(url: String, type: Symbol).returns(T.attached_class) }
          def new(url:, type: :url); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaURLPDFSource,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaUsage < Anthropic::Internal::Type::BaseModel
        # Breakdown of cached tokens by TTL
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheCreation)) }
        attr_reader :cache_creation

        sig { params(cache_creation: T.nilable(Anthropic::Beta::BetaCacheCreation::OrHash)).void }
        attr_writer :cache_creation

        # The number of input tokens used to create the cache entry.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :cache_creation_input_tokens

        # The number of input tokens read from the cache.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :cache_read_input_tokens

        # The number of input tokens which were used.
        sig { returns(Integer) }
        attr_accessor :input_tokens

        # The number of output tokens which were used.
        sig { returns(Integer) }
        attr_accessor :output_tokens

        # The number of server tool requests.
        sig { returns(T.nilable(Anthropic::Beta::BetaServerToolUsage)) }
        attr_reader :server_tool_use

        sig { params(server_tool_use: T.nilable(Anthropic::Beta::BetaServerToolUsage::OrHash)).void }
        attr_writer :server_tool_use

        # If the request used the priority, standard, or batch tier.
        sig { returns(T.nilable(Anthropic::Beta::BetaUsage::ServiceTier::TaggedSymbol)) }
        attr_accessor :service_tier

        sig do
          override
            .returns({
              cache_creation: T.nilable(Anthropic::Beta::BetaCacheCreation),
              cache_creation_input_tokens: T.nilable(Integer),
              cache_read_input_tokens: T.nilable(Integer),
              input_tokens: Integer,
              output_tokens: Integer,
              server_tool_use: T.nilable(Anthropic::Beta::BetaServerToolUsage),
              service_tier:
                T.nilable(Anthropic::Beta::BetaUsage::ServiceTier::TaggedSymbol)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              cache_creation: T.nilable(Anthropic::Beta::BetaCacheCreation::OrHash),
              cache_creation_input_tokens: T.nilable(Integer),
              cache_read_input_tokens: T.nilable(Integer),
              input_tokens: Integer,
              output_tokens: Integer,
              server_tool_use: T.nilable(Anthropic::Beta::BetaServerToolUsage::OrHash),
              service_tier: T.nilable(Anthropic::Beta::BetaUsage::ServiceTier::OrSymbol)
            ).returns(T.attached_class)
          end
          def new(
            cache_creation:, # Breakdown of cached tokens by TTL
            cache_creation_input_tokens:, # The number of input tokens used to create the cache entry.
            cache_read_input_tokens:, # The number of input tokens read from the cache.
            input_tokens:, # The number of input tokens which were used.
            output_tokens:, # The number of output tokens which were used.
            server_tool_use:, # The number of server tool requests.
            service_tier: # If the request used the priority, standard, or batch tier.
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::BetaUsage, Anthropic::Internal::AnyHash)
          end

        # If the request used the priority, standard, or batch tier.
        module ServiceTier
          extend Anthropic::Internal::Type::Enum

          class << self
            sig { override.returns(T::Array[Anthropic::Beta::BetaUsage::ServiceTier::TaggedSymbol]) }
            def values; end
          end

          BATCH = T.let(:batch, Anthropic::Beta::BetaUsage::ServiceTier::TaggedSymbol)

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          PRIORITY = T.let(
              :priority,
              Anthropic::Beta::BetaUsage::ServiceTier::TaggedSymbol
            )

          STANDARD = T.let(
              :standard,
              Anthropic::Beta::BetaUsage::ServiceTier::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Anthropic::Beta::BetaUsage::ServiceTier)
            end
        end
      end

      class BetaWebSearchResultBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :encrypted_content

        sig { returns(T.nilable(String)) }
        attr_accessor :page_age

        sig { returns(String) }
        attr_accessor :title

        sig { returns(Symbol) }
        attr_accessor :type

        sig { returns(String) }
        attr_accessor :url

        sig do
          override
            .returns({
              encrypted_content: String,
              page_age: T.nilable(String),
              title: String,
              type: Symbol,
              url: String
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              encrypted_content: String,
              page_age: T.nilable(String),
              title: String,
              url: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(encrypted_content:, page_age:, title:, url:, type: :web_search_result); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaWebSearchResultBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaWebSearchResultBlockParam < Anthropic::Internal::Type::BaseModel
        sig { returns(String) }
        attr_accessor :encrypted_content

        sig { returns(T.nilable(String)) }
        attr_accessor :page_age

        sig { returns(String) }
        attr_accessor :title

        sig { returns(Symbol) }
        attr_accessor :type

        sig { returns(String) }
        attr_accessor :url

        sig do
          override
            .returns({
              encrypted_content: String,
              title: String,
              type: Symbol,
              url: String,
              page_age: T.nilable(String)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              encrypted_content: String,
              title: String,
              url: String,
              page_age: T.nilable(String),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(encrypted_content:, title:, url:, page_age: nil, type: :web_search_result); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaWebSearchResultBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaWebSearchTool20250305 < Anthropic::Internal::Type::BaseModel
        # If provided, only these domains will be included in results. Cannot be used
        # alongside `blocked_domains`.
        sig { returns(T.nilable(T::Array[String])) }
        attr_accessor :allowed_domains

        # If provided, these domains will never appear in results. Cannot be used
        # alongside `allowed_domains`.
        sig { returns(T.nilable(T::Array[String])) }
        attr_accessor :blocked_domains

        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        # Maximum number of times the tool can be used in the API request.
        sig { returns(T.nilable(Integer)) }
        attr_accessor :max_uses

        # Name of the tool.
        #
        # This is how the tool will be called by the model and in `tool_use` blocks.
        sig { returns(Symbol) }
        attr_accessor :name

        sig { returns(Symbol) }
        attr_accessor :type

        # Parameters for the user's location. Used to provide more relevant search
        # results.
        sig { returns(T.nilable(Anthropic::Beta::BetaWebSearchTool20250305::UserLocation)) }
        attr_reader :user_location

        sig do
          params(
            user_location: T.nilable(
                Anthropic::Beta::BetaWebSearchTool20250305::UserLocation::OrHash
              )
          ).void
        end
        attr_writer :user_location

        sig do
          override
            .returns({
              name: Symbol,
              type: Symbol,
              allowed_domains: T.nilable(T::Array[String]),
              blocked_domains: T.nilable(T::Array[String]),
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral),
              max_uses: T.nilable(Integer),
              user_location:
                T.nilable(
                  Anthropic::Beta::BetaWebSearchTool20250305::UserLocation
                )
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              allowed_domains: T.nilable(T::Array[String]),
              blocked_domains: T.nilable(T::Array[String]),
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              max_uses: T.nilable(Integer),
              user_location: T.nilable(
                Anthropic::Beta::BetaWebSearchTool20250305::UserLocation::OrHash
              ),
              name: Symbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            allowed_domains: nil, # If provided, only these domains will be included in results. Cannot be used
                                  # alongside `blocked_domains`.
            blocked_domains: nil, # If provided, these domains will never appear in results. Cannot be used
                                  # alongside `allowed_domains`.
            cache_control: nil, # Create a cache control breakpoint at this content block.
            max_uses: nil, # Maximum number of times the tool can be used in the API request.
            user_location: nil, # Parameters for the user's location. Used to provide more relevant search
                                # results.
            name: :web_search, # Name of the tool.
                               # This is how the tool will be called by the model and in `tool_use` blocks.
            type: :web_search_20250305
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaWebSearchTool20250305,
              Anthropic::Internal::AnyHash
            )
          end

        class UserLocation < Anthropic::Internal::Type::BaseModel
          # The city of the user.
          sig { returns(T.nilable(String)) }
          attr_accessor :city

          # The two letter
          # [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
          # user.
          sig { returns(T.nilable(String)) }
          attr_accessor :country

          # The region of the user.
          sig { returns(T.nilable(String)) }
          attr_accessor :region

          # The [IANA timezone](https://nodatime.org/TimeZones) of the user.
          sig { returns(T.nilable(String)) }
          attr_accessor :timezone

          sig { returns(Symbol) }
          attr_accessor :type

          sig do
            override
              .returns({
                type: Symbol,
                city: T.nilable(String),
                country: T.nilable(String),
                region: T.nilable(String),
                timezone: T.nilable(String)
              })
          end
          def to_hash; end

          class << self
            # Parameters for the user's location. Used to provide more relevant search
            # results.
            sig do
              params(
                city: T.nilable(String),
                country: T.nilable(String),
                region: T.nilable(String),
                timezone: T.nilable(String),
                type: Symbol
              ).returns(T.attached_class)
            end
            def new(
              city: nil, # The city of the user.
              country: nil, # The two letter
                            # [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
                            # user.
              region: nil, # The region of the user.
              timezone: nil, # The [IANA timezone](https://nodatime.org/TimeZones) of the user.
              type: :approximate
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::BetaWebSearchTool20250305::UserLocation,
                Anthropic::Internal::AnyHash
              )
            end
        end
      end

      class BetaWebSearchToolRequestError < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaWebSearchToolResultErrorCode::OrSymbol) }
        attr_accessor :error_code

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              error_code:
                Anthropic::Beta::BetaWebSearchToolResultErrorCode::OrSymbol,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              error_code: Anthropic::Beta::BetaWebSearchToolResultErrorCode::OrSymbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(error_code:, type: :web_search_tool_result_error); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaWebSearchToolRequestError,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BetaWebSearchToolResultBlock < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaWebSearchToolResultBlockContent::Variants) }
        attr_accessor :content

        sig { returns(String) }
        attr_accessor :tool_use_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content:
                Anthropic::Beta::BetaWebSearchToolResultBlockContent::Variants,
              tool_use_id: String,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: T.any(
                Anthropic::Beta::BetaWebSearchToolResultError::OrHash,
                T::Array[Anthropic::Beta::BetaWebSearchResultBlock::OrHash]
              ),
              tool_use_id: String,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(content:, tool_use_id:, type: :web_search_tool_result); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaWebSearchToolResultBlock,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaWebSearchToolResultBlockContent
        extend Anthropic::Internal::Type::Union

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::Beta::BetaWebSearchToolResultBlockContent::Variants
            ])
          end
          def variants; end
        end

        BetaWebSearchResultBlockArray = T.let(
            Anthropic::Internal::Type::ArrayOf[
              Anthropic::Beta::BetaWebSearchResultBlock
            ],
            Anthropic::Internal::Type::Converter
          )

        Variants = T.type_alias do
            T.any(
              Anthropic::Beta::BetaWebSearchToolResultError,
              T::Array[Anthropic::Beta::BetaWebSearchResultBlock]
            )
          end
      end

      class BetaWebSearchToolResultBlockParam < Anthropic::Internal::Type::BaseModel
        # Create a cache control breakpoint at this content block.
        sig { returns(T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)) }
        attr_reader :cache_control

        sig { params(cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash)).void }
        attr_writer :cache_control

        sig do
          returns(T.any(
              T::Array[Anthropic::Beta::BetaWebSearchResultBlockParam],
              Anthropic::Beta::BetaWebSearchToolRequestError
            ))
        end
        attr_accessor :content

        sig { returns(String) }
        attr_accessor :tool_use_id

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              content:
                T.any(
                  T::Array[Anthropic::Beta::BetaWebSearchResultBlockParam],
                  Anthropic::Beta::BetaWebSearchToolRequestError
                ),
              tool_use_id: String,
              type: Symbol,
              cache_control:
                T.nilable(Anthropic::Beta::BetaCacheControlEphemeral)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              content: T.any(
                T::Array[
                  Anthropic::Beta::BetaWebSearchResultBlockParam::OrHash
                ],
                Anthropic::Beta::BetaWebSearchToolRequestError::OrHash
              ),
              tool_use_id: String,
              cache_control: T.nilable(Anthropic::Beta::BetaCacheControlEphemeral::OrHash),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            content:,
            tool_use_id:,
            cache_control: nil, # Create a cache control breakpoint at this content block.
            type: :web_search_tool_result
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaWebSearchToolResultBlockParam,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaWebSearchToolResultBlockParamContent
        extend Anthropic::Internal::Type::Union

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::Beta::BetaWebSearchToolResultBlockParamContent::Variants
            ])
          end
          def variants; end
        end

        BetaWebSearchResultBlockParamArray = T.let(
            Anthropic::Internal::Type::ArrayOf[
              Anthropic::Beta::BetaWebSearchResultBlockParam
            ],
            Anthropic::Internal::Type::Converter
          )

        Variants = T.type_alias do
            T.any(
              T::Array[Anthropic::Beta::BetaWebSearchResultBlockParam],
              Anthropic::Beta::BetaWebSearchToolRequestError
            )
          end
      end

      class BetaWebSearchToolResultError < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Beta::BetaWebSearchToolResultErrorCode::TaggedSymbol) }
        attr_accessor :error_code

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              error_code:
                Anthropic::Beta::BetaWebSearchToolResultErrorCode::TaggedSymbol,
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              error_code: Anthropic::Beta::BetaWebSearchToolResultErrorCode::OrSymbol,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(error_code:, type: :web_search_tool_result_error); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::BetaWebSearchToolResultError,
              Anthropic::Internal::AnyHash
            )
          end
      end

      module BetaWebSearchToolResultErrorCode
        extend Anthropic::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::Beta::BetaWebSearchToolResultErrorCode::TaggedSymbol
            ])
          end
          def values; end
        end

        INVALID_TOOL_INPUT = T.let(
            :invalid_tool_input,
            Anthropic::Beta::BetaWebSearchToolResultErrorCode::TaggedSymbol
          )

        MAX_USES_EXCEEDED = T.let(
            :max_uses_exceeded,
            Anthropic::Beta::BetaWebSearchToolResultErrorCode::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        QUERY_TOO_LONG = T.let(
            :query_too_long,
            Anthropic::Beta::BetaWebSearchToolResultErrorCode::TaggedSymbol
          )

        TOO_MANY_REQUESTS = T.let(
            :too_many_requests,
            Anthropic::Beta::BetaWebSearchToolResultErrorCode::TaggedSymbol
          )

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Anthropic::Beta::BetaWebSearchToolResultErrorCode)
          end

        UNAVAILABLE = T.let(
            :unavailable,
            Anthropic::Beta::BetaWebSearchToolResultErrorCode::TaggedSymbol
          )
      end

      class DeletedFile < Anthropic::Internal::Type::BaseModel
        # ID of the deleted file.
        sig { returns(String) }
        attr_accessor :id

        # Deleted object type.
        #
        # For file deletion, this is always `"file_deleted"`.
        sig { returns(T.nilable(Anthropic::Beta::DeletedFile::Type::TaggedSymbol)) }
        attr_reader :type

        sig { params(type: Anthropic::Beta::DeletedFile::Type::OrSymbol).void }
        attr_writer :type

        sig do
          override
            .returns({
              id: String,
              type: Anthropic::Beta::DeletedFile::Type::TaggedSymbol
            })
        end
        def to_hash; end

        class << self
          sig { params(id: String, type: Anthropic::Beta::DeletedFile::Type::OrSymbol).returns(T.attached_class) }
          def new(
            id:, # ID of the deleted file.
            type: nil # Deleted object type.
                      # For file deletion, this is always `"file_deleted"`.
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::DeletedFile, Anthropic::Internal::AnyHash)
          end

        # Deleted object type.
        #
        # For file deletion, this is always `"file_deleted"`.
        module Type
          extend Anthropic::Internal::Type::Enum

          class << self
            sig { override.returns(T::Array[Anthropic::Beta::DeletedFile::Type::TaggedSymbol]) }
            def values; end
          end

          FILE_DELETED = T.let(
              :file_deleted,
              Anthropic::Beta::DeletedFile::Type::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::Beta::DeletedFile::Type) }
        end
      end

      class FileDeleteParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        sig do
          override
            .returns({
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::FileDeleteParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class FileDownloadParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        sig do
          override
            .returns({
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::FileDownloadParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class FileListParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # ID of the object to use as a cursor for pagination. When provided, returns the
        # page of results immediately after this object.
        sig { returns(T.nilable(String)) }
        attr_reader :after_id

        sig { params(after_id: String).void }
        attr_writer :after_id

        # ID of the object to use as a cursor for pagination. When provided, returns the
        # page of results immediately before this object.
        sig { returns(T.nilable(String)) }
        attr_reader :before_id

        sig { params(before_id: String).void }
        attr_writer :before_id

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        # Number of items to return per page.
        #
        # Defaults to `20`. Ranges from `1` to `1000`.
        sig { returns(T.nilable(Integer)) }
        attr_reader :limit

        sig { params(limit: Integer).void }
        attr_writer :limit

        sig do
          override
            .returns({
              after_id: String,
              before_id: String,
              limit: Integer,
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              after_id: String,
              before_id: String,
              limit: Integer,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            after_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                           # page of results immediately after this object.
            before_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                            # page of results immediately before this object.
            limit: nil, # Number of items to return per page.
                        # Defaults to `20`. Ranges from `1` to `1000`.
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::FileListParams, Anthropic::Internal::AnyHash)
          end
      end

      class FileMetadata < Anthropic::Internal::Type::BaseModel
        # RFC 3339 datetime string representing when the file was created.
        sig { returns(Time) }
        attr_accessor :created_at

        # Whether the file can be downloaded.
        sig { returns(T.nilable(T::Boolean)) }
        attr_reader :downloadable

        sig { params(downloadable: T::Boolean).void }
        attr_writer :downloadable

        # Original filename of the uploaded file.
        sig { returns(String) }
        attr_accessor :filename

        # Unique object identifier.
        #
        # The format and length of IDs may change over time.
        sig { returns(String) }
        attr_accessor :id

        # MIME type of the file.
        sig { returns(String) }
        attr_accessor :mime_type

        # Size of the file in bytes.
        sig { returns(Integer) }
        attr_accessor :size_bytes

        # Object type.
        #
        # For files, this is always `"file"`.
        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              id: String,
              created_at: Time,
              filename: String,
              mime_type: String,
              size_bytes: Integer,
              type: Symbol,
              downloadable: T::Boolean
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: String,
              created_at: Time,
              filename: String,
              mime_type: String,
              size_bytes: Integer,
              downloadable: T::Boolean,
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            id:, # Unique object identifier.
                 # The format and length of IDs may change over time.
            created_at:, # RFC 3339 datetime string representing when the file was created.
            filename:, # Original filename of the uploaded file.
            mime_type:, # MIME type of the file.
            size_bytes:, # Size of the file in bytes.
            downloadable: nil, # Whether the file can be downloaded.
            type: :file # Object type.
                        # For files, this is always `"file"`.
); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Beta::FileMetadata, Anthropic::Internal::AnyHash)
          end
      end

      class FileRetrieveMetadataParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        sig do
          override
            .returns({
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::FileRetrieveMetadataParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class FileUploadParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        # The file to upload
        sig { returns(Anthropic::Internal::FileInput) }
        attr_accessor :file

        sig do
          override
            .returns({
              file: Anthropic::Internal::FileInput,
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              file: Anthropic::Internal::FileInput,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            file:, # The file to upload
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::FileUploadParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class MessageCountTokensParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        # MCP servers to be utilized in this request
        sig do
          returns(T.nilable(
              T::Array[Anthropic::Beta::BetaRequestMCPServerURLDefinition]
            ))
        end
        attr_reader :mcp_servers

        sig do
          params(
            mcp_servers: T::Array[
                Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
              ]
          ).void
        end
        attr_writer :mcp_servers

        # Input messages.
        #
        # Our models are trained to operate on alternating `user` and `assistant`
        # conversational turns. When creating a new `Message`, you specify the prior
        # conversational turns with the `messages` parameter, and the model then generates
        # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
        # in your request will be combined into a single turn.
        #
        # Each input message must be an object with a `role` and `content`. You can
        # specify a single `user`-role message, or you can include multiple `user` and
        # `assistant` messages.
        #
        # If the final message uses the `assistant` role, the response content will
        # continue immediately from the content in that message. This can be used to
        # constrain part of the model's response.
        #
        # Example with a single `user` message:
        #
        # ```json
        # [{ "role": "user", "content": "Hello, Claude" }]
        # ```
        #
        # Example with multiple conversational turns:
        #
        # ```json
        # [
        #   { "role": "user", "content": "Hello there." },
        #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
        #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
        # ]
        # ```
        #
        # Example with a partially-filled response from Claude:
        #
        # ```json
        # [
        #   {
        #     "role": "user",
        #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
        #   },
        #   { "role": "assistant", "content": "The best answer is (" }
        # ]
        # ```
        #
        # Each input message `content` may be either a single `string` or an array of
        # content blocks, where each block has a specific `type`. Using a `string` for
        # `content` is shorthand for an array of one content block of type `"text"`. The
        # following input messages are equivalent:
        #
        # ```json
        # { "role": "user", "content": "Hello, Claude" }
        # ```
        #
        # ```json
        # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
        # ```
        #
        # Starting with Claude 3 models, you can also send image content blocks:
        #
        # ```json
        # {
        #   "role": "user",
        #   "content": [
        #     {
        #       "type": "image",
        #       "source": {
        #         "type": "base64",
        #         "media_type": "image/jpeg",
        #         "data": "/9j/4AAQSkZJRg..."
        #       }
        #     },
        #     { "type": "text", "text": "What is in this image?" }
        #   ]
        # }
        # ```
        #
        # We currently support the `base64` source type for images, and the `image/jpeg`,
        # `image/png`, `image/gif`, and `image/webp` media types.
        #
        # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
        # more input examples.
        #
        # Note that if you want to include a
        # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
        # the top-level `system` parameter  there is no `"system"` role for input
        # messages in the Messages API.
        #
        # There is a limit of 100,000 messages in a single request.
        sig { returns(T::Array[Anthropic::Beta::BetaMessageParam]) }
        attr_accessor :messages

        # The model that will complete your prompt.\n\nSee
        # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
        # details and options.
        sig { returns(T.any(Anthropic::Model::OrSymbol, String)) }
        attr_accessor :model

        # System prompt.
        #
        # A system prompt is a way of providing context and instructions to Claude, such
        # as specifying a particular goal or role. See our
        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
        sig do
          returns(T.nilable(
              Anthropic::Beta::MessageCountTokensParams::System::Variants
            ))
        end
        attr_reader :system_

        sig { params(system_: Anthropic::Beta::MessageCountTokensParams::System::Variants).void }
        attr_writer :system_

        # Configuration for enabling Claude's extended thinking.
        #
        # When enabled, responses include `thinking` content blocks showing Claude's
        # thinking process before the final answer. Requires a minimum budget of 1,024
        # tokens and counts towards your `max_tokens` limit.
        #
        # See
        # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
        # for details.
        sig do
          returns(T.nilable(
              T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled,
                Anthropic::Beta::BetaThinkingConfigDisabled
              )
            ))
        end
        attr_reader :thinking

        sig do
          params(
            thinking: T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
              )
          ).void
        end
        attr_writer :thinking

        # How the model should use the provided tools. The model can use a specific tool,
        # any available tool, decide by itself, or not use tools at all.
        sig do
          returns(T.nilable(
              T.any(
                Anthropic::Beta::BetaToolChoiceAuto,
                Anthropic::Beta::BetaToolChoiceAny,
                Anthropic::Beta::BetaToolChoiceTool,
                Anthropic::Beta::BetaToolChoiceNone
              )
            ))
        end
        attr_reader :tool_choice

        sig do
          params(
            tool_choice: T.any(
                Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                Anthropic::Beta::BetaToolChoiceAny::OrHash,
                Anthropic::Beta::BetaToolChoiceTool::OrHash,
                Anthropic::Beta::BetaToolChoiceNone::OrHash
              )
          ).void
        end
        attr_writer :tool_choice

        # Definitions of tools that the model may use.
        #
        # If you include `tools` in your API request, the model may return `tool_use`
        # content blocks that represent the model's use of those tools. You can then run
        # those tools using the tool input generated by the model and then optionally
        # return results back to the model using `tool_result` content blocks.
        #
        # There are two types of tools: **client tools** and **server tools**. The
        # behavior described below applies to client tools. For
        # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
        # see their individual documentation as each has its own behavior (e.g., the
        # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
        #
        # Each tool definition includes:
        #
        # - `name`: Name of the tool.
        # - `description`: Optional, but strongly-recommended description of the tool.
        # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
        #   tool `input` shape that the model will produce in `tool_use` output content
        #   blocks.
        #
        # For example, if you defined `tools` as:
        #
        # ```json
        # [
        #   {
        #     "name": "get_stock_price",
        #     "description": "Get the current stock price for a given ticker symbol.",
        #     "input_schema": {
        #       "type": "object",
        #       "properties": {
        #         "ticker": {
        #           "type": "string",
        #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
        #         }
        #       },
        #       "required": ["ticker"]
        #     }
        #   }
        # ]
        # ```
        #
        # And then asked the model "What's the S&P 500 at today?", the model might produce
        # `tool_use` content blocks in the response like this:
        #
        # ```json
        # [
        #   {
        #     "type": "tool_use",
        #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
        #     "name": "get_stock_price",
        #     "input": { "ticker": "^GSPC" }
        #   }
        # ]
        # ```
        #
        # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
        # input, and return the following back to the model in a subsequent `user`
        # message:
        #
        # ```json
        # [
        #   {
        #     "type": "tool_result",
        #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
        #     "content": "259.75 USD"
        #   }
        # ]
        # ```
        #
        # Tools can be used for workflows that include running client-side tools and
        # functions, or more generally whenever you want the model to produce a particular
        # JSON structure of output.
        #
        # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
        sig do
          returns(T.nilable(
              T::Array[
                T.any(
                  Anthropic::Beta::BetaTool,
                  Anthropic::Beta::BetaToolBash20241022,
                  Anthropic::Beta::BetaToolBash20250124,
                  Anthropic::Beta::BetaCodeExecutionTool20250522,
                  Anthropic::Beta::BetaToolComputerUse20241022,
                  Anthropic::Beta::BetaToolComputerUse20250124,
                  Anthropic::Beta::BetaToolTextEditor20241022,
                  Anthropic::Beta::BetaToolTextEditor20250124,
                  Anthropic::Beta::BetaToolTextEditor20250429,
                  Anthropic::Beta::BetaToolTextEditor20250728,
                  Anthropic::Beta::BetaWebSearchTool20250305
                )
              ]
            ))
        end
        attr_reader :tools

        sig do
          params(
            tools: T::Array[
                T.any(
                  Anthropic::Beta::BetaTool::OrHash,
                  Anthropic::Beta::BetaToolBash20241022::OrHash,
                  Anthropic::Beta::BetaToolBash20250124::OrHash,
                  Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                  Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                )
              ]
          ).void
        end
        attr_writer :tools

        sig do
          override
            .returns({
              messages: T::Array[Anthropic::Beta::BetaMessageParam],
              model: T.any(Anthropic::Model::OrSymbol, String),
              mcp_servers:
                T::Array[Anthropic::Beta::BetaRequestMCPServerURLDefinition],
              system_:
                Anthropic::Beta::MessageCountTokensParams::System::Variants,
              thinking:
                T.any(
                  Anthropic::Beta::BetaThinkingConfigEnabled,
                  Anthropic::Beta::BetaThinkingConfigDisabled
                ),
              tool_choice:
                T.any(
                  Anthropic::Beta::BetaToolChoiceAuto,
                  Anthropic::Beta::BetaToolChoiceAny,
                  Anthropic::Beta::BetaToolChoiceTool,
                  Anthropic::Beta::BetaToolChoiceNone
                ),
              tools:
                T::Array[
                  T.any(
                    Anthropic::Beta::BetaTool,
                    Anthropic::Beta::BetaToolBash20241022,
                    Anthropic::Beta::BetaToolBash20250124,
                    Anthropic::Beta::BetaCodeExecutionTool20250522,
                    Anthropic::Beta::BetaToolComputerUse20241022,
                    Anthropic::Beta::BetaToolComputerUse20250124,
                    Anthropic::Beta::BetaToolTextEditor20241022,
                    Anthropic::Beta::BetaToolTextEditor20250124,
                    Anthropic::Beta::BetaToolTextEditor20250429,
                    Anthropic::Beta::BetaToolTextEditor20250728,
                    Anthropic::Beta::BetaWebSearchTool20250305
                  )
                ],
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              messages: T::Array[Anthropic::Beta::BetaMessageParam::OrHash],
              model: T.any(Anthropic::Model::OrSymbol, String),
              mcp_servers: T::Array[
                Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
              ],
              system_: Anthropic::Beta::MessageCountTokensParams::System::Variants,
              thinking: T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
              ),
              tool_choice: T.any(
                Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                Anthropic::Beta::BetaToolChoiceAny::OrHash,
                Anthropic::Beta::BetaToolChoiceTool::OrHash,
                Anthropic::Beta::BetaToolChoiceNone::OrHash
              ),
              tools: T::Array[
                T.any(
                  Anthropic::Beta::BetaTool::OrHash,
                  Anthropic::Beta::BetaToolBash20241022::OrHash,
                  Anthropic::Beta::BetaToolBash20250124::OrHash,
                  Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                  Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                )
              ],
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            messages:, # Input messages.
                       # Our models are trained to operate on alternating `user` and `assistant`
                       # conversational turns. When creating a new `Message`, you specify the prior
                       # conversational turns with the `messages` parameter, and the model then generates
                       # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                       # in your request will be combined into a single turn.
                       # Each input message must be an object with a `role` and `content`. You can
                       # specify a single `user`-role message, or you can include multiple `user` and
                       # `assistant` messages.
                       # If the final message uses the `assistant` role, the response content will
                       # continue immediately from the content in that message. This can be used to
                       # constrain part of the model's response.
                       # Example with a single `user` message:
                       # ```json
                       # [{ "role": "user", "content": "Hello, Claude" }]
                       # ```
                       # Example with multiple conversational turns:
                       # ```json
                       # [
                       #   { "role": "user", "content": "Hello there." },
                       #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                       #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                       # ]
                       # ```
                       # Example with a partially-filled response from Claude:
                       # ```json
                       # [
                       #   {
                       #     "role": "user",
                       #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                       #   },
                       #   { "role": "assistant", "content": "The best answer is (" }
                       # ]
                       # ```
                       # Each input message `content` may be either a single `string` or an array of
                       # content blocks, where each block has a specific `type`. Using a `string` for
                       # `content` is shorthand for an array of one content block of type `"text"`. The
                       # following input messages are equivalent:
                       # ```json
                       # { "role": "user", "content": "Hello, Claude" }
                       # ```
                       # ```json
                       # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                       # ```
                       # Starting with Claude 3 models, you can also send image content blocks:
                       # ```json
                       # {
                       #   "role": "user",
                       #   "content": [
                       #     {
                       #       "type": "image",
                       #       "source": {
                       #         "type": "base64",
                       #         "media_type": "image/jpeg",
                       #         "data": "/9j/4AAQSkZJRg..."
                       #       }
                       #     },
                       #     { "type": "text", "text": "What is in this image?" }
                       #   ]
                       # }
                       # ```
                       # We currently support the `base64` source type for images, and the `image/jpeg`,
                       # `image/png`, `image/gif`, and `image/webp` media types.
                       # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                       # more input examples.
                       # Note that if you want to include a
                       # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                       # the top-level `system` parameter  there is no `"system"` role for input
                       # messages in the Messages API.
                       # There is a limit of 100,000 messages in a single request.
            model:, # The model that will complete your prompt.\n\nSee
                    # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                    # details and options.
            mcp_servers: nil, # MCP servers to be utilized in this request
            system_: nil, # System prompt.
                          # A system prompt is a way of providing context and instructions to Claude, such
                          # as specifying a particular goal or role. See our
                          # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
            thinking: nil, # Configuration for enabling Claude's extended thinking.
                           # When enabled, responses include `thinking` content blocks showing Claude's
                           # thinking process before the final answer. Requires a minimum budget of 1,024
                           # tokens and counts towards your `max_tokens` limit.
                           # See
                           # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                           # for details.
            tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                              # any available tool, decide by itself, or not use tools at all.
            tools: nil, # Definitions of tools that the model may use.
                        # If you include `tools` in your API request, the model may return `tool_use`
                        # content blocks that represent the model's use of those tools. You can then run
                        # those tools using the tool input generated by the model and then optionally
                        # return results back to the model using `tool_result` content blocks.
                        # There are two types of tools: **client tools** and **server tools**. The
                        # behavior described below applies to client tools. For
                        # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                        # see their individual documentation as each has its own behavior (e.g., the
                        # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                        # Each tool definition includes:
                        # - `name`: Name of the tool.
                        # - `description`: Optional, but strongly-recommended description of the tool.
                        # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                        #   tool `input` shape that the model will produce in `tool_use` output content
                        #   blocks.
                        # For example, if you defined `tools` as:
                        # ```json
                        # [
                        #   {
                        #     "name": "get_stock_price",
                        #     "description": "Get the current stock price for a given ticker symbol.",
                        #     "input_schema": {
                        #       "type": "object",
                        #       "properties": {
                        #         "ticker": {
                        #           "type": "string",
                        #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                        #         }
                        #       },
                        #       "required": ["ticker"]
                        #     }
                        #   }
                        # ]
                        # ```
                        # And then asked the model "What's the S&P 500 at today?", the model might produce
                        # `tool_use` content blocks in the response like this:
                        # ```json
                        # [
                        #   {
                        #     "type": "tool_use",
                        #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                        #     "name": "get_stock_price",
                        #     "input": { "ticker": "^GSPC" }
                        #   }
                        # ]
                        # ```
                        # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                        # input, and return the following back to the model in a subsequent `user`
                        # message:
                        # ```json
                        # [
                        #   {
                        #     "type": "tool_result",
                        #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                        #     "content": "259.75 USD"
                        #   }
                        # ]
                        # ```
                        # Tools can be used for workflows that include running client-side tools and
                        # functions, or more generally whenever you want the model to produce a particular
                        # JSON structure of output.
                        # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::MessageCountTokensParams,
              Anthropic::Internal::AnyHash
            )
          end

        # System prompt.
        #
        # A system prompt is a way of providing context and instructions to Claude, such
        # as specifying a particular goal or role. See our
        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
        module System
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::MessageCountTokensParams::System::Variants
              ])
            end
            def variants; end
          end

          BetaTextBlockParamArray = T.let(
              Anthropic::Internal::Type::ArrayOf[
                Anthropic::Beta::BetaTextBlockParam
              ],
              Anthropic::Internal::Type::Converter
            )

          Variants = T.type_alias do
              T.any(String, T::Array[Anthropic::Beta::BetaTextBlockParam])
            end
        end

        module Tool
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::MessageCountTokensParams::Tool::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias do
              T.any(
                Anthropic::Beta::BetaTool,
                Anthropic::Beta::BetaToolBash20241022,
                Anthropic::Beta::BetaToolBash20250124,
                Anthropic::Beta::BetaCodeExecutionTool20250522,
                Anthropic::Beta::BetaToolComputerUse20241022,
                Anthropic::Beta::BetaToolComputerUse20250124,
                Anthropic::Beta::BetaToolTextEditor20241022,
                Anthropic::Beta::BetaToolTextEditor20250124,
                Anthropic::Beta::BetaToolTextEditor20250429,
                Anthropic::Beta::BetaToolTextEditor20250728,
                Anthropic::Beta::BetaWebSearchTool20250305
              )
            end
        end
      end

      class MessageCreateParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        # Container identifier for reuse across requests.
        sig { returns(T.nilable(String)) }
        attr_accessor :container

        # The maximum number of tokens to generate before stopping.
        #
        # Note that our models may stop _before_ reaching this maximum. This parameter
        # only specifies the absolute maximum number of tokens to generate.
        #
        # Different models have different maximum values for this parameter. See
        # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
        sig { returns(Integer) }
        attr_accessor :max_tokens

        # MCP servers to be utilized in this request
        sig do
          returns(T.nilable(
              T::Array[Anthropic::Beta::BetaRequestMCPServerURLDefinition]
            ))
        end
        attr_reader :mcp_servers

        sig do
          params(
            mcp_servers: T::Array[
                Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
              ]
          ).void
        end
        attr_writer :mcp_servers

        # Input messages.
        #
        # Our models are trained to operate on alternating `user` and `assistant`
        # conversational turns. When creating a new `Message`, you specify the prior
        # conversational turns with the `messages` parameter, and the model then generates
        # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
        # in your request will be combined into a single turn.
        #
        # Each input message must be an object with a `role` and `content`. You can
        # specify a single `user`-role message, or you can include multiple `user` and
        # `assistant` messages.
        #
        # If the final message uses the `assistant` role, the response content will
        # continue immediately from the content in that message. This can be used to
        # constrain part of the model's response.
        #
        # Example with a single `user` message:
        #
        # ```json
        # [{ "role": "user", "content": "Hello, Claude" }]
        # ```
        #
        # Example with multiple conversational turns:
        #
        # ```json
        # [
        #   { "role": "user", "content": "Hello there." },
        #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
        #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
        # ]
        # ```
        #
        # Example with a partially-filled response from Claude:
        #
        # ```json
        # [
        #   {
        #     "role": "user",
        #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
        #   },
        #   { "role": "assistant", "content": "The best answer is (" }
        # ]
        # ```
        #
        # Each input message `content` may be either a single `string` or an array of
        # content blocks, where each block has a specific `type`. Using a `string` for
        # `content` is shorthand for an array of one content block of type `"text"`. The
        # following input messages are equivalent:
        #
        # ```json
        # { "role": "user", "content": "Hello, Claude" }
        # ```
        #
        # ```json
        # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
        # ```
        #
        # Starting with Claude 3 models, you can also send image content blocks:
        #
        # ```json
        # {
        #   "role": "user",
        #   "content": [
        #     {
        #       "type": "image",
        #       "source": {
        #         "type": "base64",
        #         "media_type": "image/jpeg",
        #         "data": "/9j/4AAQSkZJRg..."
        #       }
        #     },
        #     { "type": "text", "text": "What is in this image?" }
        #   ]
        # }
        # ```
        #
        # We currently support the `base64` source type for images, and the `image/jpeg`,
        # `image/png`, `image/gif`, and `image/webp` media types.
        #
        # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
        # more input examples.
        #
        # Note that if you want to include a
        # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
        # the top-level `system` parameter  there is no `"system"` role for input
        # messages in the Messages API.
        #
        # There is a limit of 100,000 messages in a single request.
        sig { returns(T::Array[Anthropic::Beta::BetaMessageParam]) }
        attr_accessor :messages

        # An object describing metadata about the request.
        sig { returns(T.nilable(Anthropic::Beta::BetaMetadata)) }
        attr_reader :metadata

        sig { params(metadata: Anthropic::Beta::BetaMetadata::OrHash).void }
        attr_writer :metadata

        # The model that will complete your prompt.\n\nSee
        # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
        # details and options.
        sig { returns(T.any(Anthropic::Model::OrSymbol, String)) }
        attr_accessor :model

        # Determines whether to use priority capacity (if available) or standard capacity
        # for this request.
        #
        # Anthropic offers different levels of service for your API requests. See
        # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
        sig do
          returns(T.nilable(
              Anthropic::Beta::MessageCreateParams::ServiceTier::OrSymbol
            ))
        end
        attr_reader :service_tier

        sig { params(service_tier: Anthropic::Beta::MessageCreateParams::ServiceTier::OrSymbol).void }
        attr_writer :service_tier

        # Custom text sequences that will cause the model to stop generating.
        #
        # Our models will normally stop when they have naturally completed their turn,
        # which will result in a response `stop_reason` of `"end_turn"`.
        #
        # If you want the model to stop generating when it encounters custom strings of
        # text, you can use the `stop_sequences` parameter. If the model encounters one of
        # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
        # and the response `stop_sequence` value will contain the matched stop sequence.
        sig { returns(T.nilable(T::Array[String])) }
        attr_reader :stop_sequences

        sig { params(stop_sequences: T::Array[String]).void }
        attr_writer :stop_sequences

        # System prompt.
        #
        # A system prompt is a way of providing context and instructions to Claude, such
        # as specifying a particular goal or role. See our
        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
        sig { returns(T.nilable(Anthropic::Beta::MessageCreateParams::System::Variants)) }
        attr_reader :system_

        sig { params(system_: Anthropic::Beta::MessageCreateParams::System::Variants).void }
        attr_writer :system_

        # Amount of randomness injected into the response.
        #
        # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
        # for analytical / multiple choice, and closer to `1.0` for creative and
        # generative tasks.
        #
        # Note that even with `temperature` of `0.0`, the results will not be fully
        # deterministic.
        sig { returns(T.nilable(Float)) }
        attr_reader :temperature

        sig { params(temperature: Float).void }
        attr_writer :temperature

        # Configuration for enabling Claude's extended thinking.
        #
        # When enabled, responses include `thinking` content blocks showing Claude's
        # thinking process before the final answer. Requires a minimum budget of 1,024
        # tokens and counts towards your `max_tokens` limit.
        #
        # See
        # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
        # for details.
        sig do
          returns(T.nilable(
              T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled,
                Anthropic::Beta::BetaThinkingConfigDisabled
              )
            ))
        end
        attr_reader :thinking

        sig do
          params(
            thinking: T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
              )
          ).void
        end
        attr_writer :thinking

        # How the model should use the provided tools. The model can use a specific tool,
        # any available tool, decide by itself, or not use tools at all.
        sig do
          returns(T.nilable(
              T.any(
                Anthropic::Beta::BetaToolChoiceAuto,
                Anthropic::Beta::BetaToolChoiceAny,
                Anthropic::Beta::BetaToolChoiceTool,
                Anthropic::Beta::BetaToolChoiceNone
              )
            ))
        end
        attr_reader :tool_choice

        sig do
          params(
            tool_choice: T.any(
                Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                Anthropic::Beta::BetaToolChoiceAny::OrHash,
                Anthropic::Beta::BetaToolChoiceTool::OrHash,
                Anthropic::Beta::BetaToolChoiceNone::OrHash
              )
          ).void
        end
        attr_writer :tool_choice

        # Definitions of tools that the model may use.
        #
        # If you include `tools` in your API request, the model may return `tool_use`
        # content blocks that represent the model's use of those tools. You can then run
        # those tools using the tool input generated by the model and then optionally
        # return results back to the model using `tool_result` content blocks.
        #
        # There are two types of tools: **client tools** and **server tools**. The
        # behavior described below applies to client tools. For
        # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
        # see their individual documentation as each has its own behavior (e.g., the
        # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
        #
        # Each tool definition includes:
        #
        # - `name`: Name of the tool.
        # - `description`: Optional, but strongly-recommended description of the tool.
        # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
        #   tool `input` shape that the model will produce in `tool_use` output content
        #   blocks.
        #
        # For example, if you defined `tools` as:
        #
        # ```json
        # [
        #   {
        #     "name": "get_stock_price",
        #     "description": "Get the current stock price for a given ticker symbol.",
        #     "input_schema": {
        #       "type": "object",
        #       "properties": {
        #         "ticker": {
        #           "type": "string",
        #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
        #         }
        #       },
        #       "required": ["ticker"]
        #     }
        #   }
        # ]
        # ```
        #
        # And then asked the model "What's the S&P 500 at today?", the model might produce
        # `tool_use` content blocks in the response like this:
        #
        # ```json
        # [
        #   {
        #     "type": "tool_use",
        #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
        #     "name": "get_stock_price",
        #     "input": { "ticker": "^GSPC" }
        #   }
        # ]
        # ```
        #
        # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
        # input, and return the following back to the model in a subsequent `user`
        # message:
        #
        # ```json
        # [
        #   {
        #     "type": "tool_result",
        #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
        #     "content": "259.75 USD"
        #   }
        # ]
        # ```
        #
        # Tools can be used for workflows that include running client-side tools and
        # functions, or more generally whenever you want the model to produce a particular
        # JSON structure of output.
        #
        # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
        sig do
          returns(T.nilable(
              T::Array[
                T.any(
                  Anthropic::Beta::BetaTool,
                  Anthropic::Beta::BetaToolBash20241022,
                  Anthropic::Beta::BetaToolBash20250124,
                  Anthropic::Beta::BetaCodeExecutionTool20250522,
                  Anthropic::Beta::BetaToolComputerUse20241022,
                  Anthropic::Beta::BetaToolComputerUse20250124,
                  Anthropic::Beta::BetaToolTextEditor20241022,
                  Anthropic::Beta::BetaToolTextEditor20250124,
                  Anthropic::Beta::BetaToolTextEditor20250429,
                  Anthropic::Beta::BetaToolTextEditor20250728,
                  Anthropic::Beta::BetaWebSearchTool20250305
                )
              ]
            ))
        end
        attr_reader :tools

        sig do
          params(
            tools: T::Array[
                T.any(
                  Anthropic::Beta::BetaTool::OrHash,
                  Anthropic::Beta::BetaToolBash20241022::OrHash,
                  Anthropic::Beta::BetaToolBash20250124::OrHash,
                  Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                  Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                )
              ]
          ).void
        end
        attr_writer :tools

        # Only sample from the top K options for each subsequent token.
        #
        # Used to remove "long tail" low probability responses.
        # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
        #
        # Recommended for advanced use cases only. You usually only need to use
        # `temperature`.
        sig { returns(T.nilable(Integer)) }
        attr_reader :top_k

        sig { params(top_k: Integer).void }
        attr_writer :top_k

        # Use nucleus sampling.
        #
        # In nucleus sampling, we compute the cumulative distribution over all the options
        # for each subsequent token in decreasing probability order and cut it off once it
        # reaches a particular probability specified by `top_p`. You should either alter
        # `temperature` or `top_p`, but not both.
        #
        # Recommended for advanced use cases only. You usually only need to use
        # `temperature`.
        sig { returns(T.nilable(Float)) }
        attr_reader :top_p

        sig { params(top_p: Float).void }
        attr_writer :top_p

        sig do
          override
            .returns({
              max_tokens: Integer,
              messages: T::Array[Anthropic::Beta::BetaMessageParam],
              model: T.any(Anthropic::Model::OrSymbol, String),
              container: T.nilable(String),
              mcp_servers:
                T::Array[Anthropic::Beta::BetaRequestMCPServerURLDefinition],
              metadata: Anthropic::Beta::BetaMetadata,
              service_tier:
                Anthropic::Beta::MessageCreateParams::ServiceTier::OrSymbol,
              stop_sequences: T::Array[String],
              system_: Anthropic::Beta::MessageCreateParams::System::Variants,
              temperature: Float,
              thinking:
                T.any(
                  Anthropic::Beta::BetaThinkingConfigEnabled,
                  Anthropic::Beta::BetaThinkingConfigDisabled
                ),
              tool_choice:
                T.any(
                  Anthropic::Beta::BetaToolChoiceAuto,
                  Anthropic::Beta::BetaToolChoiceAny,
                  Anthropic::Beta::BetaToolChoiceTool,
                  Anthropic::Beta::BetaToolChoiceNone
                ),
              tools:
                T::Array[
                  T.any(
                    Anthropic::Beta::BetaTool,
                    Anthropic::Beta::BetaToolBash20241022,
                    Anthropic::Beta::BetaToolBash20250124,
                    Anthropic::Beta::BetaCodeExecutionTool20250522,
                    Anthropic::Beta::BetaToolComputerUse20241022,
                    Anthropic::Beta::BetaToolComputerUse20250124,
                    Anthropic::Beta::BetaToolTextEditor20241022,
                    Anthropic::Beta::BetaToolTextEditor20250124,
                    Anthropic::Beta::BetaToolTextEditor20250429,
                    Anthropic::Beta::BetaToolTextEditor20250728,
                    Anthropic::Beta::BetaWebSearchTool20250305
                  )
                ],
              top_k: Integer,
              top_p: Float,
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              max_tokens: Integer,
              messages: T::Array[Anthropic::Beta::BetaMessageParam::OrHash],
              model: T.any(Anthropic::Model::OrSymbol, String),
              container: T.nilable(String),
              mcp_servers: T::Array[
                Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
              ],
              metadata: Anthropic::Beta::BetaMetadata::OrHash,
              service_tier: Anthropic::Beta::MessageCreateParams::ServiceTier::OrSymbol,
              stop_sequences: T::Array[String],
              system_: Anthropic::Beta::MessageCreateParams::System::Variants,
              temperature: Float,
              thinking: T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
              ),
              tool_choice: T.any(
                Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                Anthropic::Beta::BetaToolChoiceAny::OrHash,
                Anthropic::Beta::BetaToolChoiceTool::OrHash,
                Anthropic::Beta::BetaToolChoiceNone::OrHash
              ),
              tools: T::Array[
                T.any(
                  Anthropic::Beta::BetaTool::OrHash,
                  Anthropic::Beta::BetaToolBash20241022::OrHash,
                  Anthropic::Beta::BetaToolBash20250124::OrHash,
                  Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                  Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                )
              ],
              top_k: Integer,
              top_p: Float,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            max_tokens:, # The maximum number of tokens to generate before stopping.
                         # Note that our models may stop _before_ reaching this maximum. This parameter
                         # only specifies the absolute maximum number of tokens to generate.
                         # Different models have different maximum values for this parameter. See
                         # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
            messages:, # Input messages.
                       # Our models are trained to operate on alternating `user` and `assistant`
                       # conversational turns. When creating a new `Message`, you specify the prior
                       # conversational turns with the `messages` parameter, and the model then generates
                       # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                       # in your request will be combined into a single turn.
                       # Each input message must be an object with a `role` and `content`. You can
                       # specify a single `user`-role message, or you can include multiple `user` and
                       # `assistant` messages.
                       # If the final message uses the `assistant` role, the response content will
                       # continue immediately from the content in that message. This can be used to
                       # constrain part of the model's response.
                       # Example with a single `user` message:
                       # ```json
                       # [{ "role": "user", "content": "Hello, Claude" }]
                       # ```
                       # Example with multiple conversational turns:
                       # ```json
                       # [
                       #   { "role": "user", "content": "Hello there." },
                       #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                       #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                       # ]
                       # ```
                       # Example with a partially-filled response from Claude:
                       # ```json
                       # [
                       #   {
                       #     "role": "user",
                       #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                       #   },
                       #   { "role": "assistant", "content": "The best answer is (" }
                       # ]
                       # ```
                       # Each input message `content` may be either a single `string` or an array of
                       # content blocks, where each block has a specific `type`. Using a `string` for
                       # `content` is shorthand for an array of one content block of type `"text"`. The
                       # following input messages are equivalent:
                       # ```json
                       # { "role": "user", "content": "Hello, Claude" }
                       # ```
                       # ```json
                       # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                       # ```
                       # Starting with Claude 3 models, you can also send image content blocks:
                       # ```json
                       # {
                       #   "role": "user",
                       #   "content": [
                       #     {
                       #       "type": "image",
                       #       "source": {
                       #         "type": "base64",
                       #         "media_type": "image/jpeg",
                       #         "data": "/9j/4AAQSkZJRg..."
                       #       }
                       #     },
                       #     { "type": "text", "text": "What is in this image?" }
                       #   ]
                       # }
                       # ```
                       # We currently support the `base64` source type for images, and the `image/jpeg`,
                       # `image/png`, `image/gif`, and `image/webp` media types.
                       # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                       # more input examples.
                       # Note that if you want to include a
                       # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                       # the top-level `system` parameter  there is no `"system"` role for input
                       # messages in the Messages API.
                       # There is a limit of 100,000 messages in a single request.
            model:, # The model that will complete your prompt.\n\nSee
                    # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                    # details and options.
            container: nil, # Container identifier for reuse across requests.
            mcp_servers: nil, # MCP servers to be utilized in this request
            metadata: nil, # An object describing metadata about the request.
            service_tier: nil, # Determines whether to use priority capacity (if available) or standard capacity
                               # for this request.
                               # Anthropic offers different levels of service for your API requests. See
                               # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
            stop_sequences: nil, # Custom text sequences that will cause the model to stop generating.
                                 # Our models will normally stop when they have naturally completed their turn,
                                 # which will result in a response `stop_reason` of `"end_turn"`.
                                 # If you want the model to stop generating when it encounters custom strings of
                                 # text, you can use the `stop_sequences` parameter. If the model encounters one of
                                 # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                                 # and the response `stop_sequence` value will contain the matched stop sequence.
            system_: nil, # System prompt.
                          # A system prompt is a way of providing context and instructions to Claude, such
                          # as specifying a particular goal or role. See our
                          # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
            temperature: nil, # Amount of randomness injected into the response.
                              # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                              # for analytical / multiple choice, and closer to `1.0` for creative and
                              # generative tasks.
                              # Note that even with `temperature` of `0.0`, the results will not be fully
                              # deterministic.
            thinking: nil, # Configuration for enabling Claude's extended thinking.
                           # When enabled, responses include `thinking` content blocks showing Claude's
                           # thinking process before the final answer. Requires a minimum budget of 1,024
                           # tokens and counts towards your `max_tokens` limit.
                           # See
                           # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                           # for details.
            tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                              # any available tool, decide by itself, or not use tools at all.
            tools: nil, # Definitions of tools that the model may use.
                        # If you include `tools` in your API request, the model may return `tool_use`
                        # content blocks that represent the model's use of those tools. You can then run
                        # those tools using the tool input generated by the model and then optionally
                        # return results back to the model using `tool_result` content blocks.
                        # There are two types of tools: **client tools** and **server tools**. The
                        # behavior described below applies to client tools. For
                        # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                        # see their individual documentation as each has its own behavior (e.g., the
                        # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                        # Each tool definition includes:
                        # - `name`: Name of the tool.
                        # - `description`: Optional, but strongly-recommended description of the tool.
                        # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                        #   tool `input` shape that the model will produce in `tool_use` output content
                        #   blocks.
                        # For example, if you defined `tools` as:
                        # ```json
                        # [
                        #   {
                        #     "name": "get_stock_price",
                        #     "description": "Get the current stock price for a given ticker symbol.",
                        #     "input_schema": {
                        #       "type": "object",
                        #       "properties": {
                        #         "ticker": {
                        #           "type": "string",
                        #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                        #         }
                        #       },
                        #       "required": ["ticker"]
                        #     }
                        #   }
                        # ]
                        # ```
                        # And then asked the model "What's the S&P 500 at today?", the model might produce
                        # `tool_use` content blocks in the response like this:
                        # ```json
                        # [
                        #   {
                        #     "type": "tool_use",
                        #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                        #     "name": "get_stock_price",
                        #     "input": { "ticker": "^GSPC" }
                        #   }
                        # ]
                        # ```
                        # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                        # input, and return the following back to the model in a subsequent `user`
                        # message:
                        # ```json
                        # [
                        #   {
                        #     "type": "tool_result",
                        #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                        #     "content": "259.75 USD"
                        #   }
                        # ]
                        # ```
                        # Tools can be used for workflows that include running client-side tools and
                        # functions, or more generally whenever you want the model to produce a particular
                        # JSON structure of output.
                        # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
            top_k: nil, # Only sample from the top K options for each subsequent token.
                        # Used to remove "long tail" low probability responses.
                        # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                        # Recommended for advanced use cases only. You usually only need to use
                        # `temperature`.
            top_p: nil, # Use nucleus sampling.
                        # In nucleus sampling, we compute the cumulative distribution over all the options
                        # for each subsequent token in decreasing probability order and cut it off once it
                        # reaches a particular probability specified by `top_p`. You should either alter
                        # `temperature` or `top_p`, but not both.
                        # Recommended for advanced use cases only. You usually only need to use
                        # `temperature`.
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::MessageCreateParams,
              Anthropic::Internal::AnyHash
            )
          end

        # Determines whether to use priority capacity (if available) or standard capacity
        # for this request.
        #
        # Anthropic offers different levels of service for your API requests. See
        # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
        module ServiceTier
          extend Anthropic::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::MessageCreateParams::ServiceTier::TaggedSymbol
              ])
            end
            def values; end
          end

          AUTO = T.let(
              :auto,
              Anthropic::Beta::MessageCreateParams::ServiceTier::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          STANDARD_ONLY = T.let(
              :standard_only,
              Anthropic::Beta::MessageCreateParams::ServiceTier::TaggedSymbol
            )

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Anthropic::Beta::MessageCreateParams::ServiceTier)
            end
        end

        # System prompt.
        #
        # A system prompt is a way of providing context and instructions to Claude, such
        # as specifying a particular goal or role. See our
        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
        module System
          extend Anthropic::Internal::Type::Union

          class << self
            sig { override.returns(T::Array[Anthropic::Beta::MessageCreateParams::System::Variants]) }
            def variants; end
          end

          BetaTextBlockParamArray = T.let(
              Anthropic::Internal::Type::ArrayOf[
                Anthropic::Beta::BetaTextBlockParam
              ],
              Anthropic::Internal::Type::Converter
            )

          Variants = T.type_alias do
              T.any(String, T::Array[Anthropic::Beta::BetaTextBlockParam])
            end
        end
      end

      module Messages
        class BatchCancelParams < Anthropic::Internal::Type::BaseModel
          extend Anthropic::Internal::Type::RequestParameters::Converter
          include Anthropic::Internal::Type::RequestParameters

          # Optional header to specify the beta version(s) you want to use.
          sig do
            returns(T.nilable(
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
              ))
          end
          attr_reader :betas

          sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
          attr_writer :betas

          sig do
            override
              .returns({
                betas:
                  T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions::OrHash
              ).returns(T.attached_class)
            end
            def new(
              betas: nil, # Optional header to specify the beta version(s) you want to use.
              request_options: {}
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BatchCancelParams,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BatchCreateParams < Anthropic::Internal::Type::BaseModel
          extend Anthropic::Internal::Type::RequestParameters::Converter
          include Anthropic::Internal::Type::RequestParameters

          # Optional header to specify the beta version(s) you want to use.
          sig do
            returns(T.nilable(
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
              ))
          end
          attr_reader :betas

          sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
          attr_writer :betas

          # List of requests for prompt completion. Each is an individual request to create
          # a Message.
          sig { returns(T::Array[Anthropic::Beta::Messages::BatchCreateParams::Request]) }
          attr_accessor :requests

          sig do
            override
              .returns({
                requests:
                  T::Array[
                    Anthropic::Beta::Messages::BatchCreateParams::Request
                  ],
                betas:
                  T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                requests: T::Array[
                  Anthropic::Beta::Messages::BatchCreateParams::Request::OrHash
                ],
                betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions::OrHash
              ).returns(T.attached_class)
            end
            def new(
              requests:, # List of requests for prompt completion. Each is an individual request to create
                         # a Message.
              betas: nil, # Optional header to specify the beta version(s) you want to use.
              request_options: {}
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BatchCreateParams,
                Anthropic::Internal::AnyHash
              )
            end

          class Request < Anthropic::Internal::Type::BaseModel
            # Developer-provided ID created for each request in a Message Batch. Useful for
            # matching results to requests, as results may be given out of request order.
            #
            # Must be unique for each request within the Message Batch.
            sig { returns(String) }
            attr_accessor :custom_id

            # Messages API creation parameters for the individual request.
            #
            # See the [Messages API reference](/en/api/messages) for full documentation on
            # available parameters.
            sig { returns(Anthropic::Beta::Messages::BatchCreateParams::Request::Params) }
            attr_reader :params

            sig { params(params: Anthropic::Beta::Messages::BatchCreateParams::Request::Params::OrHash).void }
            attr_writer :params

            sig do
              override
                .returns({
                  custom_id: String,
                  params:
                    Anthropic::Beta::Messages::BatchCreateParams::Request::Params
                })
            end
            def to_hash; end

            class << self
              sig do
                params(
                  custom_id: String,
                  params: Anthropic::Beta::Messages::BatchCreateParams::Request::Params::OrHash
                ).returns(T.attached_class)
              end
              def new(
                custom_id:, # Developer-provided ID created for each request in a Message Batch. Useful for
                            # matching results to requests, as results may be given out of request order.
                            # Must be unique for each request within the Message Batch.
                params: # Messages API creation parameters for the individual request.
                        # See the [Messages API reference](/en/api/messages) for full documentation on
                        # available parameters.
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Anthropic::Beta::Messages::BatchCreateParams::Request,
                  Anthropic::Internal::AnyHash
                )
              end

            class Params < Anthropic::Internal::Type::BaseModel
              # Container identifier for reuse across requests.
              sig { returns(T.nilable(String)) }
              attr_accessor :container

              # The maximum number of tokens to generate before stopping.
              #
              # Note that our models may stop _before_ reaching this maximum. This parameter
              # only specifies the absolute maximum number of tokens to generate.
              #
              # Different models have different maximum values for this parameter. See
              # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
              sig { returns(Integer) }
              attr_accessor :max_tokens

              # MCP servers to be utilized in this request
              sig do
                returns(T.nilable(
                    T::Array[Anthropic::Beta::BetaRequestMCPServerURLDefinition]
                  ))
              end
              attr_reader :mcp_servers

              sig do
                params(
                  mcp_servers: T::Array[
                      Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
                    ]
                ).void
              end
              attr_writer :mcp_servers

              # Input messages.
              #
              # Our models are trained to operate on alternating `user` and `assistant`
              # conversational turns. When creating a new `Message`, you specify the prior
              # conversational turns with the `messages` parameter, and the model then generates
              # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
              # in your request will be combined into a single turn.
              #
              # Each input message must be an object with a `role` and `content`. You can
              # specify a single `user`-role message, or you can include multiple `user` and
              # `assistant` messages.
              #
              # If the final message uses the `assistant` role, the response content will
              # continue immediately from the content in that message. This can be used to
              # constrain part of the model's response.
              #
              # Example with a single `user` message:
              #
              # ```json
              # [{ "role": "user", "content": "Hello, Claude" }]
              # ```
              #
              # Example with multiple conversational turns:
              #
              # ```json
              # [
              #   { "role": "user", "content": "Hello there." },
              #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
              #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
              # ]
              # ```
              #
              # Example with a partially-filled response from Claude:
              #
              # ```json
              # [
              #   {
              #     "role": "user",
              #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
              #   },
              #   { "role": "assistant", "content": "The best answer is (" }
              # ]
              # ```
              #
              # Each input message `content` may be either a single `string` or an array of
              # content blocks, where each block has a specific `type`. Using a `string` for
              # `content` is shorthand for an array of one content block of type `"text"`. The
              # following input messages are equivalent:
              #
              # ```json
              # { "role": "user", "content": "Hello, Claude" }
              # ```
              #
              # ```json
              # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
              # ```
              #
              # Starting with Claude 3 models, you can also send image content blocks:
              #
              # ```json
              # {
              #   "role": "user",
              #   "content": [
              #     {
              #       "type": "image",
              #       "source": {
              #         "type": "base64",
              #         "media_type": "image/jpeg",
              #         "data": "/9j/4AAQSkZJRg..."
              #       }
              #     },
              #     { "type": "text", "text": "What is in this image?" }
              #   ]
              # }
              # ```
              #
              # We currently support the `base64` source type for images, and the `image/jpeg`,
              # `image/png`, `image/gif`, and `image/webp` media types.
              #
              # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
              # more input examples.
              #
              # Note that if you want to include a
              # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
              # the top-level `system` parameter  there is no `"system"` role for input
              # messages in the Messages API.
              #
              # There is a limit of 100,000 messages in a single request.
              sig { returns(T::Array[Anthropic::Beta::BetaMessageParam]) }
              attr_accessor :messages

              # An object describing metadata about the request.
              sig { returns(T.nilable(Anthropic::Beta::BetaMetadata)) }
              attr_reader :metadata

              sig { params(metadata: Anthropic::Beta::BetaMetadata::OrHash).void }
              attr_writer :metadata

              # The model that will complete your prompt.\n\nSee
              # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
              # details and options.
              sig { returns(T.any(Anthropic::Model::OrSymbol, String)) }
              attr_accessor :model

              # Determines whether to use priority capacity (if available) or standard capacity
              # for this request.
              #
              # Anthropic offers different levels of service for your API requests. See
              # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
              sig do
                returns(T.nilable(
                    Anthropic::Beta::Messages::BatchCreateParams::Request::Params::ServiceTier::OrSymbol
                  ))
              end
              attr_reader :service_tier

              sig do
                params(
                  service_tier: Anthropic::Beta::Messages::BatchCreateParams::Request::Params::ServiceTier::OrSymbol
                ).void
              end
              attr_writer :service_tier

              # Custom text sequences that will cause the model to stop generating.
              #
              # Our models will normally stop when they have naturally completed their turn,
              # which will result in a response `stop_reason` of `"end_turn"`.
              #
              # If you want the model to stop generating when it encounters custom strings of
              # text, you can use the `stop_sequences` parameter. If the model encounters one of
              # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
              # and the response `stop_sequence` value will contain the matched stop sequence.
              sig { returns(T.nilable(T::Array[String])) }
              attr_reader :stop_sequences

              sig { params(stop_sequences: T::Array[String]).void }
              attr_writer :stop_sequences

              # Whether to incrementally stream the response using server-sent events.
              #
              # See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
              # details.
              sig { returns(T.nilable(T::Boolean)) }
              attr_reader :stream

              sig { params(stream: T::Boolean).void }
              attr_writer :stream

              # System prompt.
              #
              # A system prompt is a way of providing context and instructions to Claude, such
              # as specifying a particular goal or role. See our
              # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
              sig do
                returns(T.nilable(
                    Anthropic::Beta::Messages::BatchCreateParams::Request::Params::System::Variants
                  ))
              end
              attr_reader :system_

              sig do
                params(
                  system_: Anthropic::Beta::Messages::BatchCreateParams::Request::Params::System::Variants
                ).void
              end
              attr_writer :system_

              # Amount of randomness injected into the response.
              #
              # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
              # for analytical / multiple choice, and closer to `1.0` for creative and
              # generative tasks.
              #
              # Note that even with `temperature` of `0.0`, the results will not be fully
              # deterministic.
              sig { returns(T.nilable(Float)) }
              attr_reader :temperature

              sig { params(temperature: Float).void }
              attr_writer :temperature

              # Configuration for enabling Claude's extended thinking.
              #
              # When enabled, responses include `thinking` content blocks showing Claude's
              # thinking process before the final answer. Requires a minimum budget of 1,024
              # tokens and counts towards your `max_tokens` limit.
              #
              # See
              # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
              # for details.
              sig do
                returns(T.nilable(
                    T.any(
                      Anthropic::Beta::BetaThinkingConfigEnabled,
                      Anthropic::Beta::BetaThinkingConfigDisabled
                    )
                  ))
              end
              attr_reader :thinking

              sig do
                params(
                  thinking: T.any(
                      Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                      Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
                    )
                ).void
              end
              attr_writer :thinking

              # How the model should use the provided tools. The model can use a specific tool,
              # any available tool, decide by itself, or not use tools at all.
              sig do
                returns(T.nilable(
                    T.any(
                      Anthropic::Beta::BetaToolChoiceAuto,
                      Anthropic::Beta::BetaToolChoiceAny,
                      Anthropic::Beta::BetaToolChoiceTool,
                      Anthropic::Beta::BetaToolChoiceNone
                    )
                  ))
              end
              attr_reader :tool_choice

              sig do
                params(
                  tool_choice: T.any(
                      Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                      Anthropic::Beta::BetaToolChoiceAny::OrHash,
                      Anthropic::Beta::BetaToolChoiceTool::OrHash,
                      Anthropic::Beta::BetaToolChoiceNone::OrHash
                    )
                ).void
              end
              attr_writer :tool_choice

              # Definitions of tools that the model may use.
              #
              # If you include `tools` in your API request, the model may return `tool_use`
              # content blocks that represent the model's use of those tools. You can then run
              # those tools using the tool input generated by the model and then optionally
              # return results back to the model using `tool_result` content blocks.
              #
              # There are two types of tools: **client tools** and **server tools**. The
              # behavior described below applies to client tools. For
              # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
              # see their individual documentation as each has its own behavior (e.g., the
              # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
              #
              # Each tool definition includes:
              #
              # - `name`: Name of the tool.
              # - `description`: Optional, but strongly-recommended description of the tool.
              # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
              #   tool `input` shape that the model will produce in `tool_use` output content
              #   blocks.
              #
              # For example, if you defined `tools` as:
              #
              # ```json
              # [
              #   {
              #     "name": "get_stock_price",
              #     "description": "Get the current stock price for a given ticker symbol.",
              #     "input_schema": {
              #       "type": "object",
              #       "properties": {
              #         "ticker": {
              #           "type": "string",
              #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
              #         }
              #       },
              #       "required": ["ticker"]
              #     }
              #   }
              # ]
              # ```
              #
              # And then asked the model "What's the S&P 500 at today?", the model might produce
              # `tool_use` content blocks in the response like this:
              #
              # ```json
              # [
              #   {
              #     "type": "tool_use",
              #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
              #     "name": "get_stock_price",
              #     "input": { "ticker": "^GSPC" }
              #   }
              # ]
              # ```
              #
              # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
              # input, and return the following back to the model in a subsequent `user`
              # message:
              #
              # ```json
              # [
              #   {
              #     "type": "tool_result",
              #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
              #     "content": "259.75 USD"
              #   }
              # ]
              # ```
              #
              # Tools can be used for workflows that include running client-side tools and
              # functions, or more generally whenever you want the model to produce a particular
              # JSON structure of output.
              #
              # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
              sig do
                returns(T.nilable(
                    T::Array[
                      T.any(
                        Anthropic::Beta::BetaTool,
                        Anthropic::Beta::BetaToolBash20241022,
                        Anthropic::Beta::BetaToolBash20250124,
                        Anthropic::Beta::BetaCodeExecutionTool20250522,
                        Anthropic::Beta::BetaToolComputerUse20241022,
                        Anthropic::Beta::BetaToolComputerUse20250124,
                        Anthropic::Beta::BetaToolTextEditor20241022,
                        Anthropic::Beta::BetaToolTextEditor20250124,
                        Anthropic::Beta::BetaToolTextEditor20250429,
                        Anthropic::Beta::BetaToolTextEditor20250728,
                        Anthropic::Beta::BetaWebSearchTool20250305
                      )
                    ]
                  ))
              end
              attr_reader :tools

              sig do
                params(
                  tools: T::Array[
                      T.any(
                        Anthropic::Beta::BetaTool::OrHash,
                        Anthropic::Beta::BetaToolBash20241022::OrHash,
                        Anthropic::Beta::BetaToolBash20250124::OrHash,
                        Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                        Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                        Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                        Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                        Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                        Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                        Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                        Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                      )
                    ]
                ).void
              end
              attr_writer :tools

              # Only sample from the top K options for each subsequent token.
              #
              # Used to remove "long tail" low probability responses.
              # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
              #
              # Recommended for advanced use cases only. You usually only need to use
              # `temperature`.
              sig { returns(T.nilable(Integer)) }
              attr_reader :top_k

              sig { params(top_k: Integer).void }
              attr_writer :top_k

              # Use nucleus sampling.
              #
              # In nucleus sampling, we compute the cumulative distribution over all the options
              # for each subsequent token in decreasing probability order and cut it off once it
              # reaches a particular probability specified by `top_p`. You should either alter
              # `temperature` or `top_p`, but not both.
              #
              # Recommended for advanced use cases only. You usually only need to use
              # `temperature`.
              sig { returns(T.nilable(Float)) }
              attr_reader :top_p

              sig { params(top_p: Float).void }
              attr_writer :top_p

              sig do
                override
                  .returns({
                    max_tokens: Integer,
                    messages: T::Array[Anthropic::Beta::BetaMessageParam],
                    model: T.any(Anthropic::Model::OrSymbol, String),
                    container: T.nilable(String),
                    mcp_servers:
                      T::Array[
                        Anthropic::Beta::BetaRequestMCPServerURLDefinition
                      ],
                    metadata: Anthropic::Beta::BetaMetadata,
                    service_tier:
                      Anthropic::Beta::Messages::BatchCreateParams::Request::Params::ServiceTier::OrSymbol,
                    stop_sequences: T::Array[String],
                    stream: T::Boolean,
                    system_:
                      Anthropic::Beta::Messages::BatchCreateParams::Request::Params::System::Variants,
                    temperature: Float,
                    thinking:
                      T.any(
                        Anthropic::Beta::BetaThinkingConfigEnabled,
                        Anthropic::Beta::BetaThinkingConfigDisabled
                      ),
                    tool_choice:
                      T.any(
                        Anthropic::Beta::BetaToolChoiceAuto,
                        Anthropic::Beta::BetaToolChoiceAny,
                        Anthropic::Beta::BetaToolChoiceTool,
                        Anthropic::Beta::BetaToolChoiceNone
                      ),
                    tools:
                      T::Array[
                        T.any(
                          Anthropic::Beta::BetaTool,
                          Anthropic::Beta::BetaToolBash20241022,
                          Anthropic::Beta::BetaToolBash20250124,
                          Anthropic::Beta::BetaCodeExecutionTool20250522,
                          Anthropic::Beta::BetaToolComputerUse20241022,
                          Anthropic::Beta::BetaToolComputerUse20250124,
                          Anthropic::Beta::BetaToolTextEditor20241022,
                          Anthropic::Beta::BetaToolTextEditor20250124,
                          Anthropic::Beta::BetaToolTextEditor20250429,
                          Anthropic::Beta::BetaToolTextEditor20250728,
                          Anthropic::Beta::BetaWebSearchTool20250305
                        )
                      ],
                    top_k: Integer,
                    top_p: Float
                  })
              end
              def to_hash; end

              class << self
                # Messages API creation parameters for the individual request.
                #
                # See the [Messages API reference](/en/api/messages) for full documentation on
                # available parameters.
                sig do
                  params(
                    max_tokens: Integer,
                    messages: T::Array[Anthropic::Beta::BetaMessageParam::OrHash],
                    model: T.any(Anthropic::Model::OrSymbol, String),
                    container: T.nilable(String),
                    mcp_servers: T::Array[
                      Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
                    ],
                    metadata: Anthropic::Beta::BetaMetadata::OrHash,
                    service_tier: Anthropic::Beta::Messages::BatchCreateParams::Request::Params::ServiceTier::OrSymbol,
                    stop_sequences: T::Array[String],
                    stream: T::Boolean,
                    system_: Anthropic::Beta::Messages::BatchCreateParams::Request::Params::System::Variants,
                    temperature: Float,
                    thinking: T.any(
                      Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                      Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
                    ),
                    tool_choice: T.any(
                      Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                      Anthropic::Beta::BetaToolChoiceAny::OrHash,
                      Anthropic::Beta::BetaToolChoiceTool::OrHash,
                      Anthropic::Beta::BetaToolChoiceNone::OrHash
                    ),
                    tools: T::Array[
                      T.any(
                        Anthropic::Beta::BetaTool::OrHash,
                        Anthropic::Beta::BetaToolBash20241022::OrHash,
                        Anthropic::Beta::BetaToolBash20250124::OrHash,
                        Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                        Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                        Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                        Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                        Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                        Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                        Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                        Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                      )
                    ],
                    top_k: Integer,
                    top_p: Float
                  ).returns(T.attached_class)
                end
                def new(
                  max_tokens:, # The maximum number of tokens to generate before stopping.
                               # Note that our models may stop _before_ reaching this maximum. This parameter
                               # only specifies the absolute maximum number of tokens to generate.
                               # Different models have different maximum values for this parameter. See
                               # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
                  messages:, # Input messages.
                             # Our models are trained to operate on alternating `user` and `assistant`
                             # conversational turns. When creating a new `Message`, you specify the prior
                             # conversational turns with the `messages` parameter, and the model then generates
                             # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                             # in your request will be combined into a single turn.
                             # Each input message must be an object with a `role` and `content`. You can
                             # specify a single `user`-role message, or you can include multiple `user` and
                             # `assistant` messages.
                             # If the final message uses the `assistant` role, the response content will
                             # continue immediately from the content in that message. This can be used to
                             # constrain part of the model's response.
                             # Example with a single `user` message:
                             # ```json
                             # [{ "role": "user", "content": "Hello, Claude" }]
                             # ```
                             # Example with multiple conversational turns:
                             # ```json
                             # [
                             #   { "role": "user", "content": "Hello there." },
                             #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                             #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                             # ]
                             # ```
                             # Example with a partially-filled response from Claude:
                             # ```json
                             # [
                             #   {
                             #     "role": "user",
                             #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                             #   },
                             #   { "role": "assistant", "content": "The best answer is (" }
                             # ]
                             # ```
                             # Each input message `content` may be either a single `string` or an array of
                             # content blocks, where each block has a specific `type`. Using a `string` for
                             # `content` is shorthand for an array of one content block of type `"text"`. The
                             # following input messages are equivalent:
                             # ```json
                             # { "role": "user", "content": "Hello, Claude" }
                             # ```
                             # ```json
                             # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                             # ```
                             # Starting with Claude 3 models, you can also send image content blocks:
                             # ```json
                             # {
                             #   "role": "user",
                             #   "content": [
                             #     {
                             #       "type": "image",
                             #       "source": {
                             #         "type": "base64",
                             #         "media_type": "image/jpeg",
                             #         "data": "/9j/4AAQSkZJRg..."
                             #       }
                             #     },
                             #     { "type": "text", "text": "What is in this image?" }
                             #   ]
                             # }
                             # ```
                             # We currently support the `base64` source type for images, and the `image/jpeg`,
                             # `image/png`, `image/gif`, and `image/webp` media types.
                             # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                             # more input examples.
                             # Note that if you want to include a
                             # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                             # the top-level `system` parameter  there is no `"system"` role for input
                             # messages in the Messages API.
                             # There is a limit of 100,000 messages in a single request.
                  model:, # The model that will complete your prompt.\n\nSee
                          # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                          # details and options.
                  container: nil, # Container identifier for reuse across requests.
                  mcp_servers: nil, # MCP servers to be utilized in this request
                  metadata: nil, # An object describing metadata about the request.
                  service_tier: nil, # Determines whether to use priority capacity (if available) or standard capacity
                                     # for this request.
                                     # Anthropic offers different levels of service for your API requests. See
                                     # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
                  stop_sequences: nil, # Custom text sequences that will cause the model to stop generating.
                                       # Our models will normally stop when they have naturally completed their turn,
                                       # which will result in a response `stop_reason` of `"end_turn"`.
                                       # If you want the model to stop generating when it encounters custom strings of
                                       # text, you can use the `stop_sequences` parameter. If the model encounters one of
                                       # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                                       # and the response `stop_sequence` value will contain the matched stop sequence.
                  stream: nil, # Whether to incrementally stream the response using server-sent events.
                               # See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
                               # details.
                  system_: nil, # System prompt.
                                # A system prompt is a way of providing context and instructions to Claude, such
                                # as specifying a particular goal or role. See our
                                # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
                  temperature: nil, # Amount of randomness injected into the response.
                                    # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                                    # for analytical / multiple choice, and closer to `1.0` for creative and
                                    # generative tasks.
                                    # Note that even with `temperature` of `0.0`, the results will not be fully
                                    # deterministic.
                  thinking: nil, # Configuration for enabling Claude's extended thinking.
                                 # When enabled, responses include `thinking` content blocks showing Claude's
                                 # thinking process before the final answer. Requires a minimum budget of 1,024
                                 # tokens and counts towards your `max_tokens` limit.
                                 # See
                                 # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                                 # for details.
                  tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                                    # any available tool, decide by itself, or not use tools at all.
                  tools: nil, # Definitions of tools that the model may use.
                              # If you include `tools` in your API request, the model may return `tool_use`
                              # content blocks that represent the model's use of those tools. You can then run
                              # those tools using the tool input generated by the model and then optionally
                              # return results back to the model using `tool_result` content blocks.
                              # There are two types of tools: **client tools** and **server tools**. The
                              # behavior described below applies to client tools. For
                              # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                              # see their individual documentation as each has its own behavior (e.g., the
                              # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                              # Each tool definition includes:
                              # - `name`: Name of the tool.
                              # - `description`: Optional, but strongly-recommended description of the tool.
                              # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                              #   tool `input` shape that the model will produce in `tool_use` output content
                              #   blocks.
                              # For example, if you defined `tools` as:
                              # ```json
                              # [
                              #   {
                              #     "name": "get_stock_price",
                              #     "description": "Get the current stock price for a given ticker symbol.",
                              #     "input_schema": {
                              #       "type": "object",
                              #       "properties": {
                              #         "ticker": {
                              #           "type": "string",
                              #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                              #         }
                              #       },
                              #       "required": ["ticker"]
                              #     }
                              #   }
                              # ]
                              # ```
                              # And then asked the model "What's the S&P 500 at today?", the model might produce
                              # `tool_use` content blocks in the response like this:
                              # ```json
                              # [
                              #   {
                              #     "type": "tool_use",
                              #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                              #     "name": "get_stock_price",
                              #     "input": { "ticker": "^GSPC" }
                              #   }
                              # ]
                              # ```
                              # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                              # input, and return the following back to the model in a subsequent `user`
                              # message:
                              # ```json
                              # [
                              #   {
                              #     "type": "tool_result",
                              #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                              #     "content": "259.75 USD"
                              #   }
                              # ]
                              # ```
                              # Tools can be used for workflows that include running client-side tools and
                              # functions, or more generally whenever you want the model to produce a particular
                              # JSON structure of output.
                              # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
                  top_k: nil, # Only sample from the top K options for each subsequent token.
                              # Used to remove "long tail" low probability responses.
                              # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                              # Recommended for advanced use cases only. You usually only need to use
                              # `temperature`.
                  top_p: nil # Use nucleus sampling.
                             # In nucleus sampling, we compute the cumulative distribution over all the options
                             # for each subsequent token in decreasing probability order and cut it off once it
                             # reaches a particular probability specified by `top_p`. You should either alter
                             # `temperature` or `top_p`, but not both.
                             # Recommended for advanced use cases only. You usually only need to use
                             # `temperature`.
); end
              end

              OrHash = T.type_alias do
                  T.any(
                    Anthropic::Beta::Messages::BatchCreateParams::Request::Params,
                    Anthropic::Internal::AnyHash
                  )
                end

              # Determines whether to use priority capacity (if available) or standard capacity
              # for this request.
              #
              # Anthropic offers different levels of service for your API requests. See
              # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
              module ServiceTier
                extend Anthropic::Internal::Type::Enum

                class << self
                  sig do
                    override
                      .returns(T::Array[
                      Anthropic::Beta::Messages::BatchCreateParams::Request::Params::ServiceTier::TaggedSymbol
                    ])
                  end
                  def values; end
                end

                AUTO = T.let(
                    :auto,
                    Anthropic::Beta::Messages::BatchCreateParams::Request::Params::ServiceTier::TaggedSymbol
                  )

                OrSymbol = T.type_alias { T.any(Symbol, String) }

                STANDARD_ONLY = T.let(
                    :standard_only,
                    Anthropic::Beta::Messages::BatchCreateParams::Request::Params::ServiceTier::TaggedSymbol
                  )

                TaggedSymbol = T.type_alias do
                    T.all(
                      Symbol,
                      Anthropic::Beta::Messages::BatchCreateParams::Request::Params::ServiceTier
                    )
                  end
              end

              # System prompt.
              #
              # A system prompt is a way of providing context and instructions to Claude, such
              # as specifying a particular goal or role. See our
              # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
              module System
                extend Anthropic::Internal::Type::Union

                class << self
                  sig do
                    override
                      .returns(T::Array[
                      Anthropic::Beta::Messages::BatchCreateParams::Request::Params::System::Variants
                    ])
                  end
                  def variants; end
                end

                BetaTextBlockParamArray = T.let(
                    Anthropic::Internal::Type::ArrayOf[
                      Anthropic::Beta::BetaTextBlockParam
                    ],
                    Anthropic::Internal::Type::Converter
                  )

                Variants = T.type_alias do
                    T.any(String, T::Array[Anthropic::Beta::BetaTextBlockParam])
                  end
              end
            end
          end
        end

        class BatchDeleteParams < Anthropic::Internal::Type::BaseModel
          extend Anthropic::Internal::Type::RequestParameters::Converter
          include Anthropic::Internal::Type::RequestParameters

          # Optional header to specify the beta version(s) you want to use.
          sig do
            returns(T.nilable(
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
              ))
          end
          attr_reader :betas

          sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
          attr_writer :betas

          sig do
            override
              .returns({
                betas:
                  T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions::OrHash
              ).returns(T.attached_class)
            end
            def new(
              betas: nil, # Optional header to specify the beta version(s) you want to use.
              request_options: {}
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BatchDeleteParams,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BatchListParams < Anthropic::Internal::Type::BaseModel
          extend Anthropic::Internal::Type::RequestParameters::Converter
          include Anthropic::Internal::Type::RequestParameters

          # ID of the object to use as a cursor for pagination. When provided, returns the
          # page of results immediately after this object.
          sig { returns(T.nilable(String)) }
          attr_reader :after_id

          sig { params(after_id: String).void }
          attr_writer :after_id

          # ID of the object to use as a cursor for pagination. When provided, returns the
          # page of results immediately before this object.
          sig { returns(T.nilable(String)) }
          attr_reader :before_id

          sig { params(before_id: String).void }
          attr_writer :before_id

          # Optional header to specify the beta version(s) you want to use.
          sig do
            returns(T.nilable(
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
              ))
          end
          attr_reader :betas

          sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
          attr_writer :betas

          # Number of items to return per page.
          #
          # Defaults to `20`. Ranges from `1` to `1000`.
          sig { returns(T.nilable(Integer)) }
          attr_reader :limit

          sig { params(limit: Integer).void }
          attr_writer :limit

          sig do
            override
              .returns({
                after_id: String,
                before_id: String,
                limit: Integer,
                betas:
                  T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                after_id: String,
                before_id: String,
                limit: Integer,
                betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions::OrHash
              ).returns(T.attached_class)
            end
            def new(
              after_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                             # page of results immediately after this object.
              before_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                              # page of results immediately before this object.
              limit: nil, # Number of items to return per page.
                          # Defaults to `20`. Ranges from `1` to `1000`.
              betas: nil, # Optional header to specify the beta version(s) you want to use.
              request_options: {}
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BatchListParams,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BatchResultsParams < Anthropic::Internal::Type::BaseModel
          extend Anthropic::Internal::Type::RequestParameters::Converter
          include Anthropic::Internal::Type::RequestParameters

          # Optional header to specify the beta version(s) you want to use.
          sig do
            returns(T.nilable(
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
              ))
          end
          attr_reader :betas

          sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
          attr_writer :betas

          sig do
            override
              .returns({
                betas:
                  T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions::OrHash
              ).returns(T.attached_class)
            end
            def new(
              betas: nil, # Optional header to specify the beta version(s) you want to use.
              request_options: {}
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BatchResultsParams,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BatchRetrieveParams < Anthropic::Internal::Type::BaseModel
          extend Anthropic::Internal::Type::RequestParameters::Converter
          include Anthropic::Internal::Type::RequestParameters

          # Optional header to specify the beta version(s) you want to use.
          sig do
            returns(T.nilable(
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
              ))
          end
          attr_reader :betas

          sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
          attr_writer :betas

          sig do
            override
              .returns({
                betas:
                  T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
                request_options: Anthropic::RequestOptions::OrHash
              ).returns(T.attached_class)
            end
            def new(
              betas: nil, # Optional header to specify the beta version(s) you want to use.
              request_options: {}
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BatchRetrieveParams,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BetaDeletedMessageBatch < Anthropic::Internal::Type::BaseModel
          # ID of the Message Batch.
          sig { returns(String) }
          attr_accessor :id

          # Deleted object type.
          #
          # For Message Batches, this is always `"message_batch_deleted"`.
          sig { returns(Symbol) }
          attr_accessor :type

          sig { override.returns({ id: String, type: Symbol }) }
          def to_hash; end

          class << self
            sig { params(id: String, type: Symbol).returns(T.attached_class) }
            def new(
              id:, # ID of the Message Batch.
              type: :message_batch_deleted # Deleted object type.
                                           # For Message Batches, this is always `"message_batch_deleted"`.
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaDeletedMessageBatch,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BetaMessageBatch < Anthropic::Internal::Type::BaseModel
          # RFC 3339 datetime string representing the time at which the Message Batch was
          # archived and its results became unavailable.
          sig { returns(T.nilable(Time)) }
          attr_accessor :archived_at

          # RFC 3339 datetime string representing the time at which cancellation was
          # initiated for the Message Batch. Specified only if cancellation was initiated.
          sig { returns(T.nilable(Time)) }
          attr_accessor :cancel_initiated_at

          # RFC 3339 datetime string representing the time at which the Message Batch was
          # created.
          sig { returns(Time) }
          attr_accessor :created_at

          # RFC 3339 datetime string representing the time at which processing for the
          # Message Batch ended. Specified only once processing ends.
          #
          # Processing ends when every request in a Message Batch has either succeeded,
          # errored, canceled, or expired.
          sig { returns(T.nilable(Time)) }
          attr_accessor :ended_at

          # RFC 3339 datetime string representing the time at which the Message Batch will
          # expire and end processing, which is 24 hours after creation.
          sig { returns(Time) }
          attr_accessor :expires_at

          # Unique object identifier.
          #
          # The format and length of IDs may change over time.
          sig { returns(String) }
          attr_accessor :id

          # Processing status of the Message Batch.
          sig { returns(Anthropic::Beta::Messages::BetaMessageBatch::ProcessingStatus::TaggedSymbol) }
          attr_accessor :processing_status

          # Tallies requests within the Message Batch, categorized by their status.
          #
          # Requests start as `processing` and move to one of the other statuses only once
          # processing of the entire batch ends. The sum of all values always matches the
          # total number of requests in the batch.
          sig { returns(Anthropic::Beta::Messages::BetaMessageBatchRequestCounts) }
          attr_reader :request_counts

          sig { params(request_counts: Anthropic::Beta::Messages::BetaMessageBatchRequestCounts::OrHash).void }
          attr_writer :request_counts

          # URL to a `.jsonl` file containing the results of the Message Batch requests.
          # Specified only once processing ends.
          #
          # Results in the file are not guaranteed to be in the same order as requests. Use
          # the `custom_id` field to match results to requests.
          sig { returns(T.nilable(String)) }
          attr_accessor :results_url

          # Object type.
          #
          # For Message Batches, this is always `"message_batch"`.
          sig { returns(Symbol) }
          attr_accessor :type

          sig do
            override
              .returns({
                id: String,
                archived_at: T.nilable(Time),
                cancel_initiated_at: T.nilable(Time),
                created_at: Time,
                ended_at: T.nilable(Time),
                expires_at: Time,
                processing_status:
                  Anthropic::Beta::Messages::BetaMessageBatch::ProcessingStatus::TaggedSymbol,
                request_counts:
                  Anthropic::Beta::Messages::BetaMessageBatchRequestCounts,
                results_url: T.nilable(String),
                type: Symbol
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                id: String,
                archived_at: T.nilable(Time),
                cancel_initiated_at: T.nilable(Time),
                created_at: Time,
                ended_at: T.nilable(Time),
                expires_at: Time,
                processing_status: Anthropic::Beta::Messages::BetaMessageBatch::ProcessingStatus::OrSymbol,
                request_counts: Anthropic::Beta::Messages::BetaMessageBatchRequestCounts::OrHash,
                results_url: T.nilable(String),
                type: Symbol
              ).returns(T.attached_class)
            end
            def new(
              id:, # Unique object identifier.
                   # The format and length of IDs may change over time.
              archived_at:, # RFC 3339 datetime string representing the time at which the Message Batch was
                            # archived and its results became unavailable.
              cancel_initiated_at:, # RFC 3339 datetime string representing the time at which cancellation was
                                    # initiated for the Message Batch. Specified only if cancellation was initiated.
              created_at:, # RFC 3339 datetime string representing the time at which the Message Batch was
                           # created.
              ended_at:, # RFC 3339 datetime string representing the time at which processing for the
                         # Message Batch ended. Specified only once processing ends.
                         # Processing ends when every request in a Message Batch has either succeeded,
                         # errored, canceled, or expired.
              expires_at:, # RFC 3339 datetime string representing the time at which the Message Batch will
                           # expire and end processing, which is 24 hours after creation.
              processing_status:, # Processing status of the Message Batch.
              request_counts:, # Tallies requests within the Message Batch, categorized by their status.
                               # Requests start as `processing` and move to one of the other statuses only once
                               # processing of the entire batch ends. The sum of all values always matches the
                               # total number of requests in the batch.
              results_url:, # URL to a `.jsonl` file containing the results of the Message Batch requests.
                            # Specified only once processing ends.
                            # Results in the file are not guaranteed to be in the same order as requests. Use
                            # the `custom_id` field to match results to requests.
              type: :message_batch # Object type.
                                   # For Message Batches, this is always `"message_batch"`.
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaMessageBatch,
                Anthropic::Internal::AnyHash
              )
            end

          # Processing status of the Message Batch.
          module ProcessingStatus
            extend Anthropic::Internal::Type::Enum

            class << self
              sig do
                override
                  .returns(T::Array[
                  Anthropic::Beta::Messages::BetaMessageBatch::ProcessingStatus::TaggedSymbol
                ])
              end
              def values; end
            end

            CANCELING = T.let(
                :canceling,
                Anthropic::Beta::Messages::BetaMessageBatch::ProcessingStatus::TaggedSymbol
              )

            ENDED = T.let(
                :ended,
                Anthropic::Beta::Messages::BetaMessageBatch::ProcessingStatus::TaggedSymbol
              )

            IN_PROGRESS = T.let(
                :in_progress,
                Anthropic::Beta::Messages::BetaMessageBatch::ProcessingStatus::TaggedSymbol
              )

            OrSymbol = T.type_alias { T.any(Symbol, String) }

            TaggedSymbol = T.type_alias do
                T.all(
                  Symbol,
                  Anthropic::Beta::Messages::BetaMessageBatch::ProcessingStatus
                )
              end
          end
        end

        class BetaMessageBatchCanceledResult < Anthropic::Internal::Type::BaseModel
          sig { returns(Symbol) }
          attr_accessor :type

          sig { override.returns({ type: Symbol }) }
          def to_hash; end

          class << self
            sig { params(type: Symbol).returns(T.attached_class) }
            def new(type: :canceled); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaMessageBatchCanceledResult,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BetaMessageBatchErroredResult < Anthropic::Internal::Type::BaseModel
          sig { returns(Anthropic::BetaErrorResponse) }
          attr_reader :error

          sig { params(error: Anthropic::BetaErrorResponse::OrHash).void }
          attr_writer :error

          sig { returns(Symbol) }
          attr_accessor :type

          sig { override.returns({ error: Anthropic::BetaErrorResponse, type: Symbol }) }
          def to_hash; end

          class << self
            sig { params(error: Anthropic::BetaErrorResponse::OrHash, type: Symbol).returns(T.attached_class) }
            def new(error:, type: :errored); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaMessageBatchErroredResult,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BetaMessageBatchExpiredResult < Anthropic::Internal::Type::BaseModel
          sig { returns(Symbol) }
          attr_accessor :type

          sig { override.returns({ type: Symbol }) }
          def to_hash; end

          class << self
            sig { params(type: Symbol).returns(T.attached_class) }
            def new(type: :expired); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaMessageBatchExpiredResult,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BetaMessageBatchIndividualResponse < Anthropic::Internal::Type::BaseModel
          # Developer-provided ID created for each request in a Message Batch. Useful for
          # matching results to requests, as results may be given out of request order.
          #
          # Must be unique for each request within the Message Batch.
          sig { returns(String) }
          attr_accessor :custom_id

          # Processing result for this request.
          #
          # Contains a Message output if processing was successful, an error response if
          # processing failed, or the reason why processing was not attempted, such as
          # cancellation or expiration.
          sig { returns(Anthropic::Beta::Messages::BetaMessageBatchResult::Variants) }
          attr_accessor :result

          sig do
            override
              .returns({
                custom_id: String,
                result:
                  Anthropic::Beta::Messages::BetaMessageBatchResult::Variants
              })
          end
          def to_hash; end

          class << self
            # This is a single line in the response `.jsonl` file and does not represent the
            # response as a whole.
            sig do
              params(
                custom_id: String,
                result: T.any(
                  Anthropic::Beta::Messages::BetaMessageBatchSucceededResult::OrHash,
                  Anthropic::Beta::Messages::BetaMessageBatchErroredResult::OrHash,
                  Anthropic::Beta::Messages::BetaMessageBatchCanceledResult::OrHash,
                  Anthropic::Beta::Messages::BetaMessageBatchExpiredResult::OrHash
                )
              ).returns(T.attached_class)
            end
            def new(
              custom_id:, # Developer-provided ID created for each request in a Message Batch. Useful for
                          # matching results to requests, as results may be given out of request order.
                          # Must be unique for each request within the Message Batch.
              result: # Processing result for this request.
                      # Contains a Message output if processing was successful, an error response if
                      # processing failed, or the reason why processing was not attempted, such as
                      # cancellation or expiration.
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaMessageBatchIndividualResponse,
                Anthropic::Internal::AnyHash
              )
            end
        end

        class BetaMessageBatchRequestCounts < Anthropic::Internal::Type::BaseModel
          # Number of requests in the Message Batch that have been canceled.
          #
          # This is zero until processing of the entire Message Batch has ended.
          sig { returns(Integer) }
          attr_accessor :canceled

          # Number of requests in the Message Batch that encountered an error.
          #
          # This is zero until processing of the entire Message Batch has ended.
          sig { returns(Integer) }
          attr_accessor :errored

          # Number of requests in the Message Batch that have expired.
          #
          # This is zero until processing of the entire Message Batch has ended.
          sig { returns(Integer) }
          attr_accessor :expired

          # Number of requests in the Message Batch that are processing.
          sig { returns(Integer) }
          attr_accessor :processing

          # Number of requests in the Message Batch that have completed successfully.
          #
          # This is zero until processing of the entire Message Batch has ended.
          sig { returns(Integer) }
          attr_accessor :succeeded

          sig do
            override
              .returns({
                canceled: Integer,
                errored: Integer,
                expired: Integer,
                processing: Integer,
                succeeded: Integer
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                canceled: Integer,
                errored: Integer,
                expired: Integer,
                processing: Integer,
                succeeded: Integer
              ).returns(T.attached_class)
            end
            def new(
              canceled:, # Number of requests in the Message Batch that have been canceled.
                         # This is zero until processing of the entire Message Batch has ended.
              errored:, # Number of requests in the Message Batch that encountered an error.
                        # This is zero until processing of the entire Message Batch has ended.
              expired:, # Number of requests in the Message Batch that have expired.
                        # This is zero until processing of the entire Message Batch has ended.
              processing:, # Number of requests in the Message Batch that are processing.
              succeeded: # Number of requests in the Message Batch that have completed successfully.
                         # This is zero until processing of the entire Message Batch has ended.
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaMessageBatchRequestCounts,
                Anthropic::Internal::AnyHash
              )
            end
        end

        # Processing result for this request.
        #
        # Contains a Message output if processing was successful, an error response if
        # processing failed, or the reason why processing was not attempted, such as
        # cancellation or expiration.
        module BetaMessageBatchResult
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Beta::Messages::BetaMessageBatchResult::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaMessageBatchSucceededResult,
                Anthropic::Beta::Messages::BetaMessageBatchErroredResult,
                Anthropic::Beta::Messages::BetaMessageBatchCanceledResult,
                Anthropic::Beta::Messages::BetaMessageBatchExpiredResult
              )
            end
        end

        class BetaMessageBatchSucceededResult < Anthropic::Internal::Type::BaseModel
          sig { returns(Anthropic::Beta::BetaMessage) }
          attr_reader :message

          sig { params(message: Anthropic::Beta::BetaMessage::OrHash).void }
          attr_writer :message

          sig { returns(Symbol) }
          attr_accessor :type

          sig { override.returns({ message: Anthropic::Beta::BetaMessage, type: Symbol }) }
          def to_hash; end

          class << self
            sig { params(message: Anthropic::Beta::BetaMessage::OrHash, type: Symbol).returns(T.attached_class) }
            def new(message:, type: :succeeded); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Beta::Messages::BetaMessageBatchSucceededResult,
                Anthropic::Internal::AnyHash
              )
            end
        end
      end

      class ModelListParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # ID of the object to use as a cursor for pagination. When provided, returns the
        # page of results immediately after this object.
        sig { returns(T.nilable(String)) }
        attr_reader :after_id

        sig { params(after_id: String).void }
        attr_writer :after_id

        # ID of the object to use as a cursor for pagination. When provided, returns the
        # page of results immediately before this object.
        sig { returns(T.nilable(String)) }
        attr_reader :before_id

        sig { params(before_id: String).void }
        attr_writer :before_id

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        # Number of items to return per page.
        #
        # Defaults to `20`. Ranges from `1` to `1000`.
        sig { returns(T.nilable(Integer)) }
        attr_reader :limit

        sig { params(limit: Integer).void }
        attr_writer :limit

        sig do
          override
            .returns({
              after_id: String,
              before_id: String,
              limit: Integer,
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              after_id: String,
              before_id: String,
              limit: Integer,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            after_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                           # page of results immediately after this object.
            before_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                            # page of results immediately before this object.
            limit: nil, # Number of items to return per page.
                        # Defaults to `20`. Ranges from `1` to `1000`.
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::ModelListParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class ModelRetrieveParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # Optional header to specify the beta version(s) you want to use.
        sig do
          returns(T.nilable(
              T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]
            ))
        end
        attr_reader :betas

        sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
        attr_writer :betas

        sig do
          override
            .returns({
              betas:
                T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Beta::ModelRetrieveParams,
              Anthropic::Internal::AnyHash
            )
          end
      end
    end

    class BetaAPIError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :api_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::BetaAPIError, Anthropic::Internal::AnyHash)
        end
    end

    class BetaAuthenticationError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :authentication_error); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::BetaAuthenticationError,
            Anthropic::Internal::AnyHash
          )
        end
    end

    BetaBase64ImageSource = Beta::BetaBase64ImageSource
    BetaBase64PDFBlock = Beta::BetaBase64PDFBlock
    BetaBase64PDFSource = Beta::BetaBase64PDFSource

    class BetaBillingError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :billing_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::BetaBillingError, Anthropic::Internal::AnyHash)
        end
    end

    BetaCacheControlEphemeral = Beta::BetaCacheControlEphemeral
    BetaCacheCreation = Beta::BetaCacheCreation
    BetaCitationCharLocation = Beta::BetaCitationCharLocation
    BetaCitationCharLocationParam = Beta::BetaCitationCharLocationParam
    BetaCitationContentBlockLocation = Beta::BetaCitationContentBlockLocation

    BetaCitationContentBlockLocationParam = Beta::BetaCitationContentBlockLocationParam

    BetaCitationPageLocation = Beta::BetaCitationPageLocation
    BetaCitationPageLocationParam = Beta::BetaCitationPageLocationParam
    BetaCitationSearchResultLocation = Beta::BetaCitationSearchResultLocation

    BetaCitationSearchResultLocationParam = Beta::BetaCitationSearchResultLocationParam

    BetaCitationWebSearchResultLocationParam = Beta::BetaCitationWebSearchResultLocationParam

    BetaCitationsConfigParam = Beta::BetaCitationsConfigParam
    BetaCitationsDelta = Beta::BetaCitationsDelta

    BetaCitationsWebSearchResultLocation = Beta::BetaCitationsWebSearchResultLocation

    BetaCodeExecutionOutputBlock = Beta::BetaCodeExecutionOutputBlock
    BetaCodeExecutionOutputBlockParam = Beta::BetaCodeExecutionOutputBlockParam
    BetaCodeExecutionResultBlock = Beta::BetaCodeExecutionResultBlock
    BetaCodeExecutionResultBlockParam = Beta::BetaCodeExecutionResultBlockParam
    BetaCodeExecutionTool20250522 = Beta::BetaCodeExecutionTool20250522
    BetaCodeExecutionToolResultBlock = Beta::BetaCodeExecutionToolResultBlock

    BetaCodeExecutionToolResultBlockContent = Beta::BetaCodeExecutionToolResultBlockContent

    BetaCodeExecutionToolResultBlockParam = Beta::BetaCodeExecutionToolResultBlockParam

    BetaCodeExecutionToolResultBlockParamContent = Beta::BetaCodeExecutionToolResultBlockParamContent

    BetaCodeExecutionToolResultError = Beta::BetaCodeExecutionToolResultError

    BetaCodeExecutionToolResultErrorCode = Beta::BetaCodeExecutionToolResultErrorCode

    BetaCodeExecutionToolResultErrorParam = Beta::BetaCodeExecutionToolResultErrorParam

    BetaContainer = Beta::BetaContainer
    BetaContainerUploadBlock = Beta::BetaContainerUploadBlock
    BetaContainerUploadBlockParam = Beta::BetaContainerUploadBlockParam
    BetaContentBlock = Beta::BetaContentBlock
    BetaContentBlockParam = Beta::BetaContentBlockParam
    BetaContentBlockSource = Beta::BetaContentBlockSource
    BetaContentBlockSourceContent = Beta::BetaContentBlockSourceContent

    module BetaError
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::BetaError::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::BetaInvalidRequestError,
            Anthropic::BetaAuthenticationError,
            Anthropic::BetaBillingError,
            Anthropic::BetaPermissionError,
            Anthropic::BetaNotFoundError,
            Anthropic::BetaRateLimitError,
            Anthropic::BetaGatewayTimeoutError,
            Anthropic::BetaAPIError,
            Anthropic::BetaOverloadedError
          )
        end
    end

    class BetaErrorResponse < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::BetaError::Variants) }
      attr_accessor :error

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ error: Anthropic::BetaError::Variants, type: Symbol }) }
      def to_hash; end

      class << self
        sig do
          params(
            error: T.any(
              Anthropic::BetaInvalidRequestError::OrHash,
              Anthropic::BetaAuthenticationError::OrHash,
              Anthropic::BetaBillingError::OrHash,
              Anthropic::BetaPermissionError::OrHash,
              Anthropic::BetaNotFoundError::OrHash,
              Anthropic::BetaRateLimitError::OrHash,
              Anthropic::BetaGatewayTimeoutError::OrHash,
              Anthropic::BetaAPIError::OrHash,
              Anthropic::BetaOverloadedError::OrHash
            ),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(error:, type: :error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::BetaErrorResponse, Anthropic::Internal::AnyHash)
        end
    end

    BetaFileDocumentSource = Beta::BetaFileDocumentSource
    BetaFileImageSource = Beta::BetaFileImageSource

    class BetaGatewayTimeoutError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :timeout_error); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::BetaGatewayTimeoutError,
            Anthropic::Internal::AnyHash
          )
        end
    end

    BetaImageBlockParam = Beta::BetaImageBlockParam
    BetaInputJSONDelta = Beta::BetaInputJSONDelta

    class BetaInvalidRequestError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :invalid_request_error); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::BetaInvalidRequestError,
            Anthropic::Internal::AnyHash
          )
        end
    end

    BetaMCPToolResultBlock = Beta::BetaMCPToolResultBlock
    BetaMCPToolUseBlock = Beta::BetaMCPToolUseBlock
    BetaMCPToolUseBlockParam = Beta::BetaMCPToolUseBlockParam
    BetaMessage = Beta::BetaMessage
    BetaMessageDeltaUsage = Beta::BetaMessageDeltaUsage
    BetaMessageParam = Beta::BetaMessageParam
    BetaMessageTokensCount = Beta::BetaMessageTokensCount
    BetaMetadata = Beta::BetaMetadata
    BetaModelInfo = Beta::BetaModelInfo

    class BetaNotFoundError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :not_found_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::BetaNotFoundError, Anthropic::Internal::AnyHash)
        end
    end

    class BetaOverloadedError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :overloaded_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::BetaOverloadedError, Anthropic::Internal::AnyHash)
        end
    end

    class BetaPermissionError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :permission_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::BetaPermissionError, Anthropic::Internal::AnyHash)
        end
    end

    BetaPlainTextSource = Beta::BetaPlainTextSource

    class BetaRateLimitError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :rate_limit_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::BetaRateLimitError, Anthropic::Internal::AnyHash)
        end
    end

    BetaRawContentBlockDelta = Beta::BetaRawContentBlockDelta
    BetaRawContentBlockDeltaEvent = Beta::BetaRawContentBlockDeltaEvent
    BetaRawContentBlockStartEvent = Beta::BetaRawContentBlockStartEvent
    BetaRawContentBlockStopEvent = Beta::BetaRawContentBlockStopEvent
    BetaRawMessageDeltaEvent = Beta::BetaRawMessageDeltaEvent
    BetaRawMessageStartEvent = Beta::BetaRawMessageStartEvent
    BetaRawMessageStopEvent = Beta::BetaRawMessageStopEvent
    BetaRawMessageStreamEvent = Beta::BetaRawMessageStreamEvent
    BetaRedactedThinkingBlock = Beta::BetaRedactedThinkingBlock
    BetaRedactedThinkingBlockParam = Beta::BetaRedactedThinkingBlockParam
    BetaRequestDocumentBlock = Beta::BetaRequestDocumentBlock

    BetaRequestMCPServerToolConfiguration = Beta::BetaRequestMCPServerToolConfiguration

    BetaRequestMCPServerURLDefinition = Beta::BetaRequestMCPServerURLDefinition

    BetaRequestMCPToolResultBlockParam = Beta::BetaRequestMCPToolResultBlockParam

    BetaSearchResultBlockParam = Beta::BetaSearchResultBlockParam
    BetaServerToolUsage = Beta::BetaServerToolUsage
    BetaServerToolUseBlock = Beta::BetaServerToolUseBlock
    BetaServerToolUseBlockParam = Beta::BetaServerToolUseBlockParam
    BetaSignatureDelta = Beta::BetaSignatureDelta
    BetaStopReason = Beta::BetaStopReason
    BetaTextBlock = Beta::BetaTextBlock
    BetaTextBlockParam = Beta::BetaTextBlockParam
    BetaTextCitation = Beta::BetaTextCitation
    BetaTextCitationParam = Beta::BetaTextCitationParam
    BetaTextDelta = Beta::BetaTextDelta
    BetaThinkingBlock = Beta::BetaThinkingBlock
    BetaThinkingBlockParam = Beta::BetaThinkingBlockParam
    BetaThinkingConfigDisabled = Beta::BetaThinkingConfigDisabled
    BetaThinkingConfigEnabled = Beta::BetaThinkingConfigEnabled
    BetaThinkingConfigParam = Beta::BetaThinkingConfigParam
    BetaThinkingDelta = Beta::BetaThinkingDelta
    BetaTool = Beta::BetaTool
    BetaToolBash20241022 = Beta::BetaToolBash20241022
    BetaToolBash20250124 = Beta::BetaToolBash20250124
    BetaToolChoice = Beta::BetaToolChoice
    BetaToolChoiceAny = Beta::BetaToolChoiceAny
    BetaToolChoiceAuto = Beta::BetaToolChoiceAuto
    BetaToolChoiceNone = Beta::BetaToolChoiceNone
    BetaToolChoiceTool = Beta::BetaToolChoiceTool
    BetaToolComputerUse20241022 = Beta::BetaToolComputerUse20241022
    BetaToolComputerUse20250124 = Beta::BetaToolComputerUse20250124
    BetaToolResultBlockParam = Beta::BetaToolResultBlockParam
    BetaToolTextEditor20241022 = Beta::BetaToolTextEditor20241022
    BetaToolTextEditor20250124 = Beta::BetaToolTextEditor20250124
    BetaToolTextEditor20250429 = Beta::BetaToolTextEditor20250429
    BetaToolTextEditor20250728 = Beta::BetaToolTextEditor20250728
    BetaToolUnion = Beta::BetaToolUnion
    BetaToolUseBlock = Beta::BetaToolUseBlock
    BetaToolUseBlockParam = Beta::BetaToolUseBlockParam
    BetaURLImageSource = Beta::BetaURLImageSource
    BetaURLPDFSource = Beta::BetaURLPDFSource
    BetaUsage = Beta::BetaUsage
    BetaWebSearchResultBlock = Beta::BetaWebSearchResultBlock
    BetaWebSearchResultBlockParam = Beta::BetaWebSearchResultBlockParam
    BetaWebSearchTool20250305 = Beta::BetaWebSearchTool20250305
    BetaWebSearchToolRequestError = Beta::BetaWebSearchToolRequestError
    BetaWebSearchToolResultBlock = Beta::BetaWebSearchToolResultBlock

    BetaWebSearchToolResultBlockContent = Beta::BetaWebSearchToolResultBlockContent

    BetaWebSearchToolResultBlockParam = Beta::BetaWebSearchToolResultBlockParam

    BetaWebSearchToolResultBlockParamContent = Beta::BetaWebSearchToolResultBlockParamContent

    BetaWebSearchToolResultError = Beta::BetaWebSearchToolResultError
    BetaWebSearchToolResultErrorCode = Beta::BetaWebSearchToolResultErrorCode

    class BillingError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :billing_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::BillingError, Anthropic::Internal::AnyHash)
        end
    end

    class CacheControlEphemeral < Anthropic::Internal::Type::BaseModel
      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(type: Symbol).returns(T.attached_class) }
        def new(type: :ephemeral); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::CacheControlEphemeral, Anthropic::Internal::AnyHash)
        end
    end

    class CitationCharLocation < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(Integer) }
      attr_accessor :document_index

      sig { returns(T.nilable(String)) }
      attr_accessor :document_title

      sig { returns(Integer) }
      attr_accessor :end_char_index

      sig { returns(T.nilable(String)) }
      attr_accessor :file_id

      sig { returns(Integer) }
      attr_accessor :start_char_index

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_char_index: Integer,
            file_id: T.nilable(String),
            start_char_index: Integer,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_char_index: Integer,
            file_id: T.nilable(String),
            start_char_index: Integer,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, document_index:, document_title:, end_char_index:, file_id:, start_char_index:, type: :char_location); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::CitationCharLocation, Anthropic::Internal::AnyHash)
        end
    end

    class CitationCharLocationParam < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(Integer) }
      attr_accessor :document_index

      sig { returns(T.nilable(String)) }
      attr_accessor :document_title

      sig { returns(Integer) }
      attr_accessor :end_char_index

      sig { returns(Integer) }
      attr_accessor :start_char_index

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_char_index: Integer,
            start_char_index: Integer,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_char_index: Integer,
            start_char_index: Integer,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, document_index:, document_title:, end_char_index:, start_char_index:, type: :char_location); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::CitationCharLocationParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class CitationContentBlockLocation < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(Integer) }
      attr_accessor :document_index

      sig { returns(T.nilable(String)) }
      attr_accessor :document_title

      sig { returns(Integer) }
      attr_accessor :end_block_index

      sig { returns(T.nilable(String)) }
      attr_accessor :file_id

      sig { returns(Integer) }
      attr_accessor :start_block_index

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_block_index: Integer,
            file_id: T.nilable(String),
            start_block_index: Integer,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_block_index: Integer,
            file_id: T.nilable(String),
            start_block_index: Integer,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, document_index:, document_title:, end_block_index:, file_id:, start_block_index:, type: :content_block_location); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::CitationContentBlockLocation,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class CitationContentBlockLocationParam < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(Integer) }
      attr_accessor :document_index

      sig { returns(T.nilable(String)) }
      attr_accessor :document_title

      sig { returns(Integer) }
      attr_accessor :end_block_index

      sig { returns(Integer) }
      attr_accessor :start_block_index

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_block_index: Integer,
            start_block_index: Integer,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_block_index: Integer,
            start_block_index: Integer,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, document_index:, document_title:, end_block_index:, start_block_index:, type: :content_block_location); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::CitationContentBlockLocationParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class CitationPageLocation < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(Integer) }
      attr_accessor :document_index

      sig { returns(T.nilable(String)) }
      attr_accessor :document_title

      sig { returns(Integer) }
      attr_accessor :end_page_number

      sig { returns(T.nilable(String)) }
      attr_accessor :file_id

      sig { returns(Integer) }
      attr_accessor :start_page_number

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_page_number: Integer,
            file_id: T.nilable(String),
            start_page_number: Integer,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_page_number: Integer,
            file_id: T.nilable(String),
            start_page_number: Integer,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, document_index:, document_title:, end_page_number:, file_id:, start_page_number:, type: :page_location); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::CitationPageLocation, Anthropic::Internal::AnyHash)
        end
    end

    class CitationPageLocationParam < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(Integer) }
      attr_accessor :document_index

      sig { returns(T.nilable(String)) }
      attr_accessor :document_title

      sig { returns(Integer) }
      attr_accessor :end_page_number

      sig { returns(Integer) }
      attr_accessor :start_page_number

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_page_number: Integer,
            start_page_number: Integer,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            document_index: Integer,
            document_title: T.nilable(String),
            end_page_number: Integer,
            start_page_number: Integer,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, document_index:, document_title:, end_page_number:, start_page_number:, type: :page_location); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::CitationPageLocationParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class CitationSearchResultLocationParam < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(Integer) }
      attr_accessor :end_block_index

      sig { returns(Integer) }
      attr_accessor :search_result_index

      sig { returns(String) }
      attr_accessor :source

      sig { returns(Integer) }
      attr_accessor :start_block_index

      sig { returns(T.nilable(String)) }
      attr_accessor :title

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            cited_text: String,
            end_block_index: Integer,
            search_result_index: Integer,
            source: String,
            start_block_index: Integer,
            title: T.nilable(String),
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            end_block_index: Integer,
            search_result_index: Integer,
            source: String,
            start_block_index: Integer,
            title: T.nilable(String),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, end_block_index:, search_result_index:, source:, start_block_index:, title:, type: :search_result_location); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::CitationSearchResultLocationParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class CitationWebSearchResultLocationParam < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(String) }
      attr_accessor :encrypted_index

      sig { returns(T.nilable(String)) }
      attr_accessor :title

      sig { returns(Symbol) }
      attr_accessor :type

      sig { returns(String) }
      attr_accessor :url

      sig do
        override
          .returns({
            cited_text: String,
            encrypted_index: String,
            title: T.nilable(String),
            type: Symbol,
            url: String
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            encrypted_index: String,
            title: T.nilable(String),
            url: String,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, encrypted_index:, title:, url:, type: :web_search_result_location); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::CitationWebSearchResultLocationParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class CitationsConfigParam < Anthropic::Internal::Type::BaseModel
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :enabled

      sig { params(enabled: T::Boolean).void }
      attr_writer :enabled

      sig { override.returns({ enabled: T::Boolean }) }
      def to_hash; end

      class << self
        sig { params(enabled: T::Boolean).returns(T.attached_class) }
        def new(enabled: nil); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::CitationsConfigParam, Anthropic::Internal::AnyHash)
        end
    end

    class CitationsDelta < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::CitationsDelta::Citation::Variants) }
      attr_accessor :citation

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            citation: Anthropic::CitationsDelta::Citation::Variants,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            citation: T.any(
              Anthropic::CitationCharLocation::OrHash,
              Anthropic::CitationPageLocation::OrHash,
              Anthropic::CitationContentBlockLocation::OrHash,
              Anthropic::CitationsWebSearchResultLocation::OrHash,
              Anthropic::CitationsSearchResultLocation::OrHash
            ),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(citation:, type: :citations_delta); end
      end

      module Citation
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::CitationsDelta::Citation::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::CitationCharLocation,
              Anthropic::CitationPageLocation,
              Anthropic::CitationContentBlockLocation,
              Anthropic::CitationsWebSearchResultLocation,
              Anthropic::CitationsSearchResultLocation
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::CitationsDelta, Anthropic::Internal::AnyHash)
        end
    end

    class CitationsSearchResultLocation < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(Integer) }
      attr_accessor :end_block_index

      sig { returns(Integer) }
      attr_accessor :search_result_index

      sig { returns(String) }
      attr_accessor :source

      sig { returns(Integer) }
      attr_accessor :start_block_index

      sig { returns(T.nilable(String)) }
      attr_accessor :title

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            cited_text: String,
            end_block_index: Integer,
            search_result_index: Integer,
            source: String,
            start_block_index: Integer,
            title: T.nilable(String),
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            end_block_index: Integer,
            search_result_index: Integer,
            source: String,
            start_block_index: Integer,
            title: T.nilable(String),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, end_block_index:, search_result_index:, source:, start_block_index:, title:, type: :search_result_location); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::CitationsSearchResultLocation,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class CitationsWebSearchResultLocation < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :cited_text

      sig { returns(String) }
      attr_accessor :encrypted_index

      sig { returns(T.nilable(String)) }
      attr_accessor :title

      sig { returns(Symbol) }
      attr_accessor :type

      sig { returns(String) }
      attr_accessor :url

      sig do
        override
          .returns({
            cited_text: String,
            encrypted_index: String,
            title: T.nilable(String),
            type: Symbol,
            url: String
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cited_text: String,
            encrypted_index: String,
            title: T.nilable(String),
            url: String,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(cited_text:, encrypted_index:, title:, url:, type: :web_search_result_location); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::CitationsWebSearchResultLocation,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class Completion < Anthropic::Internal::Type::BaseModel
      # The resulting completion up to and excluding the stop sequences.
      sig { returns(String) }
      attr_accessor :completion

      # Unique object identifier.
      #
      # The format and length of IDs may change over time.
      sig { returns(String) }
      attr_accessor :id

      # The model that will complete your prompt.\n\nSee
      # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
      # details and options.
      sig { returns(Anthropic::Model::Variants) }
      attr_accessor :model

      # The reason that we stopped.
      #
      # This may be one the following values:
      #
      # - `"stop_sequence"`: we reached a stop sequence  either provided by you via the
      #   `stop_sequences` parameter, or a stop sequence built into the model
      # - `"max_tokens"`: we exceeded `max_tokens_to_sample` or the model's maximum
      sig { returns(T.nilable(String)) }
      attr_accessor :stop_reason

      # Object type.
      #
      # For Text Completions, this is always `"completion"`.
      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            id: String,
            completion: String,
            model: Anthropic::Model::Variants,
            stop_reason: T.nilable(String),
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            id: String,
            completion: String,
            model: T.any(Anthropic::Model::OrSymbol, String),
            stop_reason: T.nilable(String),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          id:, # Unique object identifier.
               # The format and length of IDs may change over time.
          completion:, # The resulting completion up to and excluding the stop sequences.
          model:, # The model that will complete your prompt.\n\nSee
                  # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                  # details and options.
          stop_reason:, # The reason that we stopped.
                        # This may be one the following values:
                        # - `"stop_sequence"`: we reached a stop sequence  either provided by you via the
                        #   `stop_sequences` parameter, or a stop sequence built into the model
                        # - `"max_tokens"`: we exceeded `max_tokens_to_sample` or the model's maximum
          type: :completion # Object type.
                            # For Text Completions, this is always `"completion"`.
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::Completion, Anthropic::Internal::AnyHash)
        end
    end

    class CompletionCreateParams < Anthropic::Internal::Type::BaseModel
      extend Anthropic::Internal::Type::RequestParameters::Converter
      include Anthropic::Internal::Type::RequestParameters

      # Optional header to specify the beta version(s) you want to use.
      sig { returns(T.nilable(T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)])) }
      attr_reader :betas

      sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
      attr_writer :betas

      # The maximum number of tokens to generate before stopping.
      #
      # Note that our models may stop _before_ reaching this maximum. This parameter
      # only specifies the absolute maximum number of tokens to generate.
      sig { returns(Integer) }
      attr_accessor :max_tokens_to_sample

      # An object describing metadata about the request.
      sig { returns(T.nilable(Anthropic::Metadata)) }
      attr_reader :metadata

      sig { params(metadata: Anthropic::Metadata::OrHash).void }
      attr_writer :metadata

      # The model that will complete your prompt.\n\nSee
      # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
      # details and options.
      sig { returns(T.any(Anthropic::Model::OrSymbol, String)) }
      attr_accessor :model

      # The prompt that you want Claude to complete.
      #
      # For proper response generation you will need to format your prompt using
      # alternating `\n\nHuman:` and `\n\nAssistant:` conversational turns. For example:
      #
      # ```
      # "\n\nHuman: {userQuestion}\n\nAssistant:"
      # ```
      #
      # See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and
      # our guide to
      # [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more
      # details.
      sig { returns(String) }
      attr_accessor :prompt

      # Sequences that will cause the model to stop generating.
      #
      # Our models stop on `"\n\nHuman:"`, and may include additional built-in stop
      # sequences in the future. By providing the stop_sequences parameter, you may
      # include additional strings that will cause the model to stop generating.
      sig { returns(T.nilable(T::Array[String])) }
      attr_reader :stop_sequences

      sig { params(stop_sequences: T::Array[String]).void }
      attr_writer :stop_sequences

      # Amount of randomness injected into the response.
      #
      # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
      # for analytical / multiple choice, and closer to `1.0` for creative and
      # generative tasks.
      #
      # Note that even with `temperature` of `0.0`, the results will not be fully
      # deterministic.
      sig { returns(T.nilable(Float)) }
      attr_reader :temperature

      sig { params(temperature: Float).void }
      attr_writer :temperature

      # Only sample from the top K options for each subsequent token.
      #
      # Used to remove "long tail" low probability responses.
      # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
      #
      # Recommended for advanced use cases only. You usually only need to use
      # `temperature`.
      sig { returns(T.nilable(Integer)) }
      attr_reader :top_k

      sig { params(top_k: Integer).void }
      attr_writer :top_k

      # Use nucleus sampling.
      #
      # In nucleus sampling, we compute the cumulative distribution over all the options
      # for each subsequent token in decreasing probability order and cut it off once it
      # reaches a particular probability specified by `top_p`. You should either alter
      # `temperature` or `top_p`, but not both.
      #
      # Recommended for advanced use cases only. You usually only need to use
      # `temperature`.
      sig { returns(T.nilable(Float)) }
      attr_reader :top_p

      sig { params(top_p: Float).void }
      attr_writer :top_p

      sig do
        override
          .returns({
            max_tokens_to_sample: Integer,
            model: T.any(Anthropic::Model::OrSymbol, String),
            prompt: String,
            metadata: Anthropic::Metadata,
            stop_sequences: T::Array[String],
            temperature: Float,
            top_k: Integer,
            top_p: Float,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            max_tokens_to_sample: Integer,
            model: T.any(Anthropic::Model::OrSymbol, String),
            prompt: String,
            metadata: Anthropic::Metadata::OrHash,
            stop_sequences: T::Array[String],
            temperature: Float,
            top_k: Integer,
            top_p: Float,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          max_tokens_to_sample:, # The maximum number of tokens to generate before stopping.
                                 # Note that our models may stop _before_ reaching this maximum. This parameter
                                 # only specifies the absolute maximum number of tokens to generate.
          model:, # The model that will complete your prompt.\n\nSee
                  # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                  # details and options.
          prompt:, # The prompt that you want Claude to complete.
                   # For proper response generation you will need to format your prompt using
                   # alternating `\n\nHuman:` and `\n\nAssistant:` conversational turns. For example:
                   # ```
                   # "\n\nHuman: {userQuestion}\n\nAssistant:"
                   # ```
                   # See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and
                   # our guide to
                   # [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more
                   # details.
          metadata: nil, # An object describing metadata about the request.
          stop_sequences: nil, # Sequences that will cause the model to stop generating.
                               # Our models stop on `"\n\nHuman:"`, and may include additional built-in stop
                               # sequences in the future. By providing the stop_sequences parameter, you may
                               # include additional strings that will cause the model to stop generating.
          temperature: nil, # Amount of randomness injected into the response.
                            # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                            # for analytical / multiple choice, and closer to `1.0` for creative and
                            # generative tasks.
                            # Note that even with `temperature` of `0.0`, the results will not be fully
                            # deterministic.
          top_k: nil, # Only sample from the top K options for each subsequent token.
                      # Used to remove "long tail" low probability responses.
                      # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                      # Recommended for advanced use cases only. You usually only need to use
                      # `temperature`.
          top_p: nil, # Use nucleus sampling.
                      # In nucleus sampling, we compute the cumulative distribution over all the options
                      # for each subsequent token in decreasing probability order and cut it off once it
                      # reaches a particular probability specified by `top_p`. You should either alter
                      # `temperature` or `top_p`, but not both.
                      # Recommended for advanced use cases only. You usually only need to use
                      # `temperature`.
          betas: nil, # Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::CompletionCreateParams, Anthropic::Internal::AnyHash)
        end
    end

    module ContentBlock
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::ContentBlock::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::TextBlock,
            Anthropic::ThinkingBlock,
            Anthropic::RedactedThinkingBlock,
            Anthropic::ToolUseBlock,
            Anthropic::ServerToolUseBlock,
            Anthropic::WebSearchToolResultBlock
          )
        end
    end

    # Regular text content.
    module ContentBlockParam
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::ContentBlockParam::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::TextBlockParam,
            Anthropic::ImageBlockParam,
            Anthropic::DocumentBlockParam,
            Anthropic::SearchResultBlockParam,
            Anthropic::ThinkingBlockParam,
            Anthropic::RedactedThinkingBlockParam,
            Anthropic::ToolUseBlockParam,
            Anthropic::ToolResultBlockParam,
            Anthropic::ServerToolUseBlockParam,
            Anthropic::WebSearchToolResultBlockParam
          )
        end
    end

    class ContentBlockSource < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::ContentBlockSource::Content::Variants) }
      attr_accessor :content

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            content: Anthropic::ContentBlockSource::Content::Variants,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            content: Anthropic::ContentBlockSource::Content::Variants,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(content:, type: :content); end
      end

      module Content
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::ContentBlockSource::Content::Variants]) }
          def variants; end
        end

        ContentBlockSourceContentArray = T.let(
            Anthropic::Internal::Type::ArrayOf[
              union: Anthropic::ContentBlockSourceContent
            ],
            Anthropic::Internal::Type::Converter
          )

        Variants = T.type_alias do
            T.any(
              String,
              T::Array[Anthropic::ContentBlockSourceContent::Variants]
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ContentBlockSource, Anthropic::Internal::AnyHash)
        end
    end

    module ContentBlockSourceContent
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::ContentBlockSourceContent::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(Anthropic::TextBlockParam, Anthropic::ImageBlockParam)
        end
    end

    class DocumentBlockParam < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      sig { returns(T.nilable(Anthropic::CitationsConfigParam)) }
      attr_reader :citations

      sig { params(citations: Anthropic::CitationsConfigParam::OrHash).void }
      attr_writer :citations

      sig { returns(T.nilable(String)) }
      attr_accessor :context

      sig do
        returns(T.any(
            Anthropic::Base64PDFSource,
            Anthropic::PlainTextSource,
            Anthropic::ContentBlockSource,
            Anthropic::URLPDFSource
          ))
      end
      attr_accessor :source

      sig { returns(T.nilable(String)) }
      attr_accessor :title

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            source:
              T.any(
                Anthropic::Base64PDFSource,
                Anthropic::PlainTextSource,
                Anthropic::ContentBlockSource,
                Anthropic::URLPDFSource
              ),
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral),
            citations: Anthropic::CitationsConfigParam,
            context: T.nilable(String),
            title: T.nilable(String)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            source: T.any(
              Anthropic::Base64PDFSource::OrHash,
              Anthropic::PlainTextSource::OrHash,
              Anthropic::ContentBlockSource::OrHash,
              Anthropic::URLPDFSource::OrHash
            ),
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            citations: Anthropic::CitationsConfigParam::OrHash,
            context: T.nilable(String),
            title: T.nilable(String),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          source:,
          cache_control: nil, # Create a cache control breakpoint at this content block.
          citations: nil,
          context: nil,
          title: nil,
          type: :document
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::DocumentBlockParam, Anthropic::Internal::AnyHash)
        end

      module Source
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::DocumentBlockParam::Source::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Base64PDFSource,
              Anthropic::PlainTextSource,
              Anthropic::ContentBlockSource,
              Anthropic::URLPDFSource
            )
          end
      end
    end

    module ErrorObject
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::ErrorObject::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::InvalidRequestError,
            Anthropic::AuthenticationError,
            Anthropic::BillingError,
            Anthropic::PermissionError,
            Anthropic::NotFoundError,
            Anthropic::RateLimitError,
            Anthropic::GatewayTimeoutError,
            Anthropic::APIErrorObject,
            Anthropic::OverloadedError
          )
        end
    end

    class ErrorResponse < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::ErrorObject::Variants) }
      attr_accessor :error

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ error: Anthropic::ErrorObject::Variants, type: Symbol }) }
      def to_hash; end

      class << self
        sig do
          params(
            error: T.any(
              Anthropic::InvalidRequestError::OrHash,
              Anthropic::AuthenticationError::OrHash,
              Anthropic::BillingError::OrHash,
              Anthropic::PermissionError::OrHash,
              Anthropic::NotFoundError::OrHash,
              Anthropic::RateLimitError::OrHash,
              Anthropic::GatewayTimeoutError::OrHash,
              Anthropic::APIErrorObject::OrHash,
              Anthropic::OverloadedError::OrHash
            ),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(error:, type: :error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ErrorResponse, Anthropic::Internal::AnyHash)
        end
    end

    class GatewayTimeoutError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :timeout_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::GatewayTimeoutError, Anthropic::Internal::AnyHash)
        end
    end

    class ImageBlockParam < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      sig { returns(T.any(Anthropic::Base64ImageSource, Anthropic::URLImageSource)) }
      attr_accessor :source

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            source:
              T.any(Anthropic::Base64ImageSource, Anthropic::URLImageSource),
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            source: T.any(
              Anthropic::Base64ImageSource::OrHash,
              Anthropic::URLImageSource::OrHash
            ),
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          source:,
          cache_control: nil, # Create a cache control breakpoint at this content block.
          type: :image
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ImageBlockParam, Anthropic::Internal::AnyHash)
        end

      module Source
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::ImageBlockParam::Source::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(Anthropic::Base64ImageSource, Anthropic::URLImageSource)
          end
      end
    end

    class InputJSONDelta < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :partial_json

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ partial_json: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(partial_json: String, type: Symbol).returns(T.attached_class) }
        def new(partial_json:, type: :input_json_delta); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::InputJSONDelta, Anthropic::Internal::AnyHash)
        end
    end

    class InvalidRequestError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :invalid_request_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::InvalidRequestError, Anthropic::Internal::AnyHash)
        end
    end

    class Message < Anthropic::Internal::Type::BaseModel
      # Content generated by the model.
      #
      # This is an array of content blocks, each of which has a `type` that determines
      # its shape.
      #
      # Example:
      #
      # ```json
      # [{ "type": "text", "text": "Hi, I'm Claude." }]
      # ```
      #
      # If the request input `messages` ended with an `assistant` turn, then the
      # response `content` will continue directly from that last turn. You can use this
      # to constrain the model's output.
      #
      # For example, if the input `messages` were:
      #
      # ```json
      # [
      #   {
      #     "role": "user",
      #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
      #   },
      #   { "role": "assistant", "content": "The best answer is (" }
      # ]
      # ```
      #
      # Then the response `content` might be:
      #
      # ```json
      # [{ "type": "text", "text": "B)" }]
      # ```
      sig { returns(T::Array[Anthropic::ContentBlock::Variants]) }
      attr_accessor :content

      # Unique object identifier.
      #
      # The format and length of IDs may change over time.
      sig { returns(String) }
      attr_accessor :id

      # The model that will complete your prompt.\n\nSee
      # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
      # details and options.
      sig { returns(Anthropic::Model::Variants) }
      attr_accessor :model

      # Conversational role of the generated message.
      #
      # This will always be `"assistant"`.
      sig { returns(Symbol) }
      attr_accessor :role

      # The reason that we stopped.
      #
      # This may be one the following values:
      #
      # - `"end_turn"`: the model reached a natural stopping point
      # - `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
      # - `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
      # - `"tool_use"`: the model invoked one or more tools
      # - `"pause_turn"`: we paused a long-running turn. You may provide the response
      #   back as-is in a subsequent request to let the model continue.
      # - `"refusal"`: when streaming classifiers intervene to handle potential policy
      #   violations
      #
      # In non-streaming mode this value is always non-null. In streaming mode, it is
      # null in the `message_start` event and non-null otherwise.
      sig { returns(T.nilable(Anthropic::StopReason::TaggedSymbol)) }
      attr_accessor :stop_reason

      # Which custom stop sequence was generated, if any.
      #
      # This value will be a non-null string if one of your custom stop sequences was
      # generated.
      sig { returns(T.nilable(String)) }
      attr_accessor :stop_sequence

      # Object type.
      #
      # For Messages, this is always `"message"`.
      sig { returns(Symbol) }
      attr_accessor :type

      # Billing and rate-limit usage.
      #
      # Anthropic's API bills and rate-limits by token counts, as tokens represent the
      # underlying cost to our systems.
      #
      # Under the hood, the API transforms requests into a format suitable for the
      # model. The model's output then goes through a parsing stage before becoming an
      # API response. As a result, the token counts in `usage` will not match one-to-one
      # with the exact visible content of an API request or response.
      #
      # For example, `output_tokens` will be non-zero, even for an empty string response
      # from Claude.
      #
      # Total input tokens in a request is the summation of `input_tokens`,
      # `cache_creation_input_tokens`, and `cache_read_input_tokens`.
      sig { returns(Anthropic::Usage) }
      attr_reader :usage

      sig { params(usage: Anthropic::Usage::OrHash).void }
      attr_writer :usage

      sig do
        override
          .returns({
            id: String,
            content: T::Array[Anthropic::ContentBlock::Variants],
            model: Anthropic::Model::Variants,
            role: Symbol,
            stop_reason: T.nilable(Anthropic::StopReason::TaggedSymbol),
            stop_sequence: T.nilable(String),
            type: Symbol,
            usage: Anthropic::Usage
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            id: String,
            content: T::Array[
              T.any(
                Anthropic::TextBlock::OrHash,
                Anthropic::ThinkingBlock::OrHash,
                Anthropic::RedactedThinkingBlock::OrHash,
                Anthropic::ToolUseBlock::OrHash,
                Anthropic::ServerToolUseBlock::OrHash,
                Anthropic::WebSearchToolResultBlock::OrHash
              )
            ],
            model: T.any(Anthropic::Model::OrSymbol, String),
            stop_reason: T.nilable(Anthropic::StopReason::OrSymbol),
            stop_sequence: T.nilable(String),
            usage: Anthropic::Usage::OrHash,
            role: Symbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          id:, # Unique object identifier.
               # The format and length of IDs may change over time.
          content:, # Content generated by the model.
                    # This is an array of content blocks, each of which has a `type` that determines
                    # its shape.
                    # Example:
                    # ```json
                    # [{ "type": "text", "text": "Hi, I'm Claude." }]
                    # ```
                    # If the request input `messages` ended with an `assistant` turn, then the
                    # response `content` will continue directly from that last turn. You can use this
                    # to constrain the model's output.
                    # For example, if the input `messages` were:
                    # ```json
                    # [
                    #   {
                    #     "role": "user",
                    #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                    #   },
                    #   { "role": "assistant", "content": "The best answer is (" }
                    # ]
                    # ```
                    # Then the response `content` might be:
                    # ```json
                    # [{ "type": "text", "text": "B)" }]
                    # ```
          model:, # The model that will complete your prompt.\n\nSee
                  # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                  # details and options.
          stop_reason:, # The reason that we stopped.
                        # This may be one the following values:
                        # - `"end_turn"`: the model reached a natural stopping point
                        # - `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
                        # - `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
                        # - `"tool_use"`: the model invoked one or more tools
                        # - `"pause_turn"`: we paused a long-running turn. You may provide the response
                        #   back as-is in a subsequent request to let the model continue.
                        # - `"refusal"`: when streaming classifiers intervene to handle potential policy
                        #   violations
                        # In non-streaming mode this value is always non-null. In streaming mode, it is
                        # null in the `message_start` event and non-null otherwise.
          stop_sequence:, # Which custom stop sequence was generated, if any.
                          # This value will be a non-null string if one of your custom stop sequences was
                          # generated.
          usage:, # Billing and rate-limit usage.
                  # Anthropic's API bills and rate-limits by token counts, as tokens represent the
                  # underlying cost to our systems.
                  # Under the hood, the API transforms requests into a format suitable for the
                  # model. The model's output then goes through a parsing stage before becoming an
                  # API response. As a result, the token counts in `usage` will not match one-to-one
                  # with the exact visible content of an API request or response.
                  # For example, `output_tokens` will be non-zero, even for an empty string response
                  # from Claude.
                  # Total input tokens in a request is the summation of `input_tokens`,
                  # `cache_creation_input_tokens`, and `cache_read_input_tokens`.
          role: :assistant, # Conversational role of the generated message.
                            # This will always be `"assistant"`.
          type: :message # Object type.
                         # For Messages, this is always `"message"`.
); end
      end

      OrHash = T.type_alias { T.any(Anthropic::Message, Anthropic::Internal::AnyHash) }
    end

    MessageBatch = Messages::MessageBatch
    MessageBatchCanceledResult = Messages::MessageBatchCanceledResult
    MessageBatchErroredResult = Messages::MessageBatchErroredResult
    MessageBatchExpiredResult = Messages::MessageBatchExpiredResult
    MessageBatchIndividualResponse = Messages::MessageBatchIndividualResponse
    MessageBatchRequestCounts = Messages::MessageBatchRequestCounts
    MessageBatchResult = Messages::MessageBatchResult
    MessageBatchSucceededResult = Messages::MessageBatchSucceededResult

    class MessageCountTokensParams < Anthropic::Internal::Type::BaseModel
      extend Anthropic::Internal::Type::RequestParameters::Converter
      include Anthropic::Internal::Type::RequestParameters

      # Input messages.
      #
      # Our models are trained to operate on alternating `user` and `assistant`
      # conversational turns. When creating a new `Message`, you specify the prior
      # conversational turns with the `messages` parameter, and the model then generates
      # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
      # in your request will be combined into a single turn.
      #
      # Each input message must be an object with a `role` and `content`. You can
      # specify a single `user`-role message, or you can include multiple `user` and
      # `assistant` messages.
      #
      # If the final message uses the `assistant` role, the response content will
      # continue immediately from the content in that message. This can be used to
      # constrain part of the model's response.
      #
      # Example with a single `user` message:
      #
      # ```json
      # [{ "role": "user", "content": "Hello, Claude" }]
      # ```
      #
      # Example with multiple conversational turns:
      #
      # ```json
      # [
      #   { "role": "user", "content": "Hello there." },
      #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
      #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
      # ]
      # ```
      #
      # Example with a partially-filled response from Claude:
      #
      # ```json
      # [
      #   {
      #     "role": "user",
      #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
      #   },
      #   { "role": "assistant", "content": "The best answer is (" }
      # ]
      # ```
      #
      # Each input message `content` may be either a single `string` or an array of
      # content blocks, where each block has a specific `type`. Using a `string` for
      # `content` is shorthand for an array of one content block of type `"text"`. The
      # following input messages are equivalent:
      #
      # ```json
      # { "role": "user", "content": "Hello, Claude" }
      # ```
      #
      # ```json
      # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
      # ```
      #
      # Starting with Claude 3 models, you can also send image content blocks:
      #
      # ```json
      # {
      #   "role": "user",
      #   "content": [
      #     {
      #       "type": "image",
      #       "source": {
      #         "type": "base64",
      #         "media_type": "image/jpeg",
      #         "data": "/9j/4AAQSkZJRg..."
      #       }
      #     },
      #     { "type": "text", "text": "What is in this image?" }
      #   ]
      # }
      # ```
      #
      # We currently support the `base64` source type for images, and the `image/jpeg`,
      # `image/png`, `image/gif`, and `image/webp` media types.
      #
      # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
      # more input examples.
      #
      # Note that if you want to include a
      # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
      # the top-level `system` parameter  there is no `"system"` role for input
      # messages in the Messages API.
      #
      # There is a limit of 100,000 messages in a single request.
      sig { returns(T::Array[Anthropic::MessageParam]) }
      attr_accessor :messages

      # The model that will complete your prompt.\n\nSee
      # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
      # details and options.
      sig { returns(T.any(Anthropic::Model::OrSymbol, String)) }
      attr_accessor :model

      # System prompt.
      #
      # A system prompt is a way of providing context and instructions to Claude, such
      # as specifying a particular goal or role. See our
      # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
      sig { returns(T.nilable(Anthropic::MessageCountTokensParams::System::Variants)) }
      attr_reader :system_

      sig { params(system_: Anthropic::MessageCountTokensParams::System::Variants).void }
      attr_writer :system_

      # Configuration for enabling Claude's extended thinking.
      #
      # When enabled, responses include `thinking` content blocks showing Claude's
      # thinking process before the final answer. Requires a minimum budget of 1,024
      # tokens and counts towards your `max_tokens` limit.
      #
      # See
      # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
      # for details.
      sig do
        returns(T.nilable(
            T.any(
              Anthropic::ThinkingConfigEnabled,
              Anthropic::ThinkingConfigDisabled
            )
          ))
      end
      attr_reader :thinking

      sig do
        params(
          thinking: T.any(
              Anthropic::ThinkingConfigEnabled::OrHash,
              Anthropic::ThinkingConfigDisabled::OrHash
            )
        ).void
      end
      attr_writer :thinking

      # How the model should use the provided tools. The model can use a specific tool,
      # any available tool, decide by itself, or not use tools at all.
      sig do
        returns(T.nilable(
            T.any(
              Anthropic::ToolChoiceAuto,
              Anthropic::ToolChoiceAny,
              Anthropic::ToolChoiceTool,
              Anthropic::ToolChoiceNone
            )
          ))
      end
      attr_reader :tool_choice

      sig do
        params(
          tool_choice: T.any(
              Anthropic::ToolChoiceAuto::OrHash,
              Anthropic::ToolChoiceAny::OrHash,
              Anthropic::ToolChoiceTool::OrHash,
              Anthropic::ToolChoiceNone::OrHash
            )
        ).void
      end
      attr_writer :tool_choice

      # Definitions of tools that the model may use.
      #
      # If you include `tools` in your API request, the model may return `tool_use`
      # content blocks that represent the model's use of those tools. You can then run
      # those tools using the tool input generated by the model and then optionally
      # return results back to the model using `tool_result` content blocks.
      #
      # There are two types of tools: **client tools** and **server tools**. The
      # behavior described below applies to client tools. For
      # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
      # see their individual documentation as each has its own behavior (e.g., the
      # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
      #
      # Each tool definition includes:
      #
      # - `name`: Name of the tool.
      # - `description`: Optional, but strongly-recommended description of the tool.
      # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
      #   tool `input` shape that the model will produce in `tool_use` output content
      #   blocks.
      #
      # For example, if you defined `tools` as:
      #
      # ```json
      # [
      #   {
      #     "name": "get_stock_price",
      #     "description": "Get the current stock price for a given ticker symbol.",
      #     "input_schema": {
      #       "type": "object",
      #       "properties": {
      #         "ticker": {
      #           "type": "string",
      #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
      #         }
      #       },
      #       "required": ["ticker"]
      #     }
      #   }
      # ]
      # ```
      #
      # And then asked the model "What's the S&P 500 at today?", the model might produce
      # `tool_use` content blocks in the response like this:
      #
      # ```json
      # [
      #   {
      #     "type": "tool_use",
      #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
      #     "name": "get_stock_price",
      #     "input": { "ticker": "^GSPC" }
      #   }
      # ]
      # ```
      #
      # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
      # input, and return the following back to the model in a subsequent `user`
      # message:
      #
      # ```json
      # [
      #   {
      #     "type": "tool_result",
      #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
      #     "content": "259.75 USD"
      #   }
      # ]
      # ```
      #
      # Tools can be used for workflows that include running client-side tools and
      # functions, or more generally whenever you want the model to produce a particular
      # JSON structure of output.
      #
      # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
      sig do
        returns(T.nilable(
            T::Array[
              T.any(
                Anthropic::Tool,
                Anthropic::ToolBash20250124,
                Anthropic::ToolTextEditor20250124,
                Anthropic::ToolTextEditor20250429,
                Anthropic::ToolTextEditor20250728,
                Anthropic::WebSearchTool20250305
              )
            ]
          ))
      end
      attr_reader :tools

      sig do
        params(
          tools: T::Array[
              T.any(
                Anthropic::Tool::OrHash,
                Anthropic::ToolBash20250124::OrHash,
                Anthropic::ToolTextEditor20250124::OrHash,
                Anthropic::ToolTextEditor20250429::OrHash,
                Anthropic::ToolTextEditor20250728::OrHash,
                Anthropic::WebSearchTool20250305::OrHash
              )
            ]
        ).void
      end
      attr_writer :tools

      sig do
        override
          .returns({
            messages: T::Array[Anthropic::MessageParam],
            model: T.any(Anthropic::Model::OrSymbol, String),
            system_: Anthropic::MessageCountTokensParams::System::Variants,
            thinking:
              T.any(
                Anthropic::ThinkingConfigEnabled,
                Anthropic::ThinkingConfigDisabled
              ),
            tool_choice:
              T.any(
                Anthropic::ToolChoiceAuto,
                Anthropic::ToolChoiceAny,
                Anthropic::ToolChoiceTool,
                Anthropic::ToolChoiceNone
              ),
            tools:
              T::Array[
                T.any(
                  Anthropic::Tool,
                  Anthropic::ToolBash20250124,
                  Anthropic::ToolTextEditor20250124,
                  Anthropic::ToolTextEditor20250429,
                  Anthropic::ToolTextEditor20250728,
                  Anthropic::WebSearchTool20250305
                )
              ],
            request_options: Anthropic::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            messages: T::Array[Anthropic::MessageParam::OrHash],
            model: T.any(Anthropic::Model::OrSymbol, String),
            system_: Anthropic::MessageCountTokensParams::System::Variants,
            thinking: T.any(
              Anthropic::ThinkingConfigEnabled::OrHash,
              Anthropic::ThinkingConfigDisabled::OrHash
            ),
            tool_choice: T.any(
              Anthropic::ToolChoiceAuto::OrHash,
              Anthropic::ToolChoiceAny::OrHash,
              Anthropic::ToolChoiceTool::OrHash,
              Anthropic::ToolChoiceNone::OrHash
            ),
            tools: T::Array[
              T.any(
                Anthropic::Tool::OrHash,
                Anthropic::ToolBash20250124::OrHash,
                Anthropic::ToolTextEditor20250124::OrHash,
                Anthropic::ToolTextEditor20250429::OrHash,
                Anthropic::ToolTextEditor20250728::OrHash,
                Anthropic::WebSearchTool20250305::OrHash
              )
            ],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          messages:, # Input messages.
                     # Our models are trained to operate on alternating `user` and `assistant`
                     # conversational turns. When creating a new `Message`, you specify the prior
                     # conversational turns with the `messages` parameter, and the model then generates
                     # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                     # in your request will be combined into a single turn.
                     # Each input message must be an object with a `role` and `content`. You can
                     # specify a single `user`-role message, or you can include multiple `user` and
                     # `assistant` messages.
                     # If the final message uses the `assistant` role, the response content will
                     # continue immediately from the content in that message. This can be used to
                     # constrain part of the model's response.
                     # Example with a single `user` message:
                     # ```json
                     # [{ "role": "user", "content": "Hello, Claude" }]
                     # ```
                     # Example with multiple conversational turns:
                     # ```json
                     # [
                     #   { "role": "user", "content": "Hello there." },
                     #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                     #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                     # ]
                     # ```
                     # Example with a partially-filled response from Claude:
                     # ```json
                     # [
                     #   {
                     #     "role": "user",
                     #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                     #   },
                     #   { "role": "assistant", "content": "The best answer is (" }
                     # ]
                     # ```
                     # Each input message `content` may be either a single `string` or an array of
                     # content blocks, where each block has a specific `type`. Using a `string` for
                     # `content` is shorthand for an array of one content block of type `"text"`. The
                     # following input messages are equivalent:
                     # ```json
                     # { "role": "user", "content": "Hello, Claude" }
                     # ```
                     # ```json
                     # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                     # ```
                     # Starting with Claude 3 models, you can also send image content blocks:
                     # ```json
                     # {
                     #   "role": "user",
                     #   "content": [
                     #     {
                     #       "type": "image",
                     #       "source": {
                     #         "type": "base64",
                     #         "media_type": "image/jpeg",
                     #         "data": "/9j/4AAQSkZJRg..."
                     #       }
                     #     },
                     #     { "type": "text", "text": "What is in this image?" }
                     #   ]
                     # }
                     # ```
                     # We currently support the `base64` source type for images, and the `image/jpeg`,
                     # `image/png`, `image/gif`, and `image/webp` media types.
                     # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                     # more input examples.
                     # Note that if you want to include a
                     # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                     # the top-level `system` parameter  there is no `"system"` role for input
                     # messages in the Messages API.
                     # There is a limit of 100,000 messages in a single request.
          model:, # The model that will complete your prompt.\n\nSee
                  # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                  # details and options.
          system_: nil, # System prompt.
                        # A system prompt is a way of providing context and instructions to Claude, such
                        # as specifying a particular goal or role. See our
                        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
          thinking: nil, # Configuration for enabling Claude's extended thinking.
                         # When enabled, responses include `thinking` content blocks showing Claude's
                         # thinking process before the final answer. Requires a minimum budget of 1,024
                         # tokens and counts towards your `max_tokens` limit.
                         # See
                         # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                         # for details.
          tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                            # any available tool, decide by itself, or not use tools at all.
          tools: nil, # Definitions of tools that the model may use.
                      # If you include `tools` in your API request, the model may return `tool_use`
                      # content blocks that represent the model's use of those tools. You can then run
                      # those tools using the tool input generated by the model and then optionally
                      # return results back to the model using `tool_result` content blocks.
                      # There are two types of tools: **client tools** and **server tools**. The
                      # behavior described below applies to client tools. For
                      # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                      # see their individual documentation as each has its own behavior (e.g., the
                      # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                      # Each tool definition includes:
                      # - `name`: Name of the tool.
                      # - `description`: Optional, but strongly-recommended description of the tool.
                      # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                      #   tool `input` shape that the model will produce in `tool_use` output content
                      #   blocks.
                      # For example, if you defined `tools` as:
                      # ```json
                      # [
                      #   {
                      #     "name": "get_stock_price",
                      #     "description": "Get the current stock price for a given ticker symbol.",
                      #     "input_schema": {
                      #       "type": "object",
                      #       "properties": {
                      #         "ticker": {
                      #           "type": "string",
                      #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                      #         }
                      #       },
                      #       "required": ["ticker"]
                      #     }
                      #   }
                      # ]
                      # ```
                      # And then asked the model "What's the S&P 500 at today?", the model might produce
                      # `tool_use` content blocks in the response like this:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_use",
                      #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "name": "get_stock_price",
                      #     "input": { "ticker": "^GSPC" }
                      #   }
                      # ]
                      # ```
                      # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                      # input, and return the following back to the model in a subsequent `user`
                      # message:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_result",
                      #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "content": "259.75 USD"
                      #   }
                      # ]
                      # ```
                      # Tools can be used for workflows that include running client-side tools and
                      # functions, or more generally whenever you want the model to produce a particular
                      # JSON structure of output.
                      # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::MessageCountTokensParams,
            Anthropic::Internal::AnyHash
          )
        end

      # System prompt.
      #
      # A system prompt is a way of providing context and instructions to Claude, such
      # as specifying a particular goal or role. See our
      # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
      module System
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::MessageCountTokensParams::System::Variants]) }
          def variants; end
        end

        TextBlockParamArray = T.let(
            Anthropic::Internal::Type::ArrayOf[Anthropic::TextBlockParam],
            Anthropic::Internal::Type::Converter
          )

        Variants = T.type_alias { T.any(String, T::Array[Anthropic::TextBlockParam]) }
      end
    end

    module MessageCountTokensTool
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::MessageCountTokensTool::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::Tool,
            Anthropic::ToolBash20250124,
            Anthropic::ToolTextEditor20250124,
            Anthropic::ToolTextEditor20250429,
            Anthropic::ToolTextEditor20250728,
            Anthropic::WebSearchTool20250305
          )
        end
    end

    class MessageCreateParams < Anthropic::Internal::Type::BaseModel
      extend Anthropic::Internal::Type::RequestParameters::Converter
      include Anthropic::Internal::Type::RequestParameters

      # The maximum number of tokens to generate before stopping.
      #
      # Note that our models may stop _before_ reaching this maximum. This parameter
      # only specifies the absolute maximum number of tokens to generate.
      #
      # Different models have different maximum values for this parameter. See
      # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
      sig { returns(Integer) }
      attr_accessor :max_tokens

      # Input messages.
      #
      # Our models are trained to operate on alternating `user` and `assistant`
      # conversational turns. When creating a new `Message`, you specify the prior
      # conversational turns with the `messages` parameter, and the model then generates
      # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
      # in your request will be combined into a single turn.
      #
      # Each input message must be an object with a `role` and `content`. You can
      # specify a single `user`-role message, or you can include multiple `user` and
      # `assistant` messages.
      #
      # If the final message uses the `assistant` role, the response content will
      # continue immediately from the content in that message. This can be used to
      # constrain part of the model's response.
      #
      # Example with a single `user` message:
      #
      # ```json
      # [{ "role": "user", "content": "Hello, Claude" }]
      # ```
      #
      # Example with multiple conversational turns:
      #
      # ```json
      # [
      #   { "role": "user", "content": "Hello there." },
      #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
      #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
      # ]
      # ```
      #
      # Example with a partially-filled response from Claude:
      #
      # ```json
      # [
      #   {
      #     "role": "user",
      #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
      #   },
      #   { "role": "assistant", "content": "The best answer is (" }
      # ]
      # ```
      #
      # Each input message `content` may be either a single `string` or an array of
      # content blocks, where each block has a specific `type`. Using a `string` for
      # `content` is shorthand for an array of one content block of type `"text"`. The
      # following input messages are equivalent:
      #
      # ```json
      # { "role": "user", "content": "Hello, Claude" }
      # ```
      #
      # ```json
      # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
      # ```
      #
      # Starting with Claude 3 models, you can also send image content blocks:
      #
      # ```json
      # {
      #   "role": "user",
      #   "content": [
      #     {
      #       "type": "image",
      #       "source": {
      #         "type": "base64",
      #         "media_type": "image/jpeg",
      #         "data": "/9j/4AAQSkZJRg..."
      #       }
      #     },
      #     { "type": "text", "text": "What is in this image?" }
      #   ]
      # }
      # ```
      #
      # We currently support the `base64` source type for images, and the `image/jpeg`,
      # `image/png`, `image/gif`, and `image/webp` media types.
      #
      # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
      # more input examples.
      #
      # Note that if you want to include a
      # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
      # the top-level `system` parameter  there is no `"system"` role for input
      # messages in the Messages API.
      #
      # There is a limit of 100,000 messages in a single request.
      sig { returns(T::Array[Anthropic::MessageParam]) }
      attr_accessor :messages

      # An object describing metadata about the request.
      sig { returns(T.nilable(Anthropic::Metadata)) }
      attr_reader :metadata

      sig { params(metadata: Anthropic::Metadata::OrHash).void }
      attr_writer :metadata

      # The model that will complete your prompt.\n\nSee
      # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
      # details and options.
      sig { returns(T.any(Anthropic::Model::OrSymbol, String)) }
      attr_accessor :model

      # Determines whether to use priority capacity (if available) or standard capacity
      # for this request.
      #
      # Anthropic offers different levels of service for your API requests. See
      # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
      sig { returns(T.nilable(Anthropic::MessageCreateParams::ServiceTier::OrSymbol)) }
      attr_reader :service_tier

      sig { params(service_tier: Anthropic::MessageCreateParams::ServiceTier::OrSymbol).void }
      attr_writer :service_tier

      # Custom text sequences that will cause the model to stop generating.
      #
      # Our models will normally stop when they have naturally completed their turn,
      # which will result in a response `stop_reason` of `"end_turn"`.
      #
      # If you want the model to stop generating when it encounters custom strings of
      # text, you can use the `stop_sequences` parameter. If the model encounters one of
      # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
      # and the response `stop_sequence` value will contain the matched stop sequence.
      sig { returns(T.nilable(T::Array[String])) }
      attr_reader :stop_sequences

      sig { params(stop_sequences: T::Array[String]).void }
      attr_writer :stop_sequences

      # System prompt.
      #
      # A system prompt is a way of providing context and instructions to Claude, such
      # as specifying a particular goal or role. See our
      # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
      sig { returns(T.nilable(Anthropic::MessageCreateParams::System::Variants)) }
      attr_reader :system_

      sig { params(system_: Anthropic::MessageCreateParams::System::Variants).void }
      attr_writer :system_

      # Amount of randomness injected into the response.
      #
      # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
      # for analytical / multiple choice, and closer to `1.0` for creative and
      # generative tasks.
      #
      # Note that even with `temperature` of `0.0`, the results will not be fully
      # deterministic.
      sig { returns(T.nilable(Float)) }
      attr_reader :temperature

      sig { params(temperature: Float).void }
      attr_writer :temperature

      # Configuration for enabling Claude's extended thinking.
      #
      # When enabled, responses include `thinking` content blocks showing Claude's
      # thinking process before the final answer. Requires a minimum budget of 1,024
      # tokens and counts towards your `max_tokens` limit.
      #
      # See
      # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
      # for details.
      sig do
        returns(T.nilable(
            T.any(
              Anthropic::ThinkingConfigEnabled,
              Anthropic::ThinkingConfigDisabled
            )
          ))
      end
      attr_reader :thinking

      sig do
        params(
          thinking: T.any(
              Anthropic::ThinkingConfigEnabled::OrHash,
              Anthropic::ThinkingConfigDisabled::OrHash
            )
        ).void
      end
      attr_writer :thinking

      # How the model should use the provided tools. The model can use a specific tool,
      # any available tool, decide by itself, or not use tools at all.
      sig do
        returns(T.nilable(
            T.any(
              Anthropic::ToolChoiceAuto,
              Anthropic::ToolChoiceAny,
              Anthropic::ToolChoiceTool,
              Anthropic::ToolChoiceNone
            )
          ))
      end
      attr_reader :tool_choice

      sig do
        params(
          tool_choice: T.any(
              Anthropic::ToolChoiceAuto::OrHash,
              Anthropic::ToolChoiceAny::OrHash,
              Anthropic::ToolChoiceTool::OrHash,
              Anthropic::ToolChoiceNone::OrHash
            )
        ).void
      end
      attr_writer :tool_choice

      # Definitions of tools that the model may use.
      #
      # If you include `tools` in your API request, the model may return `tool_use`
      # content blocks that represent the model's use of those tools. You can then run
      # those tools using the tool input generated by the model and then optionally
      # return results back to the model using `tool_result` content blocks.
      #
      # There are two types of tools: **client tools** and **server tools**. The
      # behavior described below applies to client tools. For
      # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
      # see their individual documentation as each has its own behavior (e.g., the
      # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
      #
      # Each tool definition includes:
      #
      # - `name`: Name of the tool.
      # - `description`: Optional, but strongly-recommended description of the tool.
      # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
      #   tool `input` shape that the model will produce in `tool_use` output content
      #   blocks.
      #
      # For example, if you defined `tools` as:
      #
      # ```json
      # [
      #   {
      #     "name": "get_stock_price",
      #     "description": "Get the current stock price for a given ticker symbol.",
      #     "input_schema": {
      #       "type": "object",
      #       "properties": {
      #         "ticker": {
      #           "type": "string",
      #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
      #         }
      #       },
      #       "required": ["ticker"]
      #     }
      #   }
      # ]
      # ```
      #
      # And then asked the model "What's the S&P 500 at today?", the model might produce
      # `tool_use` content blocks in the response like this:
      #
      # ```json
      # [
      #   {
      #     "type": "tool_use",
      #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
      #     "name": "get_stock_price",
      #     "input": { "ticker": "^GSPC" }
      #   }
      # ]
      # ```
      #
      # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
      # input, and return the following back to the model in a subsequent `user`
      # message:
      #
      # ```json
      # [
      #   {
      #     "type": "tool_result",
      #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
      #     "content": "259.75 USD"
      #   }
      # ]
      # ```
      #
      # Tools can be used for workflows that include running client-side tools and
      # functions, or more generally whenever you want the model to produce a particular
      # JSON structure of output.
      #
      # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
      sig do
        returns(T.nilable(
            T::Array[
              T.any(
                Anthropic::Tool,
                Anthropic::ToolBash20250124,
                Anthropic::ToolTextEditor20250124,
                Anthropic::ToolTextEditor20250429,
                Anthropic::ToolTextEditor20250728,
                Anthropic::WebSearchTool20250305
              )
            ]
          ))
      end
      attr_reader :tools

      sig do
        params(
          tools: T::Array[
              T.any(
                Anthropic::Tool::OrHash,
                Anthropic::ToolBash20250124::OrHash,
                Anthropic::ToolTextEditor20250124::OrHash,
                Anthropic::ToolTextEditor20250429::OrHash,
                Anthropic::ToolTextEditor20250728::OrHash,
                Anthropic::WebSearchTool20250305::OrHash
              )
            ]
        ).void
      end
      attr_writer :tools

      # Only sample from the top K options for each subsequent token.
      #
      # Used to remove "long tail" low probability responses.
      # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
      #
      # Recommended for advanced use cases only. You usually only need to use
      # `temperature`.
      sig { returns(T.nilable(Integer)) }
      attr_reader :top_k

      sig { params(top_k: Integer).void }
      attr_writer :top_k

      # Use nucleus sampling.
      #
      # In nucleus sampling, we compute the cumulative distribution over all the options
      # for each subsequent token in decreasing probability order and cut it off once it
      # reaches a particular probability specified by `top_p`. You should either alter
      # `temperature` or `top_p`, but not both.
      #
      # Recommended for advanced use cases only. You usually only need to use
      # `temperature`.
      sig { returns(T.nilable(Float)) }
      attr_reader :top_p

      sig { params(top_p: Float).void }
      attr_writer :top_p

      sig do
        override
          .returns({
            max_tokens: Integer,
            messages: T::Array[Anthropic::MessageParam],
            model: T.any(Anthropic::Model::OrSymbol, String),
            metadata: Anthropic::Metadata,
            service_tier: Anthropic::MessageCreateParams::ServiceTier::OrSymbol,
            stop_sequences: T::Array[String],
            system_: Anthropic::MessageCreateParams::System::Variants,
            temperature: Float,
            thinking:
              T.any(
                Anthropic::ThinkingConfigEnabled,
                Anthropic::ThinkingConfigDisabled
              ),
            tool_choice:
              T.any(
                Anthropic::ToolChoiceAuto,
                Anthropic::ToolChoiceAny,
                Anthropic::ToolChoiceTool,
                Anthropic::ToolChoiceNone
              ),
            tools:
              T::Array[
                T.any(
                  Anthropic::Tool,
                  Anthropic::ToolBash20250124,
                  Anthropic::ToolTextEditor20250124,
                  Anthropic::ToolTextEditor20250429,
                  Anthropic::ToolTextEditor20250728,
                  Anthropic::WebSearchTool20250305
                )
              ],
            top_k: Integer,
            top_p: Float,
            request_options: Anthropic::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            max_tokens: Integer,
            messages: T::Array[Anthropic::MessageParam::OrHash],
            model: T.any(Anthropic::Model::OrSymbol, String),
            metadata: Anthropic::Metadata::OrHash,
            service_tier: Anthropic::MessageCreateParams::ServiceTier::OrSymbol,
            stop_sequences: T::Array[String],
            system_: Anthropic::MessageCreateParams::System::Variants,
            temperature: Float,
            thinking: T.any(
              Anthropic::ThinkingConfigEnabled::OrHash,
              Anthropic::ThinkingConfigDisabled::OrHash
            ),
            tool_choice: T.any(
              Anthropic::ToolChoiceAuto::OrHash,
              Anthropic::ToolChoiceAny::OrHash,
              Anthropic::ToolChoiceTool::OrHash,
              Anthropic::ToolChoiceNone::OrHash
            ),
            tools: T::Array[
              T.any(
                Anthropic::Tool::OrHash,
                Anthropic::ToolBash20250124::OrHash,
                Anthropic::ToolTextEditor20250124::OrHash,
                Anthropic::ToolTextEditor20250429::OrHash,
                Anthropic::ToolTextEditor20250728::OrHash,
                Anthropic::WebSearchTool20250305::OrHash
              )
            ],
            top_k: Integer,
            top_p: Float,
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          max_tokens:, # The maximum number of tokens to generate before stopping.
                       # Note that our models may stop _before_ reaching this maximum. This parameter
                       # only specifies the absolute maximum number of tokens to generate.
                       # Different models have different maximum values for this parameter. See
                       # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
          messages:, # Input messages.
                     # Our models are trained to operate on alternating `user` and `assistant`
                     # conversational turns. When creating a new `Message`, you specify the prior
                     # conversational turns with the `messages` parameter, and the model then generates
                     # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                     # in your request will be combined into a single turn.
                     # Each input message must be an object with a `role` and `content`. You can
                     # specify a single `user`-role message, or you can include multiple `user` and
                     # `assistant` messages.
                     # If the final message uses the `assistant` role, the response content will
                     # continue immediately from the content in that message. This can be used to
                     # constrain part of the model's response.
                     # Example with a single `user` message:
                     # ```json
                     # [{ "role": "user", "content": "Hello, Claude" }]
                     # ```
                     # Example with multiple conversational turns:
                     # ```json
                     # [
                     #   { "role": "user", "content": "Hello there." },
                     #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                     #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                     # ]
                     # ```
                     # Example with a partially-filled response from Claude:
                     # ```json
                     # [
                     #   {
                     #     "role": "user",
                     #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                     #   },
                     #   { "role": "assistant", "content": "The best answer is (" }
                     # ]
                     # ```
                     # Each input message `content` may be either a single `string` or an array of
                     # content blocks, where each block has a specific `type`. Using a `string` for
                     # `content` is shorthand for an array of one content block of type `"text"`. The
                     # following input messages are equivalent:
                     # ```json
                     # { "role": "user", "content": "Hello, Claude" }
                     # ```
                     # ```json
                     # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                     # ```
                     # Starting with Claude 3 models, you can also send image content blocks:
                     # ```json
                     # {
                     #   "role": "user",
                     #   "content": [
                     #     {
                     #       "type": "image",
                     #       "source": {
                     #         "type": "base64",
                     #         "media_type": "image/jpeg",
                     #         "data": "/9j/4AAQSkZJRg..."
                     #       }
                     #     },
                     #     { "type": "text", "text": "What is in this image?" }
                     #   ]
                     # }
                     # ```
                     # We currently support the `base64` source type for images, and the `image/jpeg`,
                     # `image/png`, `image/gif`, and `image/webp` media types.
                     # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                     # more input examples.
                     # Note that if you want to include a
                     # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                     # the top-level `system` parameter  there is no `"system"` role for input
                     # messages in the Messages API.
                     # There is a limit of 100,000 messages in a single request.
          model:, # The model that will complete your prompt.\n\nSee
                  # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                  # details and options.
          metadata: nil, # An object describing metadata about the request.
          service_tier: nil, # Determines whether to use priority capacity (if available) or standard capacity
                             # for this request.
                             # Anthropic offers different levels of service for your API requests. See
                             # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
          stop_sequences: nil, # Custom text sequences that will cause the model to stop generating.
                               # Our models will normally stop when they have naturally completed their turn,
                               # which will result in a response `stop_reason` of `"end_turn"`.
                               # If you want the model to stop generating when it encounters custom strings of
                               # text, you can use the `stop_sequences` parameter. If the model encounters one of
                               # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                               # and the response `stop_sequence` value will contain the matched stop sequence.
          system_: nil, # System prompt.
                        # A system prompt is a way of providing context and instructions to Claude, such
                        # as specifying a particular goal or role. See our
                        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
          temperature: nil, # Amount of randomness injected into the response.
                            # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                            # for analytical / multiple choice, and closer to `1.0` for creative and
                            # generative tasks.
                            # Note that even with `temperature` of `0.0`, the results will not be fully
                            # deterministic.
          thinking: nil, # Configuration for enabling Claude's extended thinking.
                         # When enabled, responses include `thinking` content blocks showing Claude's
                         # thinking process before the final answer. Requires a minimum budget of 1,024
                         # tokens and counts towards your `max_tokens` limit.
                         # See
                         # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                         # for details.
          tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                            # any available tool, decide by itself, or not use tools at all.
          tools: nil, # Definitions of tools that the model may use.
                      # If you include `tools` in your API request, the model may return `tool_use`
                      # content blocks that represent the model's use of those tools. You can then run
                      # those tools using the tool input generated by the model and then optionally
                      # return results back to the model using `tool_result` content blocks.
                      # There are two types of tools: **client tools** and **server tools**. The
                      # behavior described below applies to client tools. For
                      # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                      # see their individual documentation as each has its own behavior (e.g., the
                      # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                      # Each tool definition includes:
                      # - `name`: Name of the tool.
                      # - `description`: Optional, but strongly-recommended description of the tool.
                      # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                      #   tool `input` shape that the model will produce in `tool_use` output content
                      #   blocks.
                      # For example, if you defined `tools` as:
                      # ```json
                      # [
                      #   {
                      #     "name": "get_stock_price",
                      #     "description": "Get the current stock price for a given ticker symbol.",
                      #     "input_schema": {
                      #       "type": "object",
                      #       "properties": {
                      #         "ticker": {
                      #           "type": "string",
                      #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                      #         }
                      #       },
                      #       "required": ["ticker"]
                      #     }
                      #   }
                      # ]
                      # ```
                      # And then asked the model "What's the S&P 500 at today?", the model might produce
                      # `tool_use` content blocks in the response like this:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_use",
                      #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "name": "get_stock_price",
                      #     "input": { "ticker": "^GSPC" }
                      #   }
                      # ]
                      # ```
                      # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                      # input, and return the following back to the model in a subsequent `user`
                      # message:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_result",
                      #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "content": "259.75 USD"
                      #   }
                      # ]
                      # ```
                      # Tools can be used for workflows that include running client-side tools and
                      # functions, or more generally whenever you want the model to produce a particular
                      # JSON structure of output.
                      # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
          top_k: nil, # Only sample from the top K options for each subsequent token.
                      # Used to remove "long tail" low probability responses.
                      # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                      # Recommended for advanced use cases only. You usually only need to use
                      # `temperature`.
          top_p: nil, # Use nucleus sampling.
                      # In nucleus sampling, we compute the cumulative distribution over all the options
                      # for each subsequent token in decreasing probability order and cut it off once it
                      # reaches a particular probability specified by `top_p`. You should either alter
                      # `temperature` or `top_p`, but not both.
                      # Recommended for advanced use cases only. You usually only need to use
                      # `temperature`.
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::MessageCreateParams, Anthropic::Internal::AnyHash)
        end

      # Determines whether to use priority capacity (if available) or standard capacity
      # for this request.
      #
      # Anthropic offers different levels of service for your API requests. See
      # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
      module ServiceTier
        extend Anthropic::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Anthropic::MessageCreateParams::ServiceTier::TaggedSymbol]) }
          def values; end
        end

        AUTO = T.let(
            :auto,
            Anthropic::MessageCreateParams::ServiceTier::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        STANDARD_ONLY = T.let(
            :standard_only,
            Anthropic::MessageCreateParams::ServiceTier::TaggedSymbol
          )

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Anthropic::MessageCreateParams::ServiceTier)
          end
      end

      # System prompt.
      #
      # A system prompt is a way of providing context and instructions to Claude, such
      # as specifying a particular goal or role. See our
      # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
      module System
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::MessageCreateParams::System::Variants]) }
          def variants; end
        end

        TextBlockParamArray = T.let(
            Anthropic::Internal::Type::ArrayOf[Anthropic::TextBlockParam],
            Anthropic::Internal::Type::Converter
          )

        Variants = T.type_alias { T.any(String, T::Array[Anthropic::TextBlockParam]) }
      end
    end

    class MessageDeltaUsage < Anthropic::Internal::Type::BaseModel
      # The cumulative number of input tokens used to create the cache entry.
      sig { returns(T.nilable(Integer)) }
      attr_accessor :cache_creation_input_tokens

      # The cumulative number of input tokens read from the cache.
      sig { returns(T.nilable(Integer)) }
      attr_accessor :cache_read_input_tokens

      # The cumulative number of input tokens which were used.
      sig { returns(T.nilable(Integer)) }
      attr_accessor :input_tokens

      # The cumulative number of output tokens which were used.
      sig { returns(Integer) }
      attr_accessor :output_tokens

      # The number of server tool requests.
      sig { returns(T.nilable(Anthropic::ServerToolUsage)) }
      attr_reader :server_tool_use

      sig { params(server_tool_use: T.nilable(Anthropic::ServerToolUsage::OrHash)).void }
      attr_writer :server_tool_use

      sig do
        override
          .returns({
            cache_creation_input_tokens: T.nilable(Integer),
            cache_read_input_tokens: T.nilable(Integer),
            input_tokens: T.nilable(Integer),
            output_tokens: Integer,
            server_tool_use: T.nilable(Anthropic::ServerToolUsage)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cache_creation_input_tokens: T.nilable(Integer),
            cache_read_input_tokens: T.nilable(Integer),
            input_tokens: T.nilable(Integer),
            output_tokens: Integer,
            server_tool_use: T.nilable(Anthropic::ServerToolUsage::OrHash)
          ).returns(T.attached_class)
        end
        def new(
          cache_creation_input_tokens:, # The cumulative number of input tokens used to create the cache entry.
          cache_read_input_tokens:, # The cumulative number of input tokens read from the cache.
          input_tokens:, # The cumulative number of input tokens which were used.
          output_tokens:, # The cumulative number of output tokens which were used.
          server_tool_use: # The number of server tool requests.
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::MessageDeltaUsage, Anthropic::Internal::AnyHash)
        end
    end

    class MessageParam < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::MessageParam::Content::Variants) }
      attr_accessor :content

      sig { returns(Anthropic::MessageParam::Role::OrSymbol) }
      attr_accessor :role

      sig do
        override
          .returns({
            content: Anthropic::MessageParam::Content::Variants,
            role: Anthropic::MessageParam::Role::OrSymbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            content: Anthropic::MessageParam::Content::Variants,
            role: Anthropic::MessageParam::Role::OrSymbol
          ).returns(T.attached_class)
        end
        def new(content:, role:); end
      end

      module Content
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::MessageParam::Content::Variants]) }
          def variants; end
        end

        ContentBlockParamArray = T.let(
            Anthropic::Internal::Type::ArrayOf[
              union: Anthropic::ContentBlockParam
            ],
            Anthropic::Internal::Type::Converter
          )

        Variants = T.type_alias do
            T.any(String, T::Array[Anthropic::ContentBlockParam::Variants])
          end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::MessageParam, Anthropic::Internal::AnyHash)
        end

      module Role
        extend Anthropic::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Anthropic::MessageParam::Role::TaggedSymbol]) }
          def values; end
        end

        ASSISTANT = T.let(:assistant, Anthropic::MessageParam::Role::TaggedSymbol)

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::MessageParam::Role) }

        USER = T.let(:user, Anthropic::MessageParam::Role::TaggedSymbol)
      end
    end

    class MessageTokensCount < Anthropic::Internal::Type::BaseModel
      # The total number of tokens across the provided list of messages, system prompt,
      # and tools.
      sig { returns(Integer) }
      attr_accessor :input_tokens

      sig { override.returns({ input_tokens: Integer }) }
      def to_hash; end

      class << self
        sig { params(input_tokens: Integer).returns(T.attached_class) }
        def new(
          input_tokens: # The total number of tokens across the provided list of messages, system prompt,
                        # and tools.
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::MessageTokensCount, Anthropic::Internal::AnyHash)
        end
    end

    module Messages
      class BatchCancelParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        sig { override.returns({ request_options: Anthropic::RequestOptions }) }
        def to_hash; end

        class << self
          sig { params(request_options: Anthropic::RequestOptions::OrHash).returns(T.attached_class) }
          def new(request_options: {}); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::BatchCancelParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BatchCreateParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # List of requests for prompt completion. Each is an individual request to create
        # a Message.
        sig { returns(T::Array[Anthropic::Messages::BatchCreateParams::Request]) }
        attr_accessor :requests

        sig do
          override
            .returns({
              requests:
                T::Array[Anthropic::Messages::BatchCreateParams::Request],
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              requests: T::Array[Anthropic::Messages::BatchCreateParams::Request::OrHash],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            requests:, # List of requests for prompt completion. Each is an individual request to create
                       # a Message.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::BatchCreateParams,
              Anthropic::Internal::AnyHash
            )
          end

        class Request < Anthropic::Internal::Type::BaseModel
          # Developer-provided ID created for each request in a Message Batch. Useful for
          # matching results to requests, as results may be given out of request order.
          #
          # Must be unique for each request within the Message Batch.
          sig { returns(String) }
          attr_accessor :custom_id

          # Messages API creation parameters for the individual request.
          #
          # See the [Messages API reference](/en/api/messages) for full documentation on
          # available parameters.
          sig { returns(Anthropic::Messages::BatchCreateParams::Request::Params) }
          attr_reader :params

          sig { params(params: Anthropic::Messages::BatchCreateParams::Request::Params::OrHash).void }
          attr_writer :params

          sig do
            override
              .returns({
                custom_id: String,
                params: Anthropic::Messages::BatchCreateParams::Request::Params
              })
          end
          def to_hash; end

          class << self
            sig do
              params(
                custom_id: String,
                params: Anthropic::Messages::BatchCreateParams::Request::Params::OrHash
              ).returns(T.attached_class)
            end
            def new(
              custom_id:, # Developer-provided ID created for each request in a Message Batch. Useful for
                          # matching results to requests, as results may be given out of request order.
                          # Must be unique for each request within the Message Batch.
              params: # Messages API creation parameters for the individual request.
                      # See the [Messages API reference](/en/api/messages) for full documentation on
                      # available parameters.
); end
          end

          OrHash = T.type_alias do
              T.any(
                Anthropic::Messages::BatchCreateParams::Request,
                Anthropic::Internal::AnyHash
              )
            end

          class Params < Anthropic::Internal::Type::BaseModel
            # The maximum number of tokens to generate before stopping.
            #
            # Note that our models may stop _before_ reaching this maximum. This parameter
            # only specifies the absolute maximum number of tokens to generate.
            #
            # Different models have different maximum values for this parameter. See
            # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
            sig { returns(Integer) }
            attr_accessor :max_tokens

            # Input messages.
            #
            # Our models are trained to operate on alternating `user` and `assistant`
            # conversational turns. When creating a new `Message`, you specify the prior
            # conversational turns with the `messages` parameter, and the model then generates
            # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
            # in your request will be combined into a single turn.
            #
            # Each input message must be an object with a `role` and `content`. You can
            # specify a single `user`-role message, or you can include multiple `user` and
            # `assistant` messages.
            #
            # If the final message uses the `assistant` role, the response content will
            # continue immediately from the content in that message. This can be used to
            # constrain part of the model's response.
            #
            # Example with a single `user` message:
            #
            # ```json
            # [{ "role": "user", "content": "Hello, Claude" }]
            # ```
            #
            # Example with multiple conversational turns:
            #
            # ```json
            # [
            #   { "role": "user", "content": "Hello there." },
            #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
            #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
            # ]
            # ```
            #
            # Example with a partially-filled response from Claude:
            #
            # ```json
            # [
            #   {
            #     "role": "user",
            #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
            #   },
            #   { "role": "assistant", "content": "The best answer is (" }
            # ]
            # ```
            #
            # Each input message `content` may be either a single `string` or an array of
            # content blocks, where each block has a specific `type`. Using a `string` for
            # `content` is shorthand for an array of one content block of type `"text"`. The
            # following input messages are equivalent:
            #
            # ```json
            # { "role": "user", "content": "Hello, Claude" }
            # ```
            #
            # ```json
            # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
            # ```
            #
            # Starting with Claude 3 models, you can also send image content blocks:
            #
            # ```json
            # {
            #   "role": "user",
            #   "content": [
            #     {
            #       "type": "image",
            #       "source": {
            #         "type": "base64",
            #         "media_type": "image/jpeg",
            #         "data": "/9j/4AAQSkZJRg..."
            #       }
            #     },
            #     { "type": "text", "text": "What is in this image?" }
            #   ]
            # }
            # ```
            #
            # We currently support the `base64` source type for images, and the `image/jpeg`,
            # `image/png`, `image/gif`, and `image/webp` media types.
            #
            # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
            # more input examples.
            #
            # Note that if you want to include a
            # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
            # the top-level `system` parameter  there is no `"system"` role for input
            # messages in the Messages API.
            #
            # There is a limit of 100,000 messages in a single request.
            sig { returns(T::Array[Anthropic::MessageParam]) }
            attr_accessor :messages

            # An object describing metadata about the request.
            sig { returns(T.nilable(Anthropic::Metadata)) }
            attr_reader :metadata

            sig { params(metadata: Anthropic::Metadata::OrHash).void }
            attr_writer :metadata

            # The model that will complete your prompt.\n\nSee
            # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
            # details and options.
            sig { returns(T.any(Anthropic::Model::OrSymbol, String)) }
            attr_accessor :model

            # Determines whether to use priority capacity (if available) or standard capacity
            # for this request.
            #
            # Anthropic offers different levels of service for your API requests. See
            # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
            sig do
              returns(T.nilable(
                  Anthropic::Messages::BatchCreateParams::Request::Params::ServiceTier::OrSymbol
                ))
            end
            attr_reader :service_tier

            sig do
              params(
                service_tier: Anthropic::Messages::BatchCreateParams::Request::Params::ServiceTier::OrSymbol
              ).void
            end
            attr_writer :service_tier

            # Custom text sequences that will cause the model to stop generating.
            #
            # Our models will normally stop when they have naturally completed their turn,
            # which will result in a response `stop_reason` of `"end_turn"`.
            #
            # If you want the model to stop generating when it encounters custom strings of
            # text, you can use the `stop_sequences` parameter. If the model encounters one of
            # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
            # and the response `stop_sequence` value will contain the matched stop sequence.
            sig { returns(T.nilable(T::Array[String])) }
            attr_reader :stop_sequences

            sig { params(stop_sequences: T::Array[String]).void }
            attr_writer :stop_sequences

            # Whether to incrementally stream the response using server-sent events.
            #
            # See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
            # details.
            sig { returns(T.nilable(T::Boolean)) }
            attr_reader :stream

            sig { params(stream: T::Boolean).void }
            attr_writer :stream

            # System prompt.
            #
            # A system prompt is a way of providing context and instructions to Claude, such
            # as specifying a particular goal or role. See our
            # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
            sig do
              returns(T.nilable(
                  Anthropic::Messages::BatchCreateParams::Request::Params::System::Variants
                ))
            end
            attr_reader :system_

            sig { params(system_: Anthropic::Messages::BatchCreateParams::Request::Params::System::Variants).void }
            attr_writer :system_

            # Amount of randomness injected into the response.
            #
            # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
            # for analytical / multiple choice, and closer to `1.0` for creative and
            # generative tasks.
            #
            # Note that even with `temperature` of `0.0`, the results will not be fully
            # deterministic.
            sig { returns(T.nilable(Float)) }
            attr_reader :temperature

            sig { params(temperature: Float).void }
            attr_writer :temperature

            # Configuration for enabling Claude's extended thinking.
            #
            # When enabled, responses include `thinking` content blocks showing Claude's
            # thinking process before the final answer. Requires a minimum budget of 1,024
            # tokens and counts towards your `max_tokens` limit.
            #
            # See
            # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
            # for details.
            sig do
              returns(T.nilable(
                  T.any(
                    Anthropic::ThinkingConfigEnabled,
                    Anthropic::ThinkingConfigDisabled
                  )
                ))
            end
            attr_reader :thinking

            sig do
              params(
                thinking: T.any(
                    Anthropic::ThinkingConfigEnabled::OrHash,
                    Anthropic::ThinkingConfigDisabled::OrHash
                  )
              ).void
            end
            attr_writer :thinking

            # How the model should use the provided tools. The model can use a specific tool,
            # any available tool, decide by itself, or not use tools at all.
            sig do
              returns(T.nilable(
                  T.any(
                    Anthropic::ToolChoiceAuto,
                    Anthropic::ToolChoiceAny,
                    Anthropic::ToolChoiceTool,
                    Anthropic::ToolChoiceNone
                  )
                ))
            end
            attr_reader :tool_choice

            sig do
              params(
                tool_choice: T.any(
                    Anthropic::ToolChoiceAuto::OrHash,
                    Anthropic::ToolChoiceAny::OrHash,
                    Anthropic::ToolChoiceTool::OrHash,
                    Anthropic::ToolChoiceNone::OrHash
                  )
              ).void
            end
            attr_writer :tool_choice

            # Definitions of tools that the model may use.
            #
            # If you include `tools` in your API request, the model may return `tool_use`
            # content blocks that represent the model's use of those tools. You can then run
            # those tools using the tool input generated by the model and then optionally
            # return results back to the model using `tool_result` content blocks.
            #
            # There are two types of tools: **client tools** and **server tools**. The
            # behavior described below applies to client tools. For
            # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
            # see their individual documentation as each has its own behavior (e.g., the
            # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
            #
            # Each tool definition includes:
            #
            # - `name`: Name of the tool.
            # - `description`: Optional, but strongly-recommended description of the tool.
            # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
            #   tool `input` shape that the model will produce in `tool_use` output content
            #   blocks.
            #
            # For example, if you defined `tools` as:
            #
            # ```json
            # [
            #   {
            #     "name": "get_stock_price",
            #     "description": "Get the current stock price for a given ticker symbol.",
            #     "input_schema": {
            #       "type": "object",
            #       "properties": {
            #         "ticker": {
            #           "type": "string",
            #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
            #         }
            #       },
            #       "required": ["ticker"]
            #     }
            #   }
            # ]
            # ```
            #
            # And then asked the model "What's the S&P 500 at today?", the model might produce
            # `tool_use` content blocks in the response like this:
            #
            # ```json
            # [
            #   {
            #     "type": "tool_use",
            #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
            #     "name": "get_stock_price",
            #     "input": { "ticker": "^GSPC" }
            #   }
            # ]
            # ```
            #
            # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
            # input, and return the following back to the model in a subsequent `user`
            # message:
            #
            # ```json
            # [
            #   {
            #     "type": "tool_result",
            #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
            #     "content": "259.75 USD"
            #   }
            # ]
            # ```
            #
            # Tools can be used for workflows that include running client-side tools and
            # functions, or more generally whenever you want the model to produce a particular
            # JSON structure of output.
            #
            # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
            sig do
              returns(T.nilable(
                  T::Array[
                    T.any(
                      Anthropic::Tool,
                      Anthropic::ToolBash20250124,
                      Anthropic::ToolTextEditor20250124,
                      Anthropic::ToolTextEditor20250429,
                      Anthropic::ToolTextEditor20250728,
                      Anthropic::WebSearchTool20250305
                    )
                  ]
                ))
            end
            attr_reader :tools

            sig do
              params(
                tools: T::Array[
                    T.any(
                      Anthropic::Tool::OrHash,
                      Anthropic::ToolBash20250124::OrHash,
                      Anthropic::ToolTextEditor20250124::OrHash,
                      Anthropic::ToolTextEditor20250429::OrHash,
                      Anthropic::ToolTextEditor20250728::OrHash,
                      Anthropic::WebSearchTool20250305::OrHash
                    )
                  ]
              ).void
            end
            attr_writer :tools

            # Only sample from the top K options for each subsequent token.
            #
            # Used to remove "long tail" low probability responses.
            # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
            #
            # Recommended for advanced use cases only. You usually only need to use
            # `temperature`.
            sig { returns(T.nilable(Integer)) }
            attr_reader :top_k

            sig { params(top_k: Integer).void }
            attr_writer :top_k

            # Use nucleus sampling.
            #
            # In nucleus sampling, we compute the cumulative distribution over all the options
            # for each subsequent token in decreasing probability order and cut it off once it
            # reaches a particular probability specified by `top_p`. You should either alter
            # `temperature` or `top_p`, but not both.
            #
            # Recommended for advanced use cases only. You usually only need to use
            # `temperature`.
            sig { returns(T.nilable(Float)) }
            attr_reader :top_p

            sig { params(top_p: Float).void }
            attr_writer :top_p

            sig do
              override
                .returns({
                  max_tokens: Integer,
                  messages: T::Array[Anthropic::MessageParam],
                  model: T.any(Anthropic::Model::OrSymbol, String),
                  metadata: Anthropic::Metadata,
                  service_tier:
                    Anthropic::Messages::BatchCreateParams::Request::Params::ServiceTier::OrSymbol,
                  stop_sequences: T::Array[String],
                  stream: T::Boolean,
                  system_:
                    Anthropic::Messages::BatchCreateParams::Request::Params::System::Variants,
                  temperature: Float,
                  thinking:
                    T.any(
                      Anthropic::ThinkingConfigEnabled,
                      Anthropic::ThinkingConfigDisabled
                    ),
                  tool_choice:
                    T.any(
                      Anthropic::ToolChoiceAuto,
                      Anthropic::ToolChoiceAny,
                      Anthropic::ToolChoiceTool,
                      Anthropic::ToolChoiceNone
                    ),
                  tools:
                    T::Array[
                      T.any(
                        Anthropic::Tool,
                        Anthropic::ToolBash20250124,
                        Anthropic::ToolTextEditor20250124,
                        Anthropic::ToolTextEditor20250429,
                        Anthropic::ToolTextEditor20250728,
                        Anthropic::WebSearchTool20250305
                      )
                    ],
                  top_k: Integer,
                  top_p: Float
                })
            end
            def to_hash; end

            class << self
              # Messages API creation parameters for the individual request.
              #
              # See the [Messages API reference](/en/api/messages) for full documentation on
              # available parameters.
              sig do
                params(
                  max_tokens: Integer,
                  messages: T::Array[Anthropic::MessageParam::OrHash],
                  model: T.any(Anthropic::Model::OrSymbol, String),
                  metadata: Anthropic::Metadata::OrHash,
                  service_tier: Anthropic::Messages::BatchCreateParams::Request::Params::ServiceTier::OrSymbol,
                  stop_sequences: T::Array[String],
                  stream: T::Boolean,
                  system_: Anthropic::Messages::BatchCreateParams::Request::Params::System::Variants,
                  temperature: Float,
                  thinking: T.any(
                    Anthropic::ThinkingConfigEnabled::OrHash,
                    Anthropic::ThinkingConfigDisabled::OrHash
                  ),
                  tool_choice: T.any(
                    Anthropic::ToolChoiceAuto::OrHash,
                    Anthropic::ToolChoiceAny::OrHash,
                    Anthropic::ToolChoiceTool::OrHash,
                    Anthropic::ToolChoiceNone::OrHash
                  ),
                  tools: T::Array[
                    T.any(
                      Anthropic::Tool::OrHash,
                      Anthropic::ToolBash20250124::OrHash,
                      Anthropic::ToolTextEditor20250124::OrHash,
                      Anthropic::ToolTextEditor20250429::OrHash,
                      Anthropic::ToolTextEditor20250728::OrHash,
                      Anthropic::WebSearchTool20250305::OrHash
                    )
                  ],
                  top_k: Integer,
                  top_p: Float
                ).returns(T.attached_class)
              end
              def new(
                max_tokens:, # The maximum number of tokens to generate before stopping.
                             # Note that our models may stop _before_ reaching this maximum. This parameter
                             # only specifies the absolute maximum number of tokens to generate.
                             # Different models have different maximum values for this parameter. See
                             # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
                messages:, # Input messages.
                           # Our models are trained to operate on alternating `user` and `assistant`
                           # conversational turns. When creating a new `Message`, you specify the prior
                           # conversational turns with the `messages` parameter, and the model then generates
                           # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                           # in your request will be combined into a single turn.
                           # Each input message must be an object with a `role` and `content`. You can
                           # specify a single `user`-role message, or you can include multiple `user` and
                           # `assistant` messages.
                           # If the final message uses the `assistant` role, the response content will
                           # continue immediately from the content in that message. This can be used to
                           # constrain part of the model's response.
                           # Example with a single `user` message:
                           # ```json
                           # [{ "role": "user", "content": "Hello, Claude" }]
                           # ```
                           # Example with multiple conversational turns:
                           # ```json
                           # [
                           #   { "role": "user", "content": "Hello there." },
                           #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                           #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                           # ]
                           # ```
                           # Example with a partially-filled response from Claude:
                           # ```json
                           # [
                           #   {
                           #     "role": "user",
                           #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                           #   },
                           #   { "role": "assistant", "content": "The best answer is (" }
                           # ]
                           # ```
                           # Each input message `content` may be either a single `string` or an array of
                           # content blocks, where each block has a specific `type`. Using a `string` for
                           # `content` is shorthand for an array of one content block of type `"text"`. The
                           # following input messages are equivalent:
                           # ```json
                           # { "role": "user", "content": "Hello, Claude" }
                           # ```
                           # ```json
                           # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                           # ```
                           # Starting with Claude 3 models, you can also send image content blocks:
                           # ```json
                           # {
                           #   "role": "user",
                           #   "content": [
                           #     {
                           #       "type": "image",
                           #       "source": {
                           #         "type": "base64",
                           #         "media_type": "image/jpeg",
                           #         "data": "/9j/4AAQSkZJRg..."
                           #       }
                           #     },
                           #     { "type": "text", "text": "What is in this image?" }
                           #   ]
                           # }
                           # ```
                           # We currently support the `base64` source type for images, and the `image/jpeg`,
                           # `image/png`, `image/gif`, and `image/webp` media types.
                           # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                           # more input examples.
                           # Note that if you want to include a
                           # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                           # the top-level `system` parameter  there is no `"system"` role for input
                           # messages in the Messages API.
                           # There is a limit of 100,000 messages in a single request.
                model:, # The model that will complete your prompt.\n\nSee
                        # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                        # details and options.
                metadata: nil, # An object describing metadata about the request.
                service_tier: nil, # Determines whether to use priority capacity (if available) or standard capacity
                                   # for this request.
                                   # Anthropic offers different levels of service for your API requests. See
                                   # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
                stop_sequences: nil, # Custom text sequences that will cause the model to stop generating.
                                     # Our models will normally stop when they have naturally completed their turn,
                                     # which will result in a response `stop_reason` of `"end_turn"`.
                                     # If you want the model to stop generating when it encounters custom strings of
                                     # text, you can use the `stop_sequences` parameter. If the model encounters one of
                                     # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                                     # and the response `stop_sequence` value will contain the matched stop sequence.
                stream: nil, # Whether to incrementally stream the response using server-sent events.
                             # See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for
                             # details.
                system_: nil, # System prompt.
                              # A system prompt is a way of providing context and instructions to Claude, such
                              # as specifying a particular goal or role. See our
                              # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
                temperature: nil, # Amount of randomness injected into the response.
                                  # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                                  # for analytical / multiple choice, and closer to `1.0` for creative and
                                  # generative tasks.
                                  # Note that even with `temperature` of `0.0`, the results will not be fully
                                  # deterministic.
                thinking: nil, # Configuration for enabling Claude's extended thinking.
                               # When enabled, responses include `thinking` content blocks showing Claude's
                               # thinking process before the final answer. Requires a minimum budget of 1,024
                               # tokens and counts towards your `max_tokens` limit.
                               # See
                               # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                               # for details.
                tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                                  # any available tool, decide by itself, or not use tools at all.
                tools: nil, # Definitions of tools that the model may use.
                            # If you include `tools` in your API request, the model may return `tool_use`
                            # content blocks that represent the model's use of those tools. You can then run
                            # those tools using the tool input generated by the model and then optionally
                            # return results back to the model using `tool_result` content blocks.
                            # There are two types of tools: **client tools** and **server tools**. The
                            # behavior described below applies to client tools. For
                            # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                            # see their individual documentation as each has its own behavior (e.g., the
                            # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                            # Each tool definition includes:
                            # - `name`: Name of the tool.
                            # - `description`: Optional, but strongly-recommended description of the tool.
                            # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                            #   tool `input` shape that the model will produce in `tool_use` output content
                            #   blocks.
                            # For example, if you defined `tools` as:
                            # ```json
                            # [
                            #   {
                            #     "name": "get_stock_price",
                            #     "description": "Get the current stock price for a given ticker symbol.",
                            #     "input_schema": {
                            #       "type": "object",
                            #       "properties": {
                            #         "ticker": {
                            #           "type": "string",
                            #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                            #         }
                            #       },
                            #       "required": ["ticker"]
                            #     }
                            #   }
                            # ]
                            # ```
                            # And then asked the model "What's the S&P 500 at today?", the model might produce
                            # `tool_use` content blocks in the response like this:
                            # ```json
                            # [
                            #   {
                            #     "type": "tool_use",
                            #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                            #     "name": "get_stock_price",
                            #     "input": { "ticker": "^GSPC" }
                            #   }
                            # ]
                            # ```
                            # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                            # input, and return the following back to the model in a subsequent `user`
                            # message:
                            # ```json
                            # [
                            #   {
                            #     "type": "tool_result",
                            #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                            #     "content": "259.75 USD"
                            #   }
                            # ]
                            # ```
                            # Tools can be used for workflows that include running client-side tools and
                            # functions, or more generally whenever you want the model to produce a particular
                            # JSON structure of output.
                            # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
                top_k: nil, # Only sample from the top K options for each subsequent token.
                            # Used to remove "long tail" low probability responses.
                            # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                            # Recommended for advanced use cases only. You usually only need to use
                            # `temperature`.
                top_p: nil # Use nucleus sampling.
                           # In nucleus sampling, we compute the cumulative distribution over all the options
                           # for each subsequent token in decreasing probability order and cut it off once it
                           # reaches a particular probability specified by `top_p`. You should either alter
                           # `temperature` or `top_p`, but not both.
                           # Recommended for advanced use cases only. You usually only need to use
                           # `temperature`.
); end
            end

            OrHash = T.type_alias do
                T.any(
                  Anthropic::Messages::BatchCreateParams::Request::Params,
                  Anthropic::Internal::AnyHash
                )
              end

            # Determines whether to use priority capacity (if available) or standard capacity
            # for this request.
            #
            # Anthropic offers different levels of service for your API requests. See
            # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
            module ServiceTier
              extend Anthropic::Internal::Type::Enum

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Anthropic::Messages::BatchCreateParams::Request::Params::ServiceTier::TaggedSymbol
                  ])
                end
                def values; end
              end

              AUTO = T.let(
                  :auto,
                  Anthropic::Messages::BatchCreateParams::Request::Params::ServiceTier::TaggedSymbol
                )

              OrSymbol = T.type_alias { T.any(Symbol, String) }

              STANDARD_ONLY = T.let(
                  :standard_only,
                  Anthropic::Messages::BatchCreateParams::Request::Params::ServiceTier::TaggedSymbol
                )

              TaggedSymbol = T.type_alias do
                  T.all(
                    Symbol,
                    Anthropic::Messages::BatchCreateParams::Request::Params::ServiceTier
                  )
                end
            end

            # System prompt.
            #
            # A system prompt is a way of providing context and instructions to Claude, such
            # as specifying a particular goal or role. See our
            # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
            module System
              extend Anthropic::Internal::Type::Union

              class << self
                sig do
                  override
                    .returns(T::Array[
                    Anthropic::Messages::BatchCreateParams::Request::Params::System::Variants
                  ])
                end
                def variants; end
              end

              TextBlockParamArray = T.let(
                  Anthropic::Internal::Type::ArrayOf[Anthropic::TextBlockParam],
                  Anthropic::Internal::Type::Converter
                )

              Variants = T.type_alias do
                  T.any(String, T::Array[Anthropic::TextBlockParam])
                end
            end
          end
        end
      end

      class BatchDeleteParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        sig { override.returns({ request_options: Anthropic::RequestOptions }) }
        def to_hash; end

        class << self
          sig { params(request_options: Anthropic::RequestOptions::OrHash).returns(T.attached_class) }
          def new(request_options: {}); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::BatchDeleteParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BatchListParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        # ID of the object to use as a cursor for pagination. When provided, returns the
        # page of results immediately after this object.
        sig { returns(T.nilable(String)) }
        attr_reader :after_id

        sig { params(after_id: String).void }
        attr_writer :after_id

        # ID of the object to use as a cursor for pagination. When provided, returns the
        # page of results immediately before this object.
        sig { returns(T.nilable(String)) }
        attr_reader :before_id

        sig { params(before_id: String).void }
        attr_writer :before_id

        # Number of items to return per page.
        #
        # Defaults to `20`. Ranges from `1` to `1000`.
        sig { returns(T.nilable(Integer)) }
        attr_reader :limit

        sig { params(limit: Integer).void }
        attr_writer :limit

        sig do
          override
            .returns({
              after_id: String,
              before_id: String,
              limit: Integer,
              request_options: Anthropic::RequestOptions
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              after_id: String,
              before_id: String,
              limit: Integer,
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(T.attached_class)
          end
          def new(
            after_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                           # page of results immediately after this object.
            before_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                            # page of results immediately before this object.
            limit: nil, # Number of items to return per page.
                        # Defaults to `20`. Ranges from `1` to `1000`.
            request_options: {}
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::BatchListParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BatchResultsParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        sig { override.returns({ request_options: Anthropic::RequestOptions }) }
        def to_hash; end

        class << self
          sig { params(request_options: Anthropic::RequestOptions::OrHash).returns(T.attached_class) }
          def new(request_options: {}); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::BatchResultsParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class BatchRetrieveParams < Anthropic::Internal::Type::BaseModel
        extend Anthropic::Internal::Type::RequestParameters::Converter
        include Anthropic::Internal::Type::RequestParameters

        sig { override.returns({ request_options: Anthropic::RequestOptions }) }
        def to_hash; end

        class << self
          sig { params(request_options: Anthropic::RequestOptions::OrHash).returns(T.attached_class) }
          def new(request_options: {}); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::BatchRetrieveParams,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class DeletedMessageBatch < Anthropic::Internal::Type::BaseModel
        # ID of the Message Batch.
        sig { returns(String) }
        attr_accessor :id

        # Deleted object type.
        #
        # For Message Batches, this is always `"message_batch_deleted"`.
        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ id: String, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(id: String, type: Symbol).returns(T.attached_class) }
          def new(
            id:, # ID of the Message Batch.
            type: :message_batch_deleted # Deleted object type.
                                         # For Message Batches, this is always `"message_batch_deleted"`.
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::DeletedMessageBatch,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class MessageBatch < Anthropic::Internal::Type::BaseModel
        # RFC 3339 datetime string representing the time at which the Message Batch was
        # archived and its results became unavailable.
        sig { returns(T.nilable(Time)) }
        attr_accessor :archived_at

        # RFC 3339 datetime string representing the time at which cancellation was
        # initiated for the Message Batch. Specified only if cancellation was initiated.
        sig { returns(T.nilable(Time)) }
        attr_accessor :cancel_initiated_at

        # RFC 3339 datetime string representing the time at which the Message Batch was
        # created.
        sig { returns(Time) }
        attr_accessor :created_at

        # RFC 3339 datetime string representing the time at which processing for the
        # Message Batch ended. Specified only once processing ends.
        #
        # Processing ends when every request in a Message Batch has either succeeded,
        # errored, canceled, or expired.
        sig { returns(T.nilable(Time)) }
        attr_accessor :ended_at

        # RFC 3339 datetime string representing the time at which the Message Batch will
        # expire and end processing, which is 24 hours after creation.
        sig { returns(Time) }
        attr_accessor :expires_at

        # Unique object identifier.
        #
        # The format and length of IDs may change over time.
        sig { returns(String) }
        attr_accessor :id

        # Processing status of the Message Batch.
        sig { returns(Anthropic::Messages::MessageBatch::ProcessingStatus::TaggedSymbol) }
        attr_accessor :processing_status

        # Tallies requests within the Message Batch, categorized by their status.
        #
        # Requests start as `processing` and move to one of the other statuses only once
        # processing of the entire batch ends. The sum of all values always matches the
        # total number of requests in the batch.
        sig { returns(Anthropic::Messages::MessageBatchRequestCounts) }
        attr_reader :request_counts

        sig { params(request_counts: Anthropic::Messages::MessageBatchRequestCounts::OrHash).void }
        attr_writer :request_counts

        # URL to a `.jsonl` file containing the results of the Message Batch requests.
        # Specified only once processing ends.
        #
        # Results in the file are not guaranteed to be in the same order as requests. Use
        # the `custom_id` field to match results to requests.
        sig { returns(T.nilable(String)) }
        attr_accessor :results_url

        # Object type.
        #
        # For Message Batches, this is always `"message_batch"`.
        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              id: String,
              archived_at: T.nilable(Time),
              cancel_initiated_at: T.nilable(Time),
              created_at: Time,
              ended_at: T.nilable(Time),
              expires_at: Time,
              processing_status:
                Anthropic::Messages::MessageBatch::ProcessingStatus::TaggedSymbol,
              request_counts: Anthropic::Messages::MessageBatchRequestCounts,
              results_url: T.nilable(String),
              type: Symbol
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              id: String,
              archived_at: T.nilable(Time),
              cancel_initiated_at: T.nilable(Time),
              created_at: Time,
              ended_at: T.nilable(Time),
              expires_at: Time,
              processing_status: Anthropic::Messages::MessageBatch::ProcessingStatus::OrSymbol,
              request_counts: Anthropic::Messages::MessageBatchRequestCounts::OrHash,
              results_url: T.nilable(String),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            id:, # Unique object identifier.
                 # The format and length of IDs may change over time.
            archived_at:, # RFC 3339 datetime string representing the time at which the Message Batch was
                          # archived and its results became unavailable.
            cancel_initiated_at:, # RFC 3339 datetime string representing the time at which cancellation was
                                  # initiated for the Message Batch. Specified only if cancellation was initiated.
            created_at:, # RFC 3339 datetime string representing the time at which the Message Batch was
                         # created.
            ended_at:, # RFC 3339 datetime string representing the time at which processing for the
                       # Message Batch ended. Specified only once processing ends.
                       # Processing ends when every request in a Message Batch has either succeeded,
                       # errored, canceled, or expired.
            expires_at:, # RFC 3339 datetime string representing the time at which the Message Batch will
                         # expire and end processing, which is 24 hours after creation.
            processing_status:, # Processing status of the Message Batch.
            request_counts:, # Tallies requests within the Message Batch, categorized by their status.
                             # Requests start as `processing` and move to one of the other statuses only once
                             # processing of the entire batch ends. The sum of all values always matches the
                             # total number of requests in the batch.
            results_url:, # URL to a `.jsonl` file containing the results of the Message Batch requests.
                          # Specified only once processing ends.
                          # Results in the file are not guaranteed to be in the same order as requests. Use
                          # the `custom_id` field to match results to requests.
            type: :message_batch # Object type.
                                 # For Message Batches, this is always `"message_batch"`.
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::MessageBatch,
              Anthropic::Internal::AnyHash
            )
          end

        # Processing status of the Message Batch.
        module ProcessingStatus
          extend Anthropic::Internal::Type::Enum

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::Messages::MessageBatch::ProcessingStatus::TaggedSymbol
              ])
            end
            def values; end
          end

          CANCELING = T.let(
              :canceling,
              Anthropic::Messages::MessageBatch::ProcessingStatus::TaggedSymbol
            )

          ENDED = T.let(
              :ended,
              Anthropic::Messages::MessageBatch::ProcessingStatus::TaggedSymbol
            )

          IN_PROGRESS = T.let(
              :in_progress,
              Anthropic::Messages::MessageBatch::ProcessingStatus::TaggedSymbol
            )

          OrSymbol = T.type_alias { T.any(Symbol, String) }

          TaggedSymbol = T.type_alias do
              T.all(Symbol, Anthropic::Messages::MessageBatch::ProcessingStatus)
            end
        end
      end

      class MessageBatchCanceledResult < Anthropic::Internal::Type::BaseModel
        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(type: Symbol).returns(T.attached_class) }
          def new(type: :canceled); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::MessageBatchCanceledResult,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class MessageBatchErroredResult < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::ErrorResponse) }
        attr_reader :error

        sig { params(error: Anthropic::ErrorResponse::OrHash).void }
        attr_writer :error

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ error: Anthropic::ErrorResponse, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(error: Anthropic::ErrorResponse::OrHash, type: Symbol).returns(T.attached_class) }
          def new(error:, type: :errored); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::MessageBatchErroredResult,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class MessageBatchExpiredResult < Anthropic::Internal::Type::BaseModel
        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(type: Symbol).returns(T.attached_class) }
          def new(type: :expired); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::MessageBatchExpiredResult,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class MessageBatchIndividualResponse < Anthropic::Internal::Type::BaseModel
        # Developer-provided ID created for each request in a Message Batch. Useful for
        # matching results to requests, as results may be given out of request order.
        #
        # Must be unique for each request within the Message Batch.
        sig { returns(String) }
        attr_accessor :custom_id

        # Processing result for this request.
        #
        # Contains a Message output if processing was successful, an error response if
        # processing failed, or the reason why processing was not attempted, such as
        # cancellation or expiration.
        sig { returns(Anthropic::Messages::MessageBatchResult::Variants) }
        attr_accessor :result

        sig do
          override
            .returns({
              custom_id: String,
              result: Anthropic::Messages::MessageBatchResult::Variants
            })
        end
        def to_hash; end

        class << self
          # This is a single line in the response `.jsonl` file and does not represent the
          # response as a whole.
          sig do
            params(
              custom_id: String,
              result: T.any(
                Anthropic::Messages::MessageBatchSucceededResult::OrHash,
                Anthropic::Messages::MessageBatchErroredResult::OrHash,
                Anthropic::Messages::MessageBatchCanceledResult::OrHash,
                Anthropic::Messages::MessageBatchExpiredResult::OrHash
              )
            ).returns(T.attached_class)
          end
          def new(
            custom_id:, # Developer-provided ID created for each request in a Message Batch. Useful for
                        # matching results to requests, as results may be given out of request order.
                        # Must be unique for each request within the Message Batch.
            result: # Processing result for this request.
                    # Contains a Message output if processing was successful, an error response if
                    # processing failed, or the reason why processing was not attempted, such as
                    # cancellation or expiration.
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::MessageBatchIndividualResponse,
              Anthropic::Internal::AnyHash
            )
          end
      end

      class MessageBatchRequestCounts < Anthropic::Internal::Type::BaseModel
        # Number of requests in the Message Batch that have been canceled.
        #
        # This is zero until processing of the entire Message Batch has ended.
        sig { returns(Integer) }
        attr_accessor :canceled

        # Number of requests in the Message Batch that encountered an error.
        #
        # This is zero until processing of the entire Message Batch has ended.
        sig { returns(Integer) }
        attr_accessor :errored

        # Number of requests in the Message Batch that have expired.
        #
        # This is zero until processing of the entire Message Batch has ended.
        sig { returns(Integer) }
        attr_accessor :expired

        # Number of requests in the Message Batch that are processing.
        sig { returns(Integer) }
        attr_accessor :processing

        # Number of requests in the Message Batch that have completed successfully.
        #
        # This is zero until processing of the entire Message Batch has ended.
        sig { returns(Integer) }
        attr_accessor :succeeded

        sig do
          override
            .returns({
              canceled: Integer,
              errored: Integer,
              expired: Integer,
              processing: Integer,
              succeeded: Integer
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              canceled: Integer,
              errored: Integer,
              expired: Integer,
              processing: Integer,
              succeeded: Integer
            ).returns(T.attached_class)
          end
          def new(
            canceled:, # Number of requests in the Message Batch that have been canceled.
                       # This is zero until processing of the entire Message Batch has ended.
            errored:, # Number of requests in the Message Batch that encountered an error.
                      # This is zero until processing of the entire Message Batch has ended.
            expired:, # Number of requests in the Message Batch that have expired.
                      # This is zero until processing of the entire Message Batch has ended.
            processing:, # Number of requests in the Message Batch that are processing.
            succeeded: # Number of requests in the Message Batch that have completed successfully.
                       # This is zero until processing of the entire Message Batch has ended.
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::MessageBatchRequestCounts,
              Anthropic::Internal::AnyHash
            )
          end
      end

      # Processing result for this request.
      #
      # Contains a Message output if processing was successful, an error response if
      # processing failed, or the reason why processing was not attempted, such as
      # cancellation or expiration.
      module MessageBatchResult
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::Messages::MessageBatchResult::Variants]) }
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::Messages::MessageBatchSucceededResult,
              Anthropic::Messages::MessageBatchErroredResult,
              Anthropic::Messages::MessageBatchCanceledResult,
              Anthropic::Messages::MessageBatchExpiredResult
            )
          end
      end

      class MessageBatchSucceededResult < Anthropic::Internal::Type::BaseModel
        sig { returns(Anthropic::Message) }
        attr_reader :message

        sig { params(message: Anthropic::Message::OrHash).void }
        attr_writer :message

        sig { returns(Symbol) }
        attr_accessor :type

        sig { override.returns({ message: Anthropic::Message, type: Symbol }) }
        def to_hash; end

        class << self
          sig { params(message: Anthropic::Message::OrHash, type: Symbol).returns(T.attached_class) }
          def new(message:, type: :succeeded); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::Messages::MessageBatchSucceededResult,
              Anthropic::Internal::AnyHash
            )
          end
      end
    end

    class Metadata < Anthropic::Internal::Type::BaseModel
      # An external identifier for the user who is associated with the request.
      #
      # This should be a uuid, hash value, or other opaque identifier. Anthropic may use
      # this id to help detect abuse. Do not include any identifying information such as
      # name, email address, or phone number.
      sig { returns(T.nilable(String)) }
      attr_accessor :user_id

      sig { override.returns({ user_id: T.nilable(String) }) }
      def to_hash; end

      class << self
        sig { params(user_id: T.nilable(String)).returns(T.attached_class) }
        def new(
          user_id: nil # An external identifier for the user who is associated with the request.
                       # This should be a uuid, hash value, or other opaque identifier. Anthropic may use
                       # this id to help detect abuse. Do not include any identifying information such as
                       # name, email address, or phone number.
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::Metadata, Anthropic::Internal::AnyHash)
        end
    end

    # The model that will complete your prompt.\n\nSee
    # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
    # details and options.
    module Model
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::Model::Variants]) }
        def variants; end
      end

      # Our fastest model
      CLAUDE_3_5_HAIKU_20241022 = T.let(:"claude-3-5-haiku-20241022", Anthropic::Model::TaggedSymbol)

      # Fastest and most compact model for near-instant responsiveness
      CLAUDE_3_5_HAIKU_LATEST = T.let(:"claude-3-5-haiku-latest", Anthropic::Model::TaggedSymbol)

      CLAUDE_3_5_SONNET_20240620 = T.let(:"claude-3-5-sonnet-20240620", Anthropic::Model::TaggedSymbol)

      # Our previous most intelligent model
      CLAUDE_3_5_SONNET_20241022 = T.let(:"claude-3-5-sonnet-20241022", Anthropic::Model::TaggedSymbol)

      # Our previous most intelligent model
      CLAUDE_3_5_SONNET_LATEST = T.let(:"claude-3-5-sonnet-latest", Anthropic::Model::TaggedSymbol)

      # High-performance model with early extended thinking
      CLAUDE_3_7_SONNET_20250219 = T.let(:"claude-3-7-sonnet-20250219", Anthropic::Model::TaggedSymbol)

      # High-performance model with early extended thinking
      CLAUDE_3_7_SONNET_LATEST = T.let(:"claude-3-7-sonnet-latest", Anthropic::Model::TaggedSymbol)

      # Our previous most fast and cost-effective
      CLAUDE_3_HAIKU_20240307 = T.let(:"claude-3-haiku-20240307", Anthropic::Model::TaggedSymbol)

      # Excels at writing and complex tasks
      CLAUDE_3_OPUS_20240229 = T.let(:"claude-3-opus-20240229", Anthropic::Model::TaggedSymbol)

      # Excels at writing and complex tasks
      CLAUDE_3_OPUS_LATEST = T.let(:"claude-3-opus-latest", Anthropic::Model::TaggedSymbol)

      # Our most capable model
      CLAUDE_4_OPUS_20250514 = T.let(:"claude-4-opus-20250514", Anthropic::Model::TaggedSymbol)

      # High-performance model with extended thinking
      CLAUDE_4_SONNET_20250514 = T.let(:"claude-4-sonnet-20250514", Anthropic::Model::TaggedSymbol)

      # Our most capable model
      CLAUDE_OPUS_4_0 = T.let(:"claude-opus-4-0", Anthropic::Model::TaggedSymbol)

      # Our most capable model
      CLAUDE_OPUS_4_1_20250805 = T.let(:"claude-opus-4-1-20250805", Anthropic::Model::TaggedSymbol)

      # Our most capable model
      CLAUDE_OPUS_4_20250514 = T.let(:"claude-opus-4-20250514", Anthropic::Model::TaggedSymbol)

      # High-performance model with extended thinking
      CLAUDE_SONNET_4_0 = T.let(:"claude-sonnet-4-0", Anthropic::Model::TaggedSymbol)

      # High-performance model with extended thinking
      CLAUDE_SONNET_4_20250514 = T.let(:"claude-sonnet-4-20250514", Anthropic::Model::TaggedSymbol)

      OrSymbol = T.type_alias { T.any(Symbol, String) }
      TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::Model) }
      Variants = T.type_alias { T.any(Anthropic::Model::TaggedSymbol, String) }
    end

    class ModelInfo < Anthropic::Internal::Type::BaseModel
      # RFC 3339 datetime string representing the time at which the model was released.
      # May be set to an epoch value if the release date is unknown.
      sig { returns(Time) }
      attr_accessor :created_at

      # A human-readable name for the model.
      sig { returns(String) }
      attr_accessor :display_name

      # Unique model identifier.
      sig { returns(String) }
      attr_accessor :id

      # Object type.
      #
      # For Models, this is always `"model"`.
      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ id: String, created_at: Time, display_name: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(id: String, created_at: Time, display_name: String, type: Symbol).returns(T.attached_class) }
        def new(
          id:, # Unique model identifier.
          created_at:, # RFC 3339 datetime string representing the time at which the model was released.
                       # May be set to an epoch value if the release date is unknown.
          display_name:, # A human-readable name for the model.
          type: :model # Object type.
                       # For Models, this is always `"model"`.
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ModelInfo, Anthropic::Internal::AnyHash)
        end
    end

    class ModelListParams < Anthropic::Internal::Type::BaseModel
      extend Anthropic::Internal::Type::RequestParameters::Converter
      include Anthropic::Internal::Type::RequestParameters

      # ID of the object to use as a cursor for pagination. When provided, returns the
      # page of results immediately after this object.
      sig { returns(T.nilable(String)) }
      attr_reader :after_id

      sig { params(after_id: String).void }
      attr_writer :after_id

      # ID of the object to use as a cursor for pagination. When provided, returns the
      # page of results immediately before this object.
      sig { returns(T.nilable(String)) }
      attr_reader :before_id

      sig { params(before_id: String).void }
      attr_writer :before_id

      # Optional header to specify the beta version(s) you want to use.
      sig { returns(T.nilable(T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)])) }
      attr_reader :betas

      sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
      attr_writer :betas

      # Number of items to return per page.
      #
      # Defaults to `20`. Ranges from `1` to `1000`.
      sig { returns(T.nilable(Integer)) }
      attr_reader :limit

      sig { params(limit: Integer).void }
      attr_writer :limit

      sig do
        override
          .returns({
            after_id: String,
            before_id: String,
            limit: Integer,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            after_id: String,
            before_id: String,
            limit: Integer,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          after_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                         # page of results immediately after this object.
          before_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                          # page of results immediately before this object.
          limit: nil, # Number of items to return per page.
                      # Defaults to `20`. Ranges from `1` to `1000`.
          betas: nil, # Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ModelListParams, Anthropic::Internal::AnyHash)
        end
    end

    class ModelRetrieveParams < Anthropic::Internal::Type::BaseModel
      extend Anthropic::Internal::Type::RequestParameters::Converter
      include Anthropic::Internal::Type::RequestParameters

      # Optional header to specify the beta version(s) you want to use.
      sig { returns(T.nilable(T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)])) }
      attr_reader :betas

      sig { params(betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)]).void }
      attr_writer :betas

      sig do
        override
          .returns({
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def new(
          betas: nil, # Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ModelRetrieveParams, Anthropic::Internal::AnyHash)
        end
    end

    class NotFoundError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :not_found_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::NotFoundError, Anthropic::Internal::AnyHash)
        end
    end

    class OverloadedError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :overloaded_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::OverloadedError, Anthropic::Internal::AnyHash)
        end
    end

    class PermissionError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :permission_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::PermissionError, Anthropic::Internal::AnyHash)
        end
    end

    class PlainTextSource < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :data

      sig { returns(Symbol) }
      attr_accessor :media_type

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ data: String, media_type: Symbol, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(data: String, media_type: Symbol, type: Symbol).returns(T.attached_class) }
        def new(data:, media_type: :"text/plain", type: :text); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::PlainTextSource, Anthropic::Internal::AnyHash)
        end
    end

    class RateLimitError < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: String, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :rate_limit_error); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::RateLimitError, Anthropic::Internal::AnyHash)
        end
    end

    module RawContentBlockDelta
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::RawContentBlockDelta::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::TextDelta,
            Anthropic::InputJSONDelta,
            Anthropic::CitationsDelta,
            Anthropic::ThinkingDelta,
            Anthropic::SignatureDelta
          )
        end
    end

    class RawContentBlockDeltaEvent < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::RawContentBlockDelta::Variants) }
      attr_accessor :delta

      sig { returns(Integer) }
      attr_accessor :index

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            delta: Anthropic::RawContentBlockDelta::Variants,
            index: Integer,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            delta: T.any(
              Anthropic::TextDelta::OrHash,
              Anthropic::InputJSONDelta::OrHash,
              Anthropic::CitationsDelta::OrHash,
              Anthropic::ThinkingDelta::OrHash,
              Anthropic::SignatureDelta::OrHash
            ),
            index: Integer,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(delta:, index:, type: :content_block_delta); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::RawContentBlockDeltaEvent,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class RawContentBlockStartEvent < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::RawContentBlockStartEvent::ContentBlock::Variants) }
      attr_accessor :content_block

      sig { returns(Integer) }
      attr_accessor :index

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            content_block:
              Anthropic::RawContentBlockStartEvent::ContentBlock::Variants,
            index: Integer,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            content_block: T.any(
              Anthropic::TextBlock::OrHash,
              Anthropic::ThinkingBlock::OrHash,
              Anthropic::RedactedThinkingBlock::OrHash,
              Anthropic::ToolUseBlock::OrHash,
              Anthropic::ServerToolUseBlock::OrHash,
              Anthropic::WebSearchToolResultBlock::OrHash
            ),
            index: Integer,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(content_block:, index:, type: :content_block_start); end
      end

      module ContentBlock
        extend Anthropic::Internal::Type::Union

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::RawContentBlockStartEvent::ContentBlock::Variants
            ])
          end
          def variants; end
        end

        Variants = T.type_alias do
            T.any(
              Anthropic::TextBlock,
              Anthropic::ThinkingBlock,
              Anthropic::RedactedThinkingBlock,
              Anthropic::ToolUseBlock,
              Anthropic::ServerToolUseBlock,
              Anthropic::WebSearchToolResultBlock
            )
          end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::RawContentBlockStartEvent,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class RawContentBlockStopEvent < Anthropic::Internal::Type::BaseModel
      sig { returns(Integer) }
      attr_accessor :index

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ index: Integer, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(index: Integer, type: Symbol).returns(T.attached_class) }
        def new(index:, type: :content_block_stop); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::RawContentBlockStopEvent,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class RawMessageDeltaEvent < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::RawMessageDeltaEvent::Delta) }
      attr_reader :delta

      sig { params(delta: Anthropic::RawMessageDeltaEvent::Delta::OrHash).void }
      attr_writer :delta

      sig { returns(Symbol) }
      attr_accessor :type

      # Billing and rate-limit usage.
      #
      # Anthropic's API bills and rate-limits by token counts, as tokens represent the
      # underlying cost to our systems.
      #
      # Under the hood, the API transforms requests into a format suitable for the
      # model. The model's output then goes through a parsing stage before becoming an
      # API response. As a result, the token counts in `usage` will not match one-to-one
      # with the exact visible content of an API request or response.
      #
      # For example, `output_tokens` will be non-zero, even for an empty string response
      # from Claude.
      #
      # Total input tokens in a request is the summation of `input_tokens`,
      # `cache_creation_input_tokens`, and `cache_read_input_tokens`.
      sig { returns(Anthropic::MessageDeltaUsage) }
      attr_reader :usage

      sig { params(usage: Anthropic::MessageDeltaUsage::OrHash).void }
      attr_writer :usage

      sig do
        override
          .returns({
            delta: Anthropic::RawMessageDeltaEvent::Delta,
            type: Symbol,
            usage: Anthropic::MessageDeltaUsage
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            delta: Anthropic::RawMessageDeltaEvent::Delta::OrHash,
            usage: Anthropic::MessageDeltaUsage::OrHash,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          delta:,
          usage:, # Billing and rate-limit usage.
                  # Anthropic's API bills and rate-limits by token counts, as tokens represent the
                  # underlying cost to our systems.
                  # Under the hood, the API transforms requests into a format suitable for the
                  # model. The model's output then goes through a parsing stage before becoming an
                  # API response. As a result, the token counts in `usage` will not match one-to-one
                  # with the exact visible content of an API request or response.
                  # For example, `output_tokens` will be non-zero, even for an empty string response
                  # from Claude.
                  # Total input tokens in a request is the summation of `input_tokens`,
                  # `cache_creation_input_tokens`, and `cache_read_input_tokens`.
          type: :message_delta
); end
      end

      class Delta < Anthropic::Internal::Type::BaseModel
        sig { returns(T.nilable(Anthropic::StopReason::TaggedSymbol)) }
        attr_accessor :stop_reason

        sig { returns(T.nilable(String)) }
        attr_accessor :stop_sequence

        sig do
          override
            .returns({
              stop_reason: T.nilable(Anthropic::StopReason::TaggedSymbol),
              stop_sequence: T.nilable(String)
            })
        end
        def to_hash; end

        class << self
          sig do
            params(
              stop_reason: T.nilable(Anthropic::StopReason::OrSymbol),
              stop_sequence: T.nilable(String)
            ).returns(T.attached_class)
          end
          def new(stop_reason:, stop_sequence:); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::RawMessageDeltaEvent::Delta,
              Anthropic::Internal::AnyHash
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::RawMessageDeltaEvent, Anthropic::Internal::AnyHash)
        end
    end

    class RawMessageStartEvent < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::Message) }
      attr_reader :message

      sig { params(message: Anthropic::Message::OrHash).void }
      attr_writer :message

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ message: Anthropic::Message, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(message: Anthropic::Message::OrHash, type: Symbol).returns(T.attached_class) }
        def new(message:, type: :message_start); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::RawMessageStartEvent, Anthropic::Internal::AnyHash)
        end
    end

    class RawMessageStopEvent < Anthropic::Internal::Type::BaseModel
      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(type: Symbol).returns(T.attached_class) }
        def new(type: :message_stop); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::RawMessageStopEvent, Anthropic::Internal::AnyHash)
        end
    end

    module RawMessageStreamEvent
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::RawMessageStreamEvent::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::RawMessageStartEvent,
            Anthropic::RawMessageDeltaEvent,
            Anthropic::RawMessageStopEvent,
            Anthropic::RawContentBlockStartEvent,
            Anthropic::RawContentBlockDeltaEvent,
            Anthropic::RawContentBlockStopEvent
          )
        end
    end

    class RedactedThinkingBlock < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :data

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ data: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(data: String, type: Symbol).returns(T.attached_class) }
        def new(data:, type: :redacted_thinking); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::RedactedThinkingBlock, Anthropic::Internal::AnyHash)
        end
    end

    class RedactedThinkingBlockParam < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :data

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ data: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(data: String, type: Symbol).returns(T.attached_class) }
        def new(data:, type: :redacted_thinking); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::RedactedThinkingBlockParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class SearchResultBlockParam < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      sig { returns(T.nilable(Anthropic::CitationsConfigParam)) }
      attr_reader :citations

      sig { params(citations: Anthropic::CitationsConfigParam::OrHash).void }
      attr_writer :citations

      sig { returns(T::Array[Anthropic::TextBlockParam]) }
      attr_accessor :content

      sig { returns(String) }
      attr_accessor :source

      sig { returns(String) }
      attr_accessor :title

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            content: T::Array[Anthropic::TextBlockParam],
            source: String,
            title: String,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral),
            citations: Anthropic::CitationsConfigParam
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            content: T::Array[Anthropic::TextBlockParam::OrHash],
            source: String,
            title: String,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            citations: Anthropic::CitationsConfigParam::OrHash,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          content:,
          source:,
          title:,
          cache_control: nil, # Create a cache control breakpoint at this content block.
          citations: nil,
          type: :search_result
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::SearchResultBlockParam, Anthropic::Internal::AnyHash)
        end
    end

    class ServerToolUsage < Anthropic::Internal::Type::BaseModel
      # The number of web search tool requests.
      sig { returns(Integer) }
      attr_accessor :web_search_requests

      sig { override.returns({ web_search_requests: Integer }) }
      def to_hash; end

      class << self
        sig { params(web_search_requests: Integer).returns(T.attached_class) }
        def new(
          web_search_requests: # The number of web search tool requests.
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ServerToolUsage, Anthropic::Internal::AnyHash)
        end
    end

    class ServerToolUseBlock < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :id

      sig { returns(T.anything) }
      attr_accessor :input

      sig { returns(Symbol) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ id: String, input: T.anything, name: Symbol, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(id: String, input: T.anything, name: Symbol, type: Symbol).returns(T.attached_class) }
        def new(id:, input:, name: :web_search, type: :server_tool_use); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ServerToolUseBlock, Anthropic::Internal::AnyHash)
        end
    end

    class ServerToolUseBlockParam < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      sig { returns(String) }
      attr_accessor :id

      sig { returns(T.anything) }
      attr_accessor :input

      sig { returns(Symbol) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            id: String,
            input: T.anything,
            name: Symbol,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            id: String,
            input: T.anything,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            name: Symbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          id:,
          input:,
          cache_control: nil, # Create a cache control breakpoint at this content block.
          name: :web_search,
          type: :server_tool_use
); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::ServerToolUseBlockParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class SignatureDelta < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :signature

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ signature: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(signature: String, type: Symbol).returns(T.attached_class) }
        def new(signature:, type: :signature_delta); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::SignatureDelta, Anthropic::Internal::AnyHash)
        end
    end

    module StopReason
      extend Anthropic::Internal::Type::Enum

      class << self
        sig { override.returns(T::Array[Anthropic::StopReason::TaggedSymbol]) }
        def values; end
      end

      END_TURN = T.let(:end_turn, Anthropic::StopReason::TaggedSymbol)
      MAX_TOKENS = T.let(:max_tokens, Anthropic::StopReason::TaggedSymbol)
      OrSymbol = T.type_alias { T.any(Symbol, String) }
      PAUSE_TURN = T.let(:pause_turn, Anthropic::StopReason::TaggedSymbol)
      REFUSAL = T.let(:refusal, Anthropic::StopReason::TaggedSymbol)
      STOP_SEQUENCE = T.let(:stop_sequence, Anthropic::StopReason::TaggedSymbol)
      TOOL_USE = T.let(:tool_use, Anthropic::StopReason::TaggedSymbol)
      TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::StopReason) }
    end

    class TextBlock < Anthropic::Internal::Type::BaseModel
      # Citations supporting the text block.
      #
      # The type of citation returned will depend on the type of document being cited.
      # Citing a PDF results in `page_location`, plain text results in `char_location`,
      # and content document results in `content_block_location`.
      sig { returns(T.nilable(T::Array[Anthropic::TextCitation::Variants])) }
      attr_accessor :citations

      sig { returns(String) }
      attr_accessor :text

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            citations: T.nilable(T::Array[Anthropic::TextCitation::Variants]),
            text: String,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            citations: T.nilable(
              T::Array[
                T.any(
                  Anthropic::CitationCharLocation::OrHash,
                  Anthropic::CitationPageLocation::OrHash,
                  Anthropic::CitationContentBlockLocation::OrHash,
                  Anthropic::CitationsWebSearchResultLocation::OrHash,
                  Anthropic::CitationsSearchResultLocation::OrHash
                )
              ]
            ),
            text: String,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          citations:, # Citations supporting the text block.
                      # The type of citation returned will depend on the type of document being cited.
                      # Citing a PDF results in `page_location`, plain text results in `char_location`,
                      # and content document results in `content_block_location`.
          text:,
          type: :text
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::TextBlock, Anthropic::Internal::AnyHash)
        end
    end

    class TextBlockParam < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      sig do
        returns(T.nilable(
            T::Array[
              T.any(
                Anthropic::CitationCharLocationParam,
                Anthropic::CitationPageLocationParam,
                Anthropic::CitationContentBlockLocationParam,
                Anthropic::CitationWebSearchResultLocationParam,
                Anthropic::CitationSearchResultLocationParam
              )
            ]
          ))
      end
      attr_accessor :citations

      sig { returns(String) }
      attr_accessor :text

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            text: String,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral),
            citations:
              T.nilable(
                T::Array[
                  T.any(
                    Anthropic::CitationCharLocationParam,
                    Anthropic::CitationPageLocationParam,
                    Anthropic::CitationContentBlockLocationParam,
                    Anthropic::CitationWebSearchResultLocationParam,
                    Anthropic::CitationSearchResultLocationParam
                  )
                ]
              )
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            text: String,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            citations: T.nilable(
              T::Array[
                T.any(
                  Anthropic::CitationCharLocationParam::OrHash,
                  Anthropic::CitationPageLocationParam::OrHash,
                  Anthropic::CitationContentBlockLocationParam::OrHash,
                  Anthropic::CitationWebSearchResultLocationParam::OrHash,
                  Anthropic::CitationSearchResultLocationParam::OrHash
                )
              ]
            ),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          text:,
          cache_control: nil, # Create a cache control breakpoint at this content block.
          citations: nil,
          type: :text
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::TextBlockParam, Anthropic::Internal::AnyHash)
        end
    end

    module TextCitation
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::TextCitation::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::CitationCharLocation,
            Anthropic::CitationPageLocation,
            Anthropic::CitationContentBlockLocation,
            Anthropic::CitationsWebSearchResultLocation,
            Anthropic::CitationsSearchResultLocation
          )
        end
    end

    module TextCitationParam
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::TextCitationParam::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::CitationCharLocationParam,
            Anthropic::CitationPageLocationParam,
            Anthropic::CitationContentBlockLocationParam,
            Anthropic::CitationWebSearchResultLocationParam,
            Anthropic::CitationSearchResultLocationParam
          )
        end
    end

    class TextDelta < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :text

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ text: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(text: String, type: Symbol).returns(T.attached_class) }
        def new(text:, type: :text_delta); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::TextDelta, Anthropic::Internal::AnyHash)
        end
    end

    class ThinkingBlock < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :signature

      sig { returns(String) }
      attr_accessor :thinking

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ signature: String, thinking: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(signature: String, thinking: String, type: Symbol).returns(T.attached_class) }
        def new(signature:, thinking:, type: :thinking); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ThinkingBlock, Anthropic::Internal::AnyHash)
        end
    end

    class ThinkingBlockParam < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :signature

      sig { returns(String) }
      attr_accessor :thinking

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ signature: String, thinking: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(signature: String, thinking: String, type: Symbol).returns(T.attached_class) }
        def new(signature:, thinking:, type: :thinking); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ThinkingBlockParam, Anthropic::Internal::AnyHash)
        end
    end

    class ThinkingConfigDisabled < Anthropic::Internal::Type::BaseModel
      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(type: Symbol).returns(T.attached_class) }
        def new(type: :disabled); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ThinkingConfigDisabled, Anthropic::Internal::AnyHash)
        end
    end

    class ThinkingConfigEnabled < Anthropic::Internal::Type::BaseModel
      # Determines how many tokens Claude can use for its internal reasoning process.
      # Larger budgets can enable more thorough analysis for complex problems, improving
      # response quality.
      #
      # Must be 1024 and less than `max_tokens`.
      #
      # See
      # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
      # for details.
      sig { returns(Integer) }
      attr_accessor :budget_tokens

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ budget_tokens: Integer, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(budget_tokens: Integer, type: Symbol).returns(T.attached_class) }
        def new(
          budget_tokens:, # Determines how many tokens Claude can use for its internal reasoning process.
                          # Larger budgets can enable more thorough analysis for complex problems, improving
                          # response quality.
                          # Must be 1024 and less than `max_tokens`.
                          # See
                          # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                          # for details.
          type: :enabled
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ThinkingConfigEnabled, Anthropic::Internal::AnyHash)
        end
    end

    # Configuration for enabling Claude's extended thinking.
    #
    # When enabled, responses include `thinking` content blocks showing Claude's
    # thinking process before the final answer. Requires a minimum budget of 1,024
    # tokens and counts towards your `max_tokens` limit.
    #
    # See
    # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
    # for details.
    module ThinkingConfigParam
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::ThinkingConfigParam::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::ThinkingConfigEnabled,
            Anthropic::ThinkingConfigDisabled
          )
        end
    end

    class ThinkingDelta < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :thinking

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ thinking: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(thinking: String, type: Symbol).returns(T.attached_class) }
        def new(thinking:, type: :thinking_delta); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ThinkingDelta, Anthropic::Internal::AnyHash)
        end
    end

    class Tool < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      # Description of what this tool does.
      #
      # Tool descriptions should be as detailed as possible. The more information that
      # the model has about what the tool is and how to use it, the better it will
      # perform. You can use natural language descriptions to reinforce important
      # aspects of the tool input JSON schema.
      sig { returns(T.nilable(String)) }
      attr_reader :description

      sig { params(description: String).void }
      attr_writer :description

      # [JSON schema](https://json-schema.org/draft/2020-12) for this tool's input.
      #
      # This defines the shape of the `input` that your tool accepts and that the model
      # will produce.
      sig { returns(Anthropic::Tool::InputSchema) }
      attr_reader :input_schema

      sig { params(input_schema: Anthropic::Tool::InputSchema::OrHash).void }
      attr_writer :input_schema

      # Name of the tool.
      #
      # This is how the tool will be called by the model and in `tool_use` blocks.
      sig { returns(String) }
      attr_accessor :name

      sig { returns(T.nilable(Anthropic::Tool::Type::OrSymbol)) }
      attr_accessor :type

      sig do
        override
          .returns({
            input_schema: Anthropic::Tool::InputSchema,
            name: String,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral),
            description: String,
            type: T.nilable(Anthropic::Tool::Type::OrSymbol)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            input_schema: Anthropic::Tool::InputSchema::OrHash,
            name: String,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            description: String,
            type: T.nilable(Anthropic::Tool::Type::OrSymbol)
          ).returns(T.attached_class)
        end
        def new(
          input_schema:, # [JSON schema](https://json-schema.org/draft/2020-12) for this tool's input.
                         # This defines the shape of the `input` that your tool accepts and that the model
                         # will produce.
          name:, # Name of the tool.
                 # This is how the tool will be called by the model and in `tool_use` blocks.
          cache_control: nil, # Create a cache control breakpoint at this content block.
          description: nil, # Description of what this tool does.
                            # Tool descriptions should be as detailed as possible. The more information that
                            # the model has about what the tool is and how to use it, the better it will
                            # perform. You can use natural language descriptions to reinforce important
                            # aspects of the tool input JSON schema.
          type: nil
); end
      end

      class InputSchema < Anthropic::Internal::Type::BaseModel
        sig { returns(T.nilable(T.anything)) }
        attr_accessor :properties

        sig { returns(T.nilable(T::Array[String])) }
        attr_accessor :required

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              type: Symbol,
              properties: T.nilable(T.anything),
              required: T.nilable(T::Array[String])
            })
        end
        def to_hash; end

        class << self
          # [JSON schema](https://json-schema.org/draft/2020-12) for this tool's input.
          #
          # This defines the shape of the `input` that your tool accepts and that the model
          # will produce.
          sig do
            params(
              properties: T.nilable(T.anything),
              required: T.nilable(T::Array[String]),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(properties: nil, required: nil, type: :object); end
        end

        OrHash = T.type_alias do
            T.any(Anthropic::Tool::InputSchema, Anthropic::Internal::AnyHash)
          end
      end

      OrHash = T.type_alias { T.any(Anthropic::Tool, Anthropic::Internal::AnyHash) }

      module Type
        extend Anthropic::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Anthropic::Tool::Type::TaggedSymbol]) }
          def values; end
        end

        CUSTOM = T.let(:custom, Anthropic::Tool::Type::TaggedSymbol)
        OrSymbol = T.type_alias { T.any(Symbol, String) }
        TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::Tool::Type) }
      end
    end

    class ToolBash20250124 < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      # Name of the tool.
      #
      # This is how the tool will be called by the model and in `tool_use` blocks.
      sig { returns(Symbol) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            name: Symbol,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            name: Symbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          cache_control: nil, # Create a cache control breakpoint at this content block.
          name: :bash, # Name of the tool.
                       # This is how the tool will be called by the model and in `tool_use` blocks.
          type: :bash_20250124
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolBash20250124, Anthropic::Internal::AnyHash)
        end
    end

    # How the model should use the provided tools. The model can use a specific tool,
    # any available tool, decide by itself, or not use tools at all.
    module ToolChoice
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::ToolChoice::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::ToolChoiceAuto,
            Anthropic::ToolChoiceAny,
            Anthropic::ToolChoiceTool,
            Anthropic::ToolChoiceNone
          )
        end
    end

    class ToolChoiceAny < Anthropic::Internal::Type::BaseModel
      # Whether to disable parallel tool use.
      #
      # Defaults to `false`. If set to `true`, the model will output exactly one tool
      # use.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :disable_parallel_tool_use

      sig { params(disable_parallel_tool_use: T::Boolean).void }
      attr_writer :disable_parallel_tool_use

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ type: Symbol, disable_parallel_tool_use: T::Boolean }) }
      def to_hash; end

      class << self
        # The model will use any available tools.
        sig { params(disable_parallel_tool_use: T::Boolean, type: Symbol).returns(T.attached_class) }
        def new(
          disable_parallel_tool_use: nil, # Whether to disable parallel tool use.
                                          # Defaults to `false`. If set to `true`, the model will output exactly one tool
                                          # use.
          type: :any
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolChoiceAny, Anthropic::Internal::AnyHash)
        end
    end

    class ToolChoiceAuto < Anthropic::Internal::Type::BaseModel
      # Whether to disable parallel tool use.
      #
      # Defaults to `false`. If set to `true`, the model will output at most one tool
      # use.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :disable_parallel_tool_use

      sig { params(disable_parallel_tool_use: T::Boolean).void }
      attr_writer :disable_parallel_tool_use

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ type: Symbol, disable_parallel_tool_use: T::Boolean }) }
      def to_hash; end

      class << self
        # The model will automatically decide whether to use tools.
        sig { params(disable_parallel_tool_use: T::Boolean, type: Symbol).returns(T.attached_class) }
        def new(
          disable_parallel_tool_use: nil, # Whether to disable parallel tool use.
                                          # Defaults to `false`. If set to `true`, the model will output at most one tool
                                          # use.
          type: :auto
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolChoiceAuto, Anthropic::Internal::AnyHash)
        end
    end

    class ToolChoiceNone < Anthropic::Internal::Type::BaseModel
      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ type: Symbol }) }
      def to_hash; end

      class << self
        # The model will not be allowed to use tools.
        sig { params(type: Symbol).returns(T.attached_class) }
        def new(type: :none); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolChoiceNone, Anthropic::Internal::AnyHash)
        end
    end

    class ToolChoiceTool < Anthropic::Internal::Type::BaseModel
      # Whether to disable parallel tool use.
      #
      # Defaults to `false`. If set to `true`, the model will output exactly one tool
      # use.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :disable_parallel_tool_use

      sig { params(disable_parallel_tool_use: T::Boolean).void }
      attr_writer :disable_parallel_tool_use

      # The name of the tool to use.
      sig { returns(String) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ name: String, type: Symbol, disable_parallel_tool_use: T::Boolean }) }
      def to_hash; end

      class << self
        # The model will use the specified tool with `tool_choice.name`.
        sig { params(name: String, disable_parallel_tool_use: T::Boolean, type: Symbol).returns(T.attached_class) }
        def new(
          name:, # The name of the tool to use.
          disable_parallel_tool_use: nil, # Whether to disable parallel tool use.
                                          # Defaults to `false`. If set to `true`, the model will output exactly one tool
                                          # use.
          type: :tool
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolChoiceTool, Anthropic::Internal::AnyHash)
        end
    end

    class ToolResultBlockParam < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      sig { returns(T.nilable(Anthropic::ToolResultBlockParam::Content::Variants)) }
      attr_reader :content

      sig { params(content: Anthropic::ToolResultBlockParam::Content::Variants).void }
      attr_writer :content

      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :is_error

      sig { params(is_error: T::Boolean).void }
      attr_writer :is_error

      sig { returns(String) }
      attr_accessor :tool_use_id

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            tool_use_id: String,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral),
            content: Anthropic::ToolResultBlockParam::Content::Variants,
            is_error: T::Boolean
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            tool_use_id: String,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            content: Anthropic::ToolResultBlockParam::Content::Variants,
            is_error: T::Boolean,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          tool_use_id:,
          cache_control: nil, # Create a cache control breakpoint at this content block.
          content: nil,
          is_error: nil,
          type: :tool_result
); end
      end

      module Content
        extend Anthropic::Internal::Type::Union

        class << self
          sig { override.returns(T::Array[Anthropic::ToolResultBlockParam::Content::Variants]) }
          def variants; end
        end

        module Content
          extend Anthropic::Internal::Type::Union

          class << self
            sig do
              override
                .returns(T::Array[
                Anthropic::ToolResultBlockParam::Content::Content::Variants
              ])
            end
            def variants; end
          end

          Variants = T.type_alias do
              T.any(
                Anthropic::TextBlockParam,
                Anthropic::ImageBlockParam,
                Anthropic::SearchResultBlockParam
              )
            end
        end

        ContentArray = T.let(
            Anthropic::Internal::Type::ArrayOf[
              union: Anthropic::ToolResultBlockParam::Content::Content
            ],
            Anthropic::Internal::Type::Converter
          )

        Variants = T.type_alias do
            T.any(
              String,
              T::Array[
                Anthropic::ToolResultBlockParam::Content::Content::Variants
              ]
            )
          end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolResultBlockParam, Anthropic::Internal::AnyHash)
        end
    end

    class ToolTextEditor20250124 < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      # Name of the tool.
      #
      # This is how the tool will be called by the model and in `tool_use` blocks.
      sig { returns(Symbol) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            name: Symbol,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            name: Symbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          cache_control: nil, # Create a cache control breakpoint at this content block.
          name: :str_replace_editor, # Name of the tool.
                                     # This is how the tool will be called by the model and in `tool_use` blocks.
          type: :text_editor_20250124
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolTextEditor20250124, Anthropic::Internal::AnyHash)
        end
    end

    class ToolTextEditor20250429 < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      # Name of the tool.
      #
      # This is how the tool will be called by the model and in `tool_use` blocks.
      sig { returns(Symbol) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            name: Symbol,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            name: Symbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          cache_control: nil, # Create a cache control breakpoint at this content block.
          name: :str_replace_based_edit_tool, # Name of the tool.
                                              # This is how the tool will be called by the model and in `tool_use` blocks.
          type: :text_editor_20250429
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolTextEditor20250429, Anthropic::Internal::AnyHash)
        end
    end

    class ToolTextEditor20250728 < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      # Maximum number of characters to display when viewing a file. If not specified,
      # defaults to displaying the full file.
      sig { returns(T.nilable(Integer)) }
      attr_accessor :max_characters

      # Name of the tool.
      #
      # This is how the tool will be called by the model and in `tool_use` blocks.
      sig { returns(Symbol) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            name: Symbol,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral),
            max_characters: T.nilable(Integer)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            max_characters: T.nilable(Integer),
            name: Symbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          cache_control: nil, # Create a cache control breakpoint at this content block.
          max_characters: nil, # Maximum number of characters to display when viewing a file. If not specified,
                               # defaults to displaying the full file.
          name: :str_replace_based_edit_tool, # Name of the tool.
                                              # This is how the tool will be called by the model and in `tool_use` blocks.
          type: :text_editor_20250728
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolTextEditor20250728, Anthropic::Internal::AnyHash)
        end
    end

    module ToolUnion
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::ToolUnion::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::Tool,
            Anthropic::ToolBash20250124,
            Anthropic::ToolTextEditor20250124,
            Anthropic::ToolTextEditor20250429,
            Anthropic::ToolTextEditor20250728,
            Anthropic::WebSearchTool20250305
          )
        end
    end

    class ToolUseBlock < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :id

      sig { returns(T.anything) }
      attr_accessor :input

      sig { returns(String) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig { override.returns({ id: String, input: T.anything, name: String, type: Symbol }) }
      def to_hash; end

      class << self
        sig { params(id: String, input: T.anything, name: String, type: Symbol).returns(T.attached_class) }
        def new(id:, input:, name:, type: :tool_use); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolUseBlock, Anthropic::Internal::AnyHash)
        end
    end

    class ToolUseBlockParam < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      sig { returns(String) }
      attr_accessor :id

      sig { returns(T.anything) }
      attr_accessor :input

      sig { returns(String) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            id: String,
            input: T.anything,
            name: String,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            id: String,
            input: T.anything,
            name: String,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          id:,
          input:,
          name:,
          cache_control: nil, # Create a cache control breakpoint at this content block.
          type: :tool_use
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::ToolUseBlockParam, Anthropic::Internal::AnyHash)
        end
    end

    class URLImageSource < Anthropic::Internal::Type::BaseModel
      sig { returns(Symbol) }
      attr_accessor :type

      sig { returns(String) }
      attr_accessor :url

      sig { override.returns({ type: Symbol, url: String }) }
      def to_hash; end

      class << self
        sig { params(url: String, type: Symbol).returns(T.attached_class) }
        def new(url:, type: :url); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::URLImageSource, Anthropic::Internal::AnyHash)
        end
    end

    class URLPDFSource < Anthropic::Internal::Type::BaseModel
      sig { returns(Symbol) }
      attr_accessor :type

      sig { returns(String) }
      attr_accessor :url

      sig { override.returns({ type: Symbol, url: String }) }
      def to_hash; end

      class << self
        sig { params(url: String, type: Symbol).returns(T.attached_class) }
        def new(url:, type: :url); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::URLPDFSource, Anthropic::Internal::AnyHash)
        end
    end

    class Usage < Anthropic::Internal::Type::BaseModel
      # The number of input tokens used to create the cache entry.
      sig { returns(T.nilable(Integer)) }
      attr_accessor :cache_creation_input_tokens

      # The number of input tokens read from the cache.
      sig { returns(T.nilable(Integer)) }
      attr_accessor :cache_read_input_tokens

      # The number of input tokens which were used.
      sig { returns(Integer) }
      attr_accessor :input_tokens

      # The number of output tokens which were used.
      sig { returns(Integer) }
      attr_accessor :output_tokens

      # The number of server tool requests.
      sig { returns(T.nilable(Anthropic::ServerToolUsage)) }
      attr_reader :server_tool_use

      sig { params(server_tool_use: T.nilable(Anthropic::ServerToolUsage::OrHash)).void }
      attr_writer :server_tool_use

      # If the request used the priority, standard, or batch tier.
      sig { returns(T.nilable(Anthropic::Usage::ServiceTier::TaggedSymbol)) }
      attr_accessor :service_tier

      sig do
        override
          .returns({
            cache_creation_input_tokens: T.nilable(Integer),
            cache_read_input_tokens: T.nilable(Integer),
            input_tokens: Integer,
            output_tokens: Integer,
            server_tool_use: T.nilable(Anthropic::ServerToolUsage),
            service_tier: T.nilable(Anthropic::Usage::ServiceTier::TaggedSymbol)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            cache_creation_input_tokens: T.nilable(Integer),
            cache_read_input_tokens: T.nilable(Integer),
            input_tokens: Integer,
            output_tokens: Integer,
            server_tool_use: T.nilable(Anthropic::ServerToolUsage::OrHash),
            service_tier: T.nilable(Anthropic::Usage::ServiceTier::OrSymbol)
          ).returns(T.attached_class)
        end
        def new(
          cache_creation_input_tokens:, # The number of input tokens used to create the cache entry.
          cache_read_input_tokens:, # The number of input tokens read from the cache.
          input_tokens:, # The number of input tokens which were used.
          output_tokens:, # The number of output tokens which were used.
          server_tool_use:, # The number of server tool requests.
          service_tier: # If the request used the priority, standard, or batch tier.
); end
      end

      OrHash = T.type_alias { T.any(Anthropic::Usage, Anthropic::Internal::AnyHash) }

      # If the request used the priority, standard, or batch tier.
      module ServiceTier
        extend Anthropic::Internal::Type::Enum

        class << self
          sig { override.returns(T::Array[Anthropic::Usage::ServiceTier::TaggedSymbol]) }
          def values; end
        end

        BATCH = T.let(:batch, Anthropic::Usage::ServiceTier::TaggedSymbol)
        OrSymbol = T.type_alias { T.any(Symbol, String) }
        PRIORITY = T.let(:priority, Anthropic::Usage::ServiceTier::TaggedSymbol)
        STANDARD = T.let(:standard, Anthropic::Usage::ServiceTier::TaggedSymbol)

        TaggedSymbol = T.type_alias { T.all(Symbol, Anthropic::Usage::ServiceTier) }
      end
    end

    class WebSearchResultBlock < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :encrypted_content

      sig { returns(T.nilable(String)) }
      attr_accessor :page_age

      sig { returns(String) }
      attr_accessor :title

      sig { returns(Symbol) }
      attr_accessor :type

      sig { returns(String) }
      attr_accessor :url

      sig do
        override
          .returns({
            encrypted_content: String,
            page_age: T.nilable(String),
            title: String,
            type: Symbol,
            url: String
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            encrypted_content: String,
            page_age: T.nilable(String),
            title: String,
            url: String,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(encrypted_content:, page_age:, title:, url:, type: :web_search_result); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::WebSearchResultBlock, Anthropic::Internal::AnyHash)
        end
    end

    class WebSearchResultBlockParam < Anthropic::Internal::Type::BaseModel
      sig { returns(String) }
      attr_accessor :encrypted_content

      sig { returns(T.nilable(String)) }
      attr_accessor :page_age

      sig { returns(String) }
      attr_accessor :title

      sig { returns(Symbol) }
      attr_accessor :type

      sig { returns(String) }
      attr_accessor :url

      sig do
        override
          .returns({
            encrypted_content: String,
            title: String,
            type: Symbol,
            url: String,
            page_age: T.nilable(String)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            encrypted_content: String,
            title: String,
            url: String,
            page_age: T.nilable(String),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(encrypted_content:, title:, url:, page_age: nil, type: :web_search_result); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::WebSearchResultBlockParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class WebSearchTool20250305 < Anthropic::Internal::Type::BaseModel
      # If provided, only these domains will be included in results. Cannot be used
      # alongside `blocked_domains`.
      sig { returns(T.nilable(T::Array[String])) }
      attr_accessor :allowed_domains

      # If provided, these domains will never appear in results. Cannot be used
      # alongside `allowed_domains`.
      sig { returns(T.nilable(T::Array[String])) }
      attr_accessor :blocked_domains

      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      # Maximum number of times the tool can be used in the API request.
      sig { returns(T.nilable(Integer)) }
      attr_accessor :max_uses

      # Name of the tool.
      #
      # This is how the tool will be called by the model and in `tool_use` blocks.
      sig { returns(Symbol) }
      attr_accessor :name

      sig { returns(Symbol) }
      attr_accessor :type

      # Parameters for the user's location. Used to provide more relevant search
      # results.
      sig { returns(T.nilable(Anthropic::WebSearchTool20250305::UserLocation)) }
      attr_reader :user_location

      sig { params(user_location: T.nilable(Anthropic::WebSearchTool20250305::UserLocation::OrHash)).void }
      attr_writer :user_location

      sig do
        override
          .returns({
            name: Symbol,
            type: Symbol,
            allowed_domains: T.nilable(T::Array[String]),
            blocked_domains: T.nilable(T::Array[String]),
            cache_control: T.nilable(Anthropic::CacheControlEphemeral),
            max_uses: T.nilable(Integer),
            user_location:
              T.nilable(Anthropic::WebSearchTool20250305::UserLocation)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            allowed_domains: T.nilable(T::Array[String]),
            blocked_domains: T.nilable(T::Array[String]),
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            max_uses: T.nilable(Integer),
            user_location: T.nilable(Anthropic::WebSearchTool20250305::UserLocation::OrHash),
            name: Symbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          allowed_domains: nil, # If provided, only these domains will be included in results. Cannot be used
                                # alongside `blocked_domains`.
          blocked_domains: nil, # If provided, these domains will never appear in results. Cannot be used
                                # alongside `allowed_domains`.
          cache_control: nil, # Create a cache control breakpoint at this content block.
          max_uses: nil, # Maximum number of times the tool can be used in the API request.
          user_location: nil, # Parameters for the user's location. Used to provide more relevant search
                              # results.
          name: :web_search, # Name of the tool.
                             # This is how the tool will be called by the model and in `tool_use` blocks.
          type: :web_search_20250305
); end
      end

      OrHash = T.type_alias do
          T.any(Anthropic::WebSearchTool20250305, Anthropic::Internal::AnyHash)
        end

      class UserLocation < Anthropic::Internal::Type::BaseModel
        # The city of the user.
        sig { returns(T.nilable(String)) }
        attr_accessor :city

        # The two letter
        # [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
        # user.
        sig { returns(T.nilable(String)) }
        attr_accessor :country

        # The region of the user.
        sig { returns(T.nilable(String)) }
        attr_accessor :region

        # The [IANA timezone](https://nodatime.org/TimeZones) of the user.
        sig { returns(T.nilable(String)) }
        attr_accessor :timezone

        sig { returns(Symbol) }
        attr_accessor :type

        sig do
          override
            .returns({
              type: Symbol,
              city: T.nilable(String),
              country: T.nilable(String),
              region: T.nilable(String),
              timezone: T.nilable(String)
            })
        end
        def to_hash; end

        class << self
          # Parameters for the user's location. Used to provide more relevant search
          # results.
          sig do
            params(
              city: T.nilable(String),
              country: T.nilable(String),
              region: T.nilable(String),
              timezone: T.nilable(String),
              type: Symbol
            ).returns(T.attached_class)
          end
          def new(
            city: nil, # The city of the user.
            country: nil, # The two letter
                          # [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the
                          # user.
            region: nil, # The region of the user.
            timezone: nil, # The [IANA timezone](https://nodatime.org/TimeZones) of the user.
            type: :approximate
); end
        end

        OrHash = T.type_alias do
            T.any(
              Anthropic::WebSearchTool20250305::UserLocation,
              Anthropic::Internal::AnyHash
            )
          end
      end
    end

    class WebSearchToolRequestError < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::WebSearchToolRequestError::ErrorCode::OrSymbol) }
      attr_accessor :error_code

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            error_code:
              Anthropic::WebSearchToolRequestError::ErrorCode::OrSymbol,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            error_code: Anthropic::WebSearchToolRequestError::ErrorCode::OrSymbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(error_code:, type: :web_search_tool_result_error); end
      end

      module ErrorCode
        extend Anthropic::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::WebSearchToolRequestError::ErrorCode::TaggedSymbol
            ])
          end
          def values; end
        end

        INVALID_TOOL_INPUT = T.let(
            :invalid_tool_input,
            Anthropic::WebSearchToolRequestError::ErrorCode::TaggedSymbol
          )

        MAX_USES_EXCEEDED = T.let(
            :max_uses_exceeded,
            Anthropic::WebSearchToolRequestError::ErrorCode::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        QUERY_TOO_LONG = T.let(
            :query_too_long,
            Anthropic::WebSearchToolRequestError::ErrorCode::TaggedSymbol
          )

        TOO_MANY_REQUESTS = T.let(
            :too_many_requests,
            Anthropic::WebSearchToolRequestError::ErrorCode::TaggedSymbol
          )

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Anthropic::WebSearchToolRequestError::ErrorCode)
          end

        UNAVAILABLE = T.let(
            :unavailable,
            Anthropic::WebSearchToolRequestError::ErrorCode::TaggedSymbol
          )
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::WebSearchToolRequestError,
            Anthropic::Internal::AnyHash
          )
        end
    end

    class WebSearchToolResultBlock < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::WebSearchToolResultBlockContent::Variants) }
      attr_accessor :content

      sig { returns(String) }
      attr_accessor :tool_use_id

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            content: Anthropic::WebSearchToolResultBlockContent::Variants,
            tool_use_id: String,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            content: T.any(
              Anthropic::WebSearchToolResultError::OrHash,
              T::Array[Anthropic::WebSearchResultBlock::OrHash]
            ),
            tool_use_id: String,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(content:, tool_use_id:, type: :web_search_tool_result); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::WebSearchToolResultBlock,
            Anthropic::Internal::AnyHash
          )
        end
    end

    module WebSearchToolResultBlockContent
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::WebSearchToolResultBlockContent::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            Anthropic::WebSearchToolResultError,
            T::Array[Anthropic::WebSearchResultBlock]
          )
        end

      WebSearchResultBlockArray = T.let(
          Anthropic::Internal::Type::ArrayOf[Anthropic::WebSearchResultBlock],
          Anthropic::Internal::Type::Converter
        )
    end

    class WebSearchToolResultBlockParam < Anthropic::Internal::Type::BaseModel
      # Create a cache control breakpoint at this content block.
      sig { returns(T.nilable(Anthropic::CacheControlEphemeral)) }
      attr_reader :cache_control

      sig { params(cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash)).void }
      attr_writer :cache_control

      sig do
        returns(T.any(
            T::Array[Anthropic::WebSearchResultBlockParam],
            Anthropic::WebSearchToolRequestError
          ))
      end
      attr_accessor :content

      sig { returns(String) }
      attr_accessor :tool_use_id

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            content:
              T.any(
                T::Array[Anthropic::WebSearchResultBlockParam],
                Anthropic::WebSearchToolRequestError
              ),
            tool_use_id: String,
            type: Symbol,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral)
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            content: T.any(
              T::Array[Anthropic::WebSearchResultBlockParam::OrHash],
              Anthropic::WebSearchToolRequestError::OrHash
            ),
            tool_use_id: String,
            cache_control: T.nilable(Anthropic::CacheControlEphemeral::OrHash),
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(
          content:,
          tool_use_id:,
          cache_control: nil, # Create a cache control breakpoint at this content block.
          type: :web_search_tool_result
); end
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::WebSearchToolResultBlockParam,
            Anthropic::Internal::AnyHash
          )
        end
    end

    module WebSearchToolResultBlockParamContent
      extend Anthropic::Internal::Type::Union

      class << self
        sig { override.returns(T::Array[Anthropic::WebSearchToolResultBlockParamContent::Variants]) }
        def variants; end
      end

      Variants = T.type_alias do
          T.any(
            T::Array[Anthropic::WebSearchResultBlockParam],
            Anthropic::WebSearchToolRequestError
          )
        end

      WebSearchResultBlockParamArray = T.let(
          Anthropic::Internal::Type::ArrayOf[
            Anthropic::WebSearchResultBlockParam
          ],
          Anthropic::Internal::Type::Converter
        )
    end

    class WebSearchToolResultError < Anthropic::Internal::Type::BaseModel
      sig { returns(Anthropic::WebSearchToolResultError::ErrorCode::TaggedSymbol) }
      attr_accessor :error_code

      sig { returns(Symbol) }
      attr_accessor :type

      sig do
        override
          .returns({
            error_code:
              Anthropic::WebSearchToolResultError::ErrorCode::TaggedSymbol,
            type: Symbol
          })
      end
      def to_hash; end

      class << self
        sig do
          params(
            error_code: Anthropic::WebSearchToolResultError::ErrorCode::OrSymbol,
            type: Symbol
          ).returns(T.attached_class)
        end
        def new(error_code:, type: :web_search_tool_result_error); end
      end

      module ErrorCode
        extend Anthropic::Internal::Type::Enum

        class << self
          sig do
            override
              .returns(T::Array[
              Anthropic::WebSearchToolResultError::ErrorCode::TaggedSymbol
            ])
          end
          def values; end
        end

        INVALID_TOOL_INPUT = T.let(
            :invalid_tool_input,
            Anthropic::WebSearchToolResultError::ErrorCode::TaggedSymbol
          )

        MAX_USES_EXCEEDED = T.let(
            :max_uses_exceeded,
            Anthropic::WebSearchToolResultError::ErrorCode::TaggedSymbol
          )

        OrSymbol = T.type_alias { T.any(Symbol, String) }

        QUERY_TOO_LONG = T.let(
            :query_too_long,
            Anthropic::WebSearchToolResultError::ErrorCode::TaggedSymbol
          )

        TOO_MANY_REQUESTS = T.let(
            :too_many_requests,
            Anthropic::WebSearchToolResultError::ErrorCode::TaggedSymbol
          )

        TaggedSymbol = T.type_alias do
            T.all(Symbol, Anthropic::WebSearchToolResultError::ErrorCode)
          end

        UNAVAILABLE = T.let(
            :unavailable,
            Anthropic::WebSearchToolResultError::ErrorCode::TaggedSymbol
          )
      end

      OrHash = T.type_alias do
          T.any(
            Anthropic::WebSearchToolResultError,
            Anthropic::Internal::AnyHash
          )
        end
    end
  end

  NotFoundError = Anthropic::Models::NotFoundError
  OverloadedError = Anthropic::Models::OverloadedError
  PermissionError = Anthropic::Models::PermissionError
  PlainTextSource = Anthropic::Models::PlainTextSource
  RateLimitError = Anthropic::Models::RateLimitError
  RawContentBlockDelta = Anthropic::Models::RawContentBlockDelta
  RawContentBlockDeltaEvent = Anthropic::Models::RawContentBlockDeltaEvent
  RawContentBlockStartEvent = Anthropic::Models::RawContentBlockStartEvent
  RawContentBlockStopEvent = Anthropic::Models::RawContentBlockStopEvent
  RawMessageDeltaEvent = Anthropic::Models::RawMessageDeltaEvent
  RawMessageStartEvent = Anthropic::Models::RawMessageStartEvent
  RawMessageStopEvent = Anthropic::Models::RawMessageStopEvent
  RawMessageStreamEvent = Anthropic::Models::RawMessageStreamEvent
  RedactedThinkingBlock = Anthropic::Models::RedactedThinkingBlock
  RedactedThinkingBlockParam = Anthropic::Models::RedactedThinkingBlockParam

  # Specify HTTP behaviour to use for a specific request. These options supplement
  # or override those provided at the client level.
  #
  # When making a request, you can pass an actual {RequestOptions} instance, or
  # simply pass a Hash with symbol keys matching the attributes on this class.
  class RequestOptions < Anthropic::Internal::Type::BaseModel
    # Extra data to send with the request. These are deep merged into any data
    # generated as part of the normal request.
    sig { returns(T.nilable(T.anything)) }
    attr_accessor :extra_body

    # Extra headers to send with the request. These are `.merged`d into any
    # `extra_headers` given at the client level.
    sig { returns(T.nilable(T::Hash[String, T.nilable(String)])) }
    attr_accessor :extra_headers

    # Extra query params to send with the request. These are `.merge`d into any
    # `query` given at the client level.
    sig { returns(T.nilable(T::Hash[String, T.nilable(T.any(T::Array[String], String))])) }
    attr_accessor :extra_query

    # Idempotency key to send with request and all associated retries. Will only be
    # sent for write requests.
    sig { returns(T.nilable(String)) }
    attr_accessor :idempotency_key

    # Maximum number of retries to attempt after a failed initial request.
    sig { returns(T.nilable(Integer)) }
    attr_accessor :max_retries

    # Request timeout in seconds.
    sig { returns(T.nilable(Float)) }
    attr_accessor :timeout

    class << self
      # Returns a new instance of RequestOptions.
      sig { params(values: Anthropic::Internal::AnyHash).returns(T.attached_class) }
      def new(values = {}); end

      # @api private
      sig { params(opts: Anthropic::RequestOptions::OrHash).void }
      def validate!(opts); end
    end

    OrHash = T.type_alias do
        T.any(Anthropic::RequestOptions, Anthropic::Internal::AnyHash)
      end
  end

  module Resources
    class Beta
      sig { returns(Anthropic::Resources::Beta::Files) }
      attr_reader :files

      sig { returns(Anthropic::Resources::Beta::Messages) }
      attr_reader :messages

      sig { returns(Anthropic::Resources::Beta::Models) }
      attr_reader :models

      class << self
        # @api private
        sig { params(client: Anthropic::Client).returns(T.attached_class) }
        def new(client:); end
      end

      class Files
        # Delete File
        sig do
          params(
            file_id: String,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Beta::DeletedFile)
        end
        def delete(
          file_id, # ID of the File.
          betas: nil, # Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end

        # Download File
        sig do
          params(
            file_id: String,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(StringIO)
        end
        def download(
          file_id, # ID of the File.
          betas: nil, # Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end

        # List Files
        sig do
          params(
            after_id: String,
            before_id: String,
            limit: Integer,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Internal::Page[Anthropic::Beta::FileMetadata])
        end
        def list(
          after_id: nil, # Query param: ID of the object to use as a cursor for pagination. When provided,
                         # returns the page of results immediately after this object.
          before_id: nil, # Query param: ID of the object to use as a cursor for pagination. When provided,
                          # returns the page of results immediately before this object.
          limit: nil, # Query param: Number of items to return per page.
                      # Defaults to `20`. Ranges from `1` to `1000`.
          betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end

        # Get File Metadata
        sig do
          params(
            file_id: String,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Beta::FileMetadata)
        end
        def retrieve_metadata(
          file_id, # ID of the File.
          betas: nil, # Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end

        # Upload File
        sig do
          params(
            file: Anthropic::Internal::FileInput,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Beta::FileMetadata)
        end
        def upload(
          file:, # Body param: The file to upload
          betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end

        class << self
          # @api private
          sig { params(client: Anthropic::Client).returns(T.attached_class) }
          def new(client:); end
        end
      end

      class Messages
        sig { returns(Anthropic::Resources::Beta::Messages::Batches) }
        attr_reader :batches

        # Count the number of tokens in a Message.
        #
        # The Token Count API can be used to count the number of tokens in a Message,
        # including tools, images, and documents, without creating it.
        #
        # Learn more about token counting in our
        # [user guide](/en/docs/build-with-claude/token-counting)
        sig do
          params(
            messages: T::Array[Anthropic::Beta::BetaMessageParam::OrHash],
            model: T.any(Anthropic::Model::OrSymbol, String),
            mcp_servers: T::Array[
                Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
              ],
            system_: Anthropic::Beta::MessageCountTokensParams::System::Variants,
            thinking: T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
              ),
            tool_choice: T.any(
                Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                Anthropic::Beta::BetaToolChoiceAny::OrHash,
                Anthropic::Beta::BetaToolChoiceTool::OrHash,
                Anthropic::Beta::BetaToolChoiceNone::OrHash
              ),
            tools: T::Array[
                T.any(
                  Anthropic::Beta::BetaTool::OrHash,
                  Anthropic::Beta::BetaToolBash20241022::OrHash,
                  Anthropic::Beta::BetaToolBash20250124::OrHash,
                  Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                  Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                )
              ],
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Beta::BetaMessageTokensCount)
        end
        def count_tokens(
          messages:, # Body param: Input messages.
                     # Our models are trained to operate on alternating `user` and `assistant`
                     # conversational turns. When creating a new `Message`, you specify the prior
                     # conversational turns with the `messages` parameter, and the model then generates
                     # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                     # in your request will be combined into a single turn.
                     # Each input message must be an object with a `role` and `content`. You can
                     # specify a single `user`-role message, or you can include multiple `user` and
                     # `assistant` messages.
                     # If the final message uses the `assistant` role, the response content will
                     # continue immediately from the content in that message. This can be used to
                     # constrain part of the model's response.
                     # Example with a single `user` message:
                     # ```json
                     # [{ "role": "user", "content": "Hello, Claude" }]
                     # ```
                     # Example with multiple conversational turns:
                     # ```json
                     # [
                     #   { "role": "user", "content": "Hello there." },
                     #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                     #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                     # ]
                     # ```
                     # Example with a partially-filled response from Claude:
                     # ```json
                     # [
                     #   {
                     #     "role": "user",
                     #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                     #   },
                     #   { "role": "assistant", "content": "The best answer is (" }
                     # ]
                     # ```
                     # Each input message `content` may be either a single `string` or an array of
                     # content blocks, where each block has a specific `type`. Using a `string` for
                     # `content` is shorthand for an array of one content block of type `"text"`. The
                     # following input messages are equivalent:
                     # ```json
                     # { "role": "user", "content": "Hello, Claude" }
                     # ```
                     # ```json
                     # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                     # ```
                     # Starting with Claude 3 models, you can also send image content blocks:
                     # ```json
                     # {
                     #   "role": "user",
                     #   "content": [
                     #     {
                     #       "type": "image",
                     #       "source": {
                     #         "type": "base64",
                     #         "media_type": "image/jpeg",
                     #         "data": "/9j/4AAQSkZJRg..."
                     #       }
                     #     },
                     #     { "type": "text", "text": "What is in this image?" }
                     #   ]
                     # }
                     # ```
                     # We currently support the `base64` source type for images, and the `image/jpeg`,
                     # `image/png`, `image/gif`, and `image/webp` media types.
                     # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                     # more input examples.
                     # Note that if you want to include a
                     # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                     # the top-level `system` parameter  there is no `"system"` role for input
                     # messages in the Messages API.
                     # There is a limit of 100,000 messages in a single request.
          model:, # Body param: The model that will complete your prompt.\n\nSee
                  # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                  # details and options.
          mcp_servers: nil, # Body param: MCP servers to be utilized in this request
          system_: nil, # Body param: System prompt.
                        # A system prompt is a way of providing context and instructions to Claude, such
                        # as specifying a particular goal or role. See our
                        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
          thinking: nil, # Body param: Configuration for enabling Claude's extended thinking.
                         # When enabled, responses include `thinking` content blocks showing Claude's
                         # thinking process before the final answer. Requires a minimum budget of 1,024
                         # tokens and counts towards your `max_tokens` limit.
                         # See
                         # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                         # for details.
          tool_choice: nil, # Body param: How the model should use the provided tools. The model can use a
                            # specific tool, any available tool, decide by itself, or not use tools at all.
          tools: nil, # Body param: Definitions of tools that the model may use.
                      # If you include `tools` in your API request, the model may return `tool_use`
                      # content blocks that represent the model's use of those tools. You can then run
                      # those tools using the tool input generated by the model and then optionally
                      # return results back to the model using `tool_result` content blocks.
                      # There are two types of tools: **client tools** and **server tools**. The
                      # behavior described below applies to client tools. For
                      # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                      # see their individual documentation as each has its own behavior (e.g., the
                      # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                      # Each tool definition includes:
                      # - `name`: Name of the tool.
                      # - `description`: Optional, but strongly-recommended description of the tool.
                      # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                      #   tool `input` shape that the model will produce in `tool_use` output content
                      #   blocks.
                      # For example, if you defined `tools` as:
                      # ```json
                      # [
                      #   {
                      #     "name": "get_stock_price",
                      #     "description": "Get the current stock price for a given ticker symbol.",
                      #     "input_schema": {
                      #       "type": "object",
                      #       "properties": {
                      #         "ticker": {
                      #           "type": "string",
                      #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                      #         }
                      #       },
                      #       "required": ["ticker"]
                      #     }
                      #   }
                      # ]
                      # ```
                      # And then asked the model "What's the S&P 500 at today?", the model might produce
                      # `tool_use` content blocks in the response like this:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_use",
                      #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "name": "get_stock_price",
                      #     "input": { "ticker": "^GSPC" }
                      #   }
                      # ]
                      # ```
                      # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                      # input, and return the following back to the model in a subsequent `user`
                      # message:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_result",
                      #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "content": "259.75 USD"
                      #   }
                      # ]
                      # ```
                      # Tools can be used for workflows that include running client-side tools and
                      # functions, or more generally whenever you want the model to produce a particular
                      # JSON structure of output.
                      # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
          betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end

        # See {Anthropic::Resources::Beta::Messages#stream_raw} for streaming counterpart.
        #
        # Send a structured list of input messages with text and/or image content, and the
        # model will generate the next message in the conversation.
        #
        # The Messages API can be used for either single queries or stateless multi-turn
        # conversations.
        #
        # Learn more about the Messages API in our [user guide](/en/docs/initial-setup)
        sig do
          params(
            max_tokens: Integer,
            messages: T::Array[Anthropic::Beta::BetaMessageParam::OrHash],
            model: T.any(Anthropic::Model::OrSymbol, String),
            container: T.nilable(String),
            mcp_servers: T::Array[
                Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
              ],
            metadata: Anthropic::Beta::BetaMetadata::OrHash,
            service_tier: Anthropic::Beta::MessageCreateParams::ServiceTier::OrSymbol,
            stop_sequences: T::Array[String],
            system_: Anthropic::Beta::MessageCreateParams::System::Variants,
            temperature: Float,
            thinking: T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
              ),
            tool_choice: T.any(
                Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                Anthropic::Beta::BetaToolChoiceAny::OrHash,
                Anthropic::Beta::BetaToolChoiceTool::OrHash,
                Anthropic::Beta::BetaToolChoiceNone::OrHash
              ),
            tools: T::Array[
                T.any(
                  Anthropic::Beta::BetaTool::OrHash,
                  Anthropic::Beta::BetaToolBash20241022::OrHash,
                  Anthropic::Beta::BetaToolBash20250124::OrHash,
                  Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                  Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                )
              ],
            top_k: Integer,
            top_p: Float,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            stream: T.noreturn,
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Beta::BetaMessage)
        end
        def create(
          max_tokens:, # Body param: The maximum number of tokens to generate before stopping.
                       # Note that our models may stop _before_ reaching this maximum. This parameter
                       # only specifies the absolute maximum number of tokens to generate.
                       # Different models have different maximum values for this parameter. See
                       # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
          messages:, # Body param: Input messages.
                     # Our models are trained to operate on alternating `user` and `assistant`
                     # conversational turns. When creating a new `Message`, you specify the prior
                     # conversational turns with the `messages` parameter, and the model then generates
                     # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                     # in your request will be combined into a single turn.
                     # Each input message must be an object with a `role` and `content`. You can
                     # specify a single `user`-role message, or you can include multiple `user` and
                     # `assistant` messages.
                     # If the final message uses the `assistant` role, the response content will
                     # continue immediately from the content in that message. This can be used to
                     # constrain part of the model's response.
                     # Example with a single `user` message:
                     # ```json
                     # [{ "role": "user", "content": "Hello, Claude" }]
                     # ```
                     # Example with multiple conversational turns:
                     # ```json
                     # [
                     #   { "role": "user", "content": "Hello there." },
                     #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                     #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                     # ]
                     # ```
                     # Example with a partially-filled response from Claude:
                     # ```json
                     # [
                     #   {
                     #     "role": "user",
                     #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                     #   },
                     #   { "role": "assistant", "content": "The best answer is (" }
                     # ]
                     # ```
                     # Each input message `content` may be either a single `string` or an array of
                     # content blocks, where each block has a specific `type`. Using a `string` for
                     # `content` is shorthand for an array of one content block of type `"text"`. The
                     # following input messages are equivalent:
                     # ```json
                     # { "role": "user", "content": "Hello, Claude" }
                     # ```
                     # ```json
                     # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                     # ```
                     # Starting with Claude 3 models, you can also send image content blocks:
                     # ```json
                     # {
                     #   "role": "user",
                     #   "content": [
                     #     {
                     #       "type": "image",
                     #       "source": {
                     #         "type": "base64",
                     #         "media_type": "image/jpeg",
                     #         "data": "/9j/4AAQSkZJRg..."
                     #       }
                     #     },
                     #     { "type": "text", "text": "What is in this image?" }
                     #   ]
                     # }
                     # ```
                     # We currently support the `base64` source type for images, and the `image/jpeg`,
                     # `image/png`, `image/gif`, and `image/webp` media types.
                     # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                     # more input examples.
                     # Note that if you want to include a
                     # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                     # the top-level `system` parameter  there is no `"system"` role for input
                     # messages in the Messages API.
                     # There is a limit of 100,000 messages in a single request.
          model:, # Body param: The model that will complete your prompt.\n\nSee
                  # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                  # details and options.
          container: nil, # Body param: Container identifier for reuse across requests.
          mcp_servers: nil, # Body param: MCP servers to be utilized in this request
          metadata: nil, # Body param: An object describing metadata about the request.
          service_tier: nil, # Body param: Determines whether to use priority capacity (if available) or
                             # standard capacity for this request.
                             # Anthropic offers different levels of service for your API requests. See
                             # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
          stop_sequences: nil, # Body param: Custom text sequences that will cause the model to stop generating.
                               # Our models will normally stop when they have naturally completed their turn,
                               # which will result in a response `stop_reason` of `"end_turn"`.
                               # If you want the model to stop generating when it encounters custom strings of
                               # text, you can use the `stop_sequences` parameter. If the model encounters one of
                               # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                               # and the response `stop_sequence` value will contain the matched stop sequence.
          system_: nil, # Body param: System prompt.
                        # A system prompt is a way of providing context and instructions to Claude, such
                        # as specifying a particular goal or role. See our
                        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
          temperature: nil, # Body param: Amount of randomness injected into the response.
                            # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                            # for analytical / multiple choice, and closer to `1.0` for creative and
                            # generative tasks.
                            # Note that even with `temperature` of `0.0`, the results will not be fully
                            # deterministic.
          thinking: nil, # Body param: Configuration for enabling Claude's extended thinking.
                         # When enabled, responses include `thinking` content blocks showing Claude's
                         # thinking process before the final answer. Requires a minimum budget of 1,024
                         # tokens and counts towards your `max_tokens` limit.
                         # See
                         # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                         # for details.
          tool_choice: nil, # Body param: How the model should use the provided tools. The model can use a
                            # specific tool, any available tool, decide by itself, or not use tools at all.
          tools: nil, # Body param: Definitions of tools that the model may use.
                      # If you include `tools` in your API request, the model may return `tool_use`
                      # content blocks that represent the model's use of those tools. You can then run
                      # those tools using the tool input generated by the model and then optionally
                      # return results back to the model using `tool_result` content blocks.
                      # There are two types of tools: **client tools** and **server tools**. The
                      # behavior described below applies to client tools. For
                      # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                      # see their individual documentation as each has its own behavior (e.g., the
                      # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                      # Each tool definition includes:
                      # - `name`: Name of the tool.
                      # - `description`: Optional, but strongly-recommended description of the tool.
                      # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                      #   tool `input` shape that the model will produce in `tool_use` output content
                      #   blocks.
                      # For example, if you defined `tools` as:
                      # ```json
                      # [
                      #   {
                      #     "name": "get_stock_price",
                      #     "description": "Get the current stock price for a given ticker symbol.",
                      #     "input_schema": {
                      #       "type": "object",
                      #       "properties": {
                      #         "ticker": {
                      #           "type": "string",
                      #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                      #         }
                      #       },
                      #       "required": ["ticker"]
                      #     }
                      #   }
                      # ]
                      # ```
                      # And then asked the model "What's the S&P 500 at today?", the model might produce
                      # `tool_use` content blocks in the response like this:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_use",
                      #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "name": "get_stock_price",
                      #     "input": { "ticker": "^GSPC" }
                      #   }
                      # ]
                      # ```
                      # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                      # input, and return the following back to the model in a subsequent `user`
                      # message:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_result",
                      #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "content": "259.75 USD"
                      #   }
                      # ]
                      # ```
                      # Tools can be used for workflows that include running client-side tools and
                      # functions, or more generally whenever you want the model to produce a particular
                      # JSON structure of output.
                      # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
          top_k: nil, # Body param: Only sample from the top K options for each subsequent token.
                      # Used to remove "long tail" low probability responses.
                      # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                      # Recommended for advanced use cases only. You usually only need to use
                      # `temperature`.
          top_p: nil, # Body param: Use nucleus sampling.
                      # In nucleus sampling, we compute the cumulative distribution over all the options
                      # for each subsequent token in decreasing probability order and cut it off once it
                      # reaches a particular probability specified by `top_p`. You should either alter
                      # `temperature` or `top_p`, but not both.
                      # Recommended for advanced use cases only. You usually only need to use
                      # `temperature`.
          betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
          stream: false, # There is no need to provide `stream:`. Instead, use `#stream_raw` or `#create`
                         # for streaming and non-streaming use cases, respectively.
          request_options: {}
); end

        # See {Anthropic::Resources::Beta::Messages#create} for non-streaming counterpart.
        #
        # Send a structured list of input messages with text and/or image content, and the
        # model will generate the next message in the conversation.
        #
        # The Messages API can be used for either single queries or stateless multi-turn
        # conversations.
        #
        # Learn more about the Messages API in our [user guide](/en/docs/initial-setup)
        sig do
          params(
            max_tokens: Integer,
            messages: T::Array[Anthropic::Beta::BetaMessageParam::OrHash],
            model: T.any(Anthropic::Model::OrSymbol, String),
            container: T.nilable(String),
            mcp_servers: T::Array[
                Anthropic::Beta::BetaRequestMCPServerURLDefinition::OrHash
              ],
            metadata: Anthropic::Beta::BetaMetadata::OrHash,
            service_tier: Anthropic::Beta::MessageCreateParams::ServiceTier::OrSymbol,
            stop_sequences: T::Array[String],
            system_: Anthropic::Beta::MessageCreateParams::System::Variants,
            temperature: Float,
            thinking: T.any(
                Anthropic::Beta::BetaThinkingConfigEnabled::OrHash,
                Anthropic::Beta::BetaThinkingConfigDisabled::OrHash
              ),
            tool_choice: T.any(
                Anthropic::Beta::BetaToolChoiceAuto::OrHash,
                Anthropic::Beta::BetaToolChoiceAny::OrHash,
                Anthropic::Beta::BetaToolChoiceTool::OrHash,
                Anthropic::Beta::BetaToolChoiceNone::OrHash
              ),
            tools: T::Array[
                T.any(
                  Anthropic::Beta::BetaTool::OrHash,
                  Anthropic::Beta::BetaToolBash20241022::OrHash,
                  Anthropic::Beta::BetaToolBash20250124::OrHash,
                  Anthropic::Beta::BetaCodeExecutionTool20250522::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20241022::OrHash,
                  Anthropic::Beta::BetaToolComputerUse20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20241022::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250124::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250429::OrHash,
                  Anthropic::Beta::BetaToolTextEditor20250728::OrHash,
                  Anthropic::Beta::BetaWebSearchTool20250305::OrHash
                )
              ],
            top_k: Integer,
            top_p: Float,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            stream: T.noreturn,
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Internal::Stream[
              Anthropic::Beta::BetaRawMessageStreamEvent::Variants
            ])
        end
        def stream_raw(
          max_tokens:, # Body param: The maximum number of tokens to generate before stopping.
                       # Note that our models may stop _before_ reaching this maximum. This parameter
                       # only specifies the absolute maximum number of tokens to generate.
                       # Different models have different maximum values for this parameter. See
                       # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
          messages:, # Body param: Input messages.
                     # Our models are trained to operate on alternating `user` and `assistant`
                     # conversational turns. When creating a new `Message`, you specify the prior
                     # conversational turns with the `messages` parameter, and the model then generates
                     # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                     # in your request will be combined into a single turn.
                     # Each input message must be an object with a `role` and `content`. You can
                     # specify a single `user`-role message, or you can include multiple `user` and
                     # `assistant` messages.
                     # If the final message uses the `assistant` role, the response content will
                     # continue immediately from the content in that message. This can be used to
                     # constrain part of the model's response.
                     # Example with a single `user` message:
                     # ```json
                     # [{ "role": "user", "content": "Hello, Claude" }]
                     # ```
                     # Example with multiple conversational turns:
                     # ```json
                     # [
                     #   { "role": "user", "content": "Hello there." },
                     #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                     #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                     # ]
                     # ```
                     # Example with a partially-filled response from Claude:
                     # ```json
                     # [
                     #   {
                     #     "role": "user",
                     #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                     #   },
                     #   { "role": "assistant", "content": "The best answer is (" }
                     # ]
                     # ```
                     # Each input message `content` may be either a single `string` or an array of
                     # content blocks, where each block has a specific `type`. Using a `string` for
                     # `content` is shorthand for an array of one content block of type `"text"`. The
                     # following input messages are equivalent:
                     # ```json
                     # { "role": "user", "content": "Hello, Claude" }
                     # ```
                     # ```json
                     # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                     # ```
                     # Starting with Claude 3 models, you can also send image content blocks:
                     # ```json
                     # {
                     #   "role": "user",
                     #   "content": [
                     #     {
                     #       "type": "image",
                     #       "source": {
                     #         "type": "base64",
                     #         "media_type": "image/jpeg",
                     #         "data": "/9j/4AAQSkZJRg..."
                     #       }
                     #     },
                     #     { "type": "text", "text": "What is in this image?" }
                     #   ]
                     # }
                     # ```
                     # We currently support the `base64` source type for images, and the `image/jpeg`,
                     # `image/png`, `image/gif`, and `image/webp` media types.
                     # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                     # more input examples.
                     # Note that if you want to include a
                     # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                     # the top-level `system` parameter  there is no `"system"` role for input
                     # messages in the Messages API.
                     # There is a limit of 100,000 messages in a single request.
          model:, # Body param: The model that will complete your prompt.\n\nSee
                  # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                  # details and options.
          container: nil, # Body param: Container identifier for reuse across requests.
          mcp_servers: nil, # Body param: MCP servers to be utilized in this request
          metadata: nil, # Body param: An object describing metadata about the request.
          service_tier: nil, # Body param: Determines whether to use priority capacity (if available) or
                             # standard capacity for this request.
                             # Anthropic offers different levels of service for your API requests. See
                             # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
          stop_sequences: nil, # Body param: Custom text sequences that will cause the model to stop generating.
                               # Our models will normally stop when they have naturally completed their turn,
                               # which will result in a response `stop_reason` of `"end_turn"`.
                               # If you want the model to stop generating when it encounters custom strings of
                               # text, you can use the `stop_sequences` parameter. If the model encounters one of
                               # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                               # and the response `stop_sequence` value will contain the matched stop sequence.
          system_: nil, # Body param: System prompt.
                        # A system prompt is a way of providing context and instructions to Claude, such
                        # as specifying a particular goal or role. See our
                        # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
          temperature: nil, # Body param: Amount of randomness injected into the response.
                            # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                            # for analytical / multiple choice, and closer to `1.0` for creative and
                            # generative tasks.
                            # Note that even with `temperature` of `0.0`, the results will not be fully
                            # deterministic.
          thinking: nil, # Body param: Configuration for enabling Claude's extended thinking.
                         # When enabled, responses include `thinking` content blocks showing Claude's
                         # thinking process before the final answer. Requires a minimum budget of 1,024
                         # tokens and counts towards your `max_tokens` limit.
                         # See
                         # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                         # for details.
          tool_choice: nil, # Body param: How the model should use the provided tools. The model can use a
                            # specific tool, any available tool, decide by itself, or not use tools at all.
          tools: nil, # Body param: Definitions of tools that the model may use.
                      # If you include `tools` in your API request, the model may return `tool_use`
                      # content blocks that represent the model's use of those tools. You can then run
                      # those tools using the tool input generated by the model and then optionally
                      # return results back to the model using `tool_result` content blocks.
                      # There are two types of tools: **client tools** and **server tools**. The
                      # behavior described below applies to client tools. For
                      # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                      # see their individual documentation as each has its own behavior (e.g., the
                      # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                      # Each tool definition includes:
                      # - `name`: Name of the tool.
                      # - `description`: Optional, but strongly-recommended description of the tool.
                      # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                      #   tool `input` shape that the model will produce in `tool_use` output content
                      #   blocks.
                      # For example, if you defined `tools` as:
                      # ```json
                      # [
                      #   {
                      #     "name": "get_stock_price",
                      #     "description": "Get the current stock price for a given ticker symbol.",
                      #     "input_schema": {
                      #       "type": "object",
                      #       "properties": {
                      #         "ticker": {
                      #           "type": "string",
                      #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                      #         }
                      #       },
                      #       "required": ["ticker"]
                      #     }
                      #   }
                      # ]
                      # ```
                      # And then asked the model "What's the S&P 500 at today?", the model might produce
                      # `tool_use` content blocks in the response like this:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_use",
                      #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "name": "get_stock_price",
                      #     "input": { "ticker": "^GSPC" }
                      #   }
                      # ]
                      # ```
                      # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                      # input, and return the following back to the model in a subsequent `user`
                      # message:
                      # ```json
                      # [
                      #   {
                      #     "type": "tool_result",
                      #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                      #     "content": "259.75 USD"
                      #   }
                      # ]
                      # ```
                      # Tools can be used for workflows that include running client-side tools and
                      # functions, or more generally whenever you want the model to produce a particular
                      # JSON structure of output.
                      # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
          top_k: nil, # Body param: Only sample from the top K options for each subsequent token.
                      # Used to remove "long tail" low probability responses.
                      # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                      # Recommended for advanced use cases only. You usually only need to use
                      # `temperature`.
          top_p: nil, # Body param: Use nucleus sampling.
                      # In nucleus sampling, we compute the cumulative distribution over all the options
                      # for each subsequent token in decreasing probability order and cut it off once it
                      # reaches a particular probability specified by `top_p`. You should either alter
                      # `temperature` or `top_p`, but not both.
                      # Recommended for advanced use cases only. You usually only need to use
                      # `temperature`.
          betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
          stream: true, # There is no need to provide `stream:`. Instead, use `#stream_raw` or `#create`
                        # for streaming and non-streaming use cases, respectively.
          request_options: {}
); end

        class << self
          # @api private
          sig { params(client: Anthropic::Client).returns(T.attached_class) }
          def new(client:); end
        end

        class Batches
          # Batches may be canceled any time before processing ends. Once cancellation is
          # initiated, the batch enters a `canceling` state, at which time the system may
          # complete any in-progress, non-interruptible requests before finalizing
          # cancellation.
          #
          # The number of canceled requests is specified in `request_counts`. To determine
          # which requests were canceled, check the individual results within the batch.
          # Note that cancellation may not result in any canceled requests if they were
          # non-interruptible.
          #
          # Learn more about the Message Batches API in our
          # [user guide](/en/docs/build-with-claude/batch-processing)
          sig do
            params(
              message_batch_id: String,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(Anthropic::Beta::Messages::BetaMessageBatch)
          end
          def cancel(
            message_batch_id, # ID of the Message Batch.
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end

          # Send a batch of Message creation requests.
          #
          # The Message Batches API can be used to process multiple Messages API requests at
          # once. Once a Message Batch is created, it begins processing immediately. Batches
          # can take up to 24 hours to complete.
          #
          # Learn more about the Message Batches API in our
          # [user guide](/en/docs/build-with-claude/batch-processing)
          sig do
            params(
              requests: T::Array[
                  Anthropic::Beta::Messages::BatchCreateParams::Request::OrHash
                ],
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(Anthropic::Beta::Messages::BetaMessageBatch)
          end
          def create(
            requests:, # Body param: List of requests for prompt completion. Each is an individual
                       # request to create a Message.
            betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end

          # Delete a Message Batch.
          #
          # Message Batches can only be deleted once they've finished processing. If you'd
          # like to delete an in-progress batch, you must first cancel it.
          #
          # Learn more about the Message Batches API in our
          # [user guide](/en/docs/build-with-claude/batch-processing)
          sig do
            params(
              message_batch_id: String,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(Anthropic::Beta::Messages::BetaDeletedMessageBatch)
          end
          def delete(
            message_batch_id, # ID of the Message Batch.
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end

          # List all Message Batches within a Workspace. Most recently created batches are
          # returned first.
          #
          # Learn more about the Message Batches API in our
          # [user guide](/en/docs/build-with-claude/batch-processing)
          sig do
            params(
              after_id: String,
              before_id: String,
              limit: Integer,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(Anthropic::Internal::Page[
                Anthropic::Beta::Messages::BetaMessageBatch
              ])
          end
          def list(
            after_id: nil, # Query param: ID of the object to use as a cursor for pagination. When provided,
                           # returns the page of results immediately after this object.
            before_id: nil, # Query param: ID of the object to use as a cursor for pagination. When provided,
                            # returns the page of results immediately before this object.
            limit: nil, # Query param: Number of items to return per page.
                        # Defaults to `20`. Ranges from `1` to `1000`.
            betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end

          # Streams the results of a Message Batch as a `.jsonl` file.
          #
          # Each line in the file is a JSON object containing the result of a single request
          # in the Message Batch. Results are not guaranteed to be in the same order as
          # requests. Use the `custom_id` field to match results to requests.
          #
          # Learn more about the Message Batches API in our
          # [user guide](/en/docs/build-with-claude/batch-processing)
          sig do
            params(
              message_batch_id: String,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(Anthropic::Internal::JsonLStream[
                Anthropic::Beta::Messages::BetaMessageBatchIndividualResponse
              ])
          end
          def results_streaming(
            message_batch_id, # ID of the Message Batch.
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end

          # This endpoint is idempotent and can be used to poll for Message Batch
          # completion. To access the results of a Message Batch, make a request to the
          # `results_url` field in the response.
          #
          # Learn more about the Message Batches API in our
          # [user guide](/en/docs/build-with-claude/batch-processing)
          sig do
            params(
              message_batch_id: String,
              betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
              request_options: Anthropic::RequestOptions::OrHash
            ).returns(Anthropic::Beta::Messages::BetaMessageBatch)
          end
          def retrieve(
            message_batch_id, # ID of the Message Batch.
            betas: nil, # Optional header to specify the beta version(s) you want to use.
            request_options: {}
); end

          class << self
            # @api private
            sig { params(client: Anthropic::Client).returns(T.attached_class) }
            def new(client:); end
          end
        end
      end

      class Models
        # List available models.
        #
        # The Models API response can be used to determine which models are available for
        # use in the API. More recently released models are listed first.
        sig do
          params(
            after_id: String,
            before_id: String,
            limit: Integer,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Internal::Page[Anthropic::Beta::BetaModelInfo])
        end
        def list(
          after_id: nil, # Query param: ID of the object to use as a cursor for pagination. When provided,
                         # returns the page of results immediately after this object.
          before_id: nil, # Query param: ID of the object to use as a cursor for pagination. When provided,
                          # returns the page of results immediately before this object.
          limit: nil, # Query param: Number of items to return per page.
                      # Defaults to `20`. Ranges from `1` to `1000`.
          betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end

        # Get a specific model.
        #
        # The Models API response can be used to determine information about a specific
        # model or resolve a model alias to a model ID.
        sig do
          params(
            model_id: String,
            betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Beta::BetaModelInfo)
        end
        def retrieve(
          model_id, # Model identifier or alias.
          betas: nil, # Optional header to specify the beta version(s) you want to use.
          request_options: {}
); end

        class << self
          # @api private
          sig { params(client: Anthropic::Client).returns(T.attached_class) }
          def new(client:); end
        end
      end
    end

    class Completions
      # See {Anthropic::Resources::Completions#create_streaming} for streaming
      # counterpart.
      #
      # [Legacy] Create a Text Completion.
      #
      # The Text Completions API is a legacy API. We recommend using the
      # [Messages API](https://docs.anthropic.com/en/api/messages) going forward.
      #
      # Future models and features will not be compatible with Text Completions. See our
      # [migration guide](https://docs.anthropic.com/en/api/migrating-from-text-completions-to-messages)
      # for guidance in migrating from Text Completions to Messages.
      sig do
        params(
          max_tokens_to_sample: Integer,
          model: T.any(Anthropic::Model::OrSymbol, String),
          prompt: String,
          metadata: Anthropic::Metadata::OrHash,
          stop_sequences: T::Array[String],
          temperature: Float,
          top_k: Integer,
          top_p: Float,
          betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
          stream: T.noreturn,
          request_options: Anthropic::RequestOptions::OrHash
        ).returns(Anthropic::Completion)
      end
      def create(
        max_tokens_to_sample:, # Body param: The maximum number of tokens to generate before stopping.
                               # Note that our models may stop _before_ reaching this maximum. This parameter
                               # only specifies the absolute maximum number of tokens to generate.
        model:, # Body param: The model that will complete your prompt.\n\nSee
                # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                # details and options.
        prompt:, # Body param: The prompt that you want Claude to complete.
                 # For proper response generation you will need to format your prompt using
                 # alternating `\n\nHuman:` and `\n\nAssistant:` conversational turns. For example:
                 # ```
                 # "\n\nHuman: {userQuestion}\n\nAssistant:"
                 # ```
                 # See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and
                 # our guide to
                 # [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more
                 # details.
        metadata: nil, # Body param: An object describing metadata about the request.
        stop_sequences: nil, # Body param: Sequences that will cause the model to stop generating.
                             # Our models stop on `"\n\nHuman:"`, and may include additional built-in stop
                             # sequences in the future. By providing the stop_sequences parameter, you may
                             # include additional strings that will cause the model to stop generating.
        temperature: nil, # Body param: Amount of randomness injected into the response.
                          # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                          # for analytical / multiple choice, and closer to `1.0` for creative and
                          # generative tasks.
                          # Note that even with `temperature` of `0.0`, the results will not be fully
                          # deterministic.
        top_k: nil, # Body param: Only sample from the top K options for each subsequent token.
                    # Used to remove "long tail" low probability responses.
                    # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        top_p: nil, # Body param: Use nucleus sampling.
                    # In nucleus sampling, we compute the cumulative distribution over all the options
                    # for each subsequent token in decreasing probability order and cut it off once it
                    # reaches a particular probability specified by `top_p`. You should either alter
                    # `temperature` or `top_p`, but not both.
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
        stream: false, # There is no need to provide `stream:`. Instead, use `#create_streaming` or
                       # `#create` for streaming and non-streaming use cases, respectively.
        request_options: {}
); end

      # See {Anthropic::Resources::Completions#create} for non-streaming counterpart.
      #
      # [Legacy] Create a Text Completion.
      #
      # The Text Completions API is a legacy API. We recommend using the
      # [Messages API](https://docs.anthropic.com/en/api/messages) going forward.
      #
      # Future models and features will not be compatible with Text Completions. See our
      # [migration guide](https://docs.anthropic.com/en/api/migrating-from-text-completions-to-messages)
      # for guidance in migrating from Text Completions to Messages.
      sig do
        params(
          max_tokens_to_sample: Integer,
          model: T.any(Anthropic::Model::OrSymbol, String),
          prompt: String,
          metadata: Anthropic::Metadata::OrHash,
          stop_sequences: T::Array[String],
          temperature: Float,
          top_k: Integer,
          top_p: Float,
          betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
          stream: T.noreturn,
          request_options: Anthropic::RequestOptions::OrHash
        ).returns(Anthropic::Internal::Stream[Anthropic::Completion])
      end
      def create_streaming(
        max_tokens_to_sample:, # Body param: The maximum number of tokens to generate before stopping.
                               # Note that our models may stop _before_ reaching this maximum. This parameter
                               # only specifies the absolute maximum number of tokens to generate.
        model:, # Body param: The model that will complete your prompt.\n\nSee
                # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                # details and options.
        prompt:, # Body param: The prompt that you want Claude to complete.
                 # For proper response generation you will need to format your prompt using
                 # alternating `\n\nHuman:` and `\n\nAssistant:` conversational turns. For example:
                 # ```
                 # "\n\nHuman: {userQuestion}\n\nAssistant:"
                 # ```
                 # See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and
                 # our guide to
                 # [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more
                 # details.
        metadata: nil, # Body param: An object describing metadata about the request.
        stop_sequences: nil, # Body param: Sequences that will cause the model to stop generating.
                             # Our models stop on `"\n\nHuman:"`, and may include additional built-in stop
                             # sequences in the future. By providing the stop_sequences parameter, you may
                             # include additional strings that will cause the model to stop generating.
        temperature: nil, # Body param: Amount of randomness injected into the response.
                          # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                          # for analytical / multiple choice, and closer to `1.0` for creative and
                          # generative tasks.
                          # Note that even with `temperature` of `0.0`, the results will not be fully
                          # deterministic.
        top_k: nil, # Body param: Only sample from the top K options for each subsequent token.
                    # Used to remove "long tail" low probability responses.
                    # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        top_p: nil, # Body param: Use nucleus sampling.
                    # In nucleus sampling, we compute the cumulative distribution over all the options
                    # for each subsequent token in decreasing probability order and cut it off once it
                    # reaches a particular probability specified by `top_p`. You should either alter
                    # `temperature` or `top_p`, but not both.
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
        stream: true, # There is no need to provide `stream:`. Instead, use `#create_streaming` or
                      # `#create` for streaming and non-streaming use cases, respectively.
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Anthropic::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end

    class Messages
      sig { returns(Anthropic::Resources::Messages::Batches) }
      attr_reader :batches

      # Count the number of tokens in a Message.
      #
      # The Token Count API can be used to count the number of tokens in a Message,
      # including tools, images, and documents, without creating it.
      #
      # Learn more about token counting in our
      # [user guide](/en/docs/build-with-claude/token-counting)
      sig do
        params(
          messages: T::Array[Anthropic::MessageParam::OrHash],
          model: T.any(Anthropic::Model::OrSymbol, String),
          system_: Anthropic::MessageCountTokensParams::System::Variants,
          thinking: T.any(
              Anthropic::ThinkingConfigEnabled::OrHash,
              Anthropic::ThinkingConfigDisabled::OrHash
            ),
          tool_choice: T.any(
              Anthropic::ToolChoiceAuto::OrHash,
              Anthropic::ToolChoiceAny::OrHash,
              Anthropic::ToolChoiceTool::OrHash,
              Anthropic::ToolChoiceNone::OrHash
            ),
          tools: T::Array[
              T.any(
                Anthropic::Tool::OrHash,
                Anthropic::ToolBash20250124::OrHash,
                Anthropic::ToolTextEditor20250124::OrHash,
                Anthropic::ToolTextEditor20250429::OrHash,
                Anthropic::ToolTextEditor20250728::OrHash,
                Anthropic::WebSearchTool20250305::OrHash
              )
            ],
          request_options: Anthropic::RequestOptions::OrHash
        ).returns(Anthropic::MessageTokensCount)
      end
      def count_tokens(
        messages:, # Input messages.
                   # Our models are trained to operate on alternating `user` and `assistant`
                   # conversational turns. When creating a new `Message`, you specify the prior
                   # conversational turns with the `messages` parameter, and the model then generates
                   # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                   # in your request will be combined into a single turn.
                   # Each input message must be an object with a `role` and `content`. You can
                   # specify a single `user`-role message, or you can include multiple `user` and
                   # `assistant` messages.
                   # If the final message uses the `assistant` role, the response content will
                   # continue immediately from the content in that message. This can be used to
                   # constrain part of the model's response.
                   # Example with a single `user` message:
                   # ```json
                   # [{ "role": "user", "content": "Hello, Claude" }]
                   # ```
                   # Example with multiple conversational turns:
                   # ```json
                   # [
                   #   { "role": "user", "content": "Hello there." },
                   #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                   #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                   # ]
                   # ```
                   # Example with a partially-filled response from Claude:
                   # ```json
                   # [
                   #   {
                   #     "role": "user",
                   #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                   #   },
                   #   { "role": "assistant", "content": "The best answer is (" }
                   # ]
                   # ```
                   # Each input message `content` may be either a single `string` or an array of
                   # content blocks, where each block has a specific `type`. Using a `string` for
                   # `content` is shorthand for an array of one content block of type `"text"`. The
                   # following input messages are equivalent:
                   # ```json
                   # { "role": "user", "content": "Hello, Claude" }
                   # ```
                   # ```json
                   # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                   # ```
                   # Starting with Claude 3 models, you can also send image content blocks:
                   # ```json
                   # {
                   #   "role": "user",
                   #   "content": [
                   #     {
                   #       "type": "image",
                   #       "source": {
                   #         "type": "base64",
                   #         "media_type": "image/jpeg",
                   #         "data": "/9j/4AAQSkZJRg..."
                   #       }
                   #     },
                   #     { "type": "text", "text": "What is in this image?" }
                   #   ]
                   # }
                   # ```
                   # We currently support the `base64` source type for images, and the `image/jpeg`,
                   # `image/png`, `image/gif`, and `image/webp` media types.
                   # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                   # more input examples.
                   # Note that if you want to include a
                   # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                   # the top-level `system` parameter  there is no `"system"` role for input
                   # messages in the Messages API.
                   # There is a limit of 100,000 messages in a single request.
        model:, # The model that will complete your prompt.\n\nSee
                # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                # details and options.
        system_: nil, # System prompt.
                      # A system prompt is a way of providing context and instructions to Claude, such
                      # as specifying a particular goal or role. See our
                      # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
        thinking: nil, # Configuration for enabling Claude's extended thinking.
                       # When enabled, responses include `thinking` content blocks showing Claude's
                       # thinking process before the final answer. Requires a minimum budget of 1,024
                       # tokens and counts towards your `max_tokens` limit.
                       # See
                       # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                       # for details.
        tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                          # any available tool, decide by itself, or not use tools at all.
        tools: nil, # Definitions of tools that the model may use.
                    # If you include `tools` in your API request, the model may return `tool_use`
                    # content blocks that represent the model's use of those tools. You can then run
                    # those tools using the tool input generated by the model and then optionally
                    # return results back to the model using `tool_result` content blocks.
                    # There are two types of tools: **client tools** and **server tools**. The
                    # behavior described below applies to client tools. For
                    # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                    # see their individual documentation as each has its own behavior (e.g., the
                    # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                    # Each tool definition includes:
                    # - `name`: Name of the tool.
                    # - `description`: Optional, but strongly-recommended description of the tool.
                    # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                    #   tool `input` shape that the model will produce in `tool_use` output content
                    #   blocks.
                    # For example, if you defined `tools` as:
                    # ```json
                    # [
                    #   {
                    #     "name": "get_stock_price",
                    #     "description": "Get the current stock price for a given ticker symbol.",
                    #     "input_schema": {
                    #       "type": "object",
                    #       "properties": {
                    #         "ticker": {
                    #           "type": "string",
                    #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                    #         }
                    #       },
                    #       "required": ["ticker"]
                    #     }
                    #   }
                    # ]
                    # ```
                    # And then asked the model "What's the S&P 500 at today?", the model might produce
                    # `tool_use` content blocks in the response like this:
                    # ```json
                    # [
                    #   {
                    #     "type": "tool_use",
                    #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                    #     "name": "get_stock_price",
                    #     "input": { "ticker": "^GSPC" }
                    #   }
                    # ]
                    # ```
                    # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                    # input, and return the following back to the model in a subsequent `user`
                    # message:
                    # ```json
                    # [
                    #   {
                    #     "type": "tool_result",
                    #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                    #     "content": "259.75 USD"
                    #   }
                    # ]
                    # ```
                    # Tools can be used for workflows that include running client-side tools and
                    # functions, or more generally whenever you want the model to produce a particular
                    # JSON structure of output.
                    # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
        request_options: {}
); end

      # See {Anthropic::Resources::Messages#stream_raw} for streaming counterpart.
      #
      # Send a structured list of input messages with text and/or image content, and the
      # model will generate the next message in the conversation.
      #
      # The Messages API can be used for either single queries or stateless multi-turn
      # conversations.
      #
      # Learn more about the Messages API in our [user guide](/en/docs/initial-setup)
      sig do
        params(
          max_tokens: Integer,
          messages: T::Array[Anthropic::MessageParam::OrHash],
          model: T.any(Anthropic::Model::OrSymbol, String),
          metadata: Anthropic::Metadata::OrHash,
          service_tier: Anthropic::MessageCreateParams::ServiceTier::OrSymbol,
          stop_sequences: T::Array[String],
          system_: Anthropic::MessageCreateParams::System::Variants,
          temperature: Float,
          thinking: T.any(
              Anthropic::ThinkingConfigEnabled::OrHash,
              Anthropic::ThinkingConfigDisabled::OrHash
            ),
          tool_choice: T.any(
              Anthropic::ToolChoiceAuto::OrHash,
              Anthropic::ToolChoiceAny::OrHash,
              Anthropic::ToolChoiceTool::OrHash,
              Anthropic::ToolChoiceNone::OrHash
            ),
          tools: T::Array[
              T.any(
                Anthropic::Tool::OrHash,
                Anthropic::ToolBash20250124::OrHash,
                Anthropic::ToolTextEditor20250124::OrHash,
                Anthropic::ToolTextEditor20250429::OrHash,
                Anthropic::ToolTextEditor20250728::OrHash,
                Anthropic::WebSearchTool20250305::OrHash
              )
            ],
          top_k: Integer,
          top_p: Float,
          stream: T.noreturn,
          request_options: Anthropic::RequestOptions::OrHash
        ).returns(Anthropic::Message)
      end
      def create(
        max_tokens:, # The maximum number of tokens to generate before stopping.
                     # Note that our models may stop _before_ reaching this maximum. This parameter
                     # only specifies the absolute maximum number of tokens to generate.
                     # Different models have different maximum values for this parameter. See
                     # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
        messages:, # Input messages.
                   # Our models are trained to operate on alternating `user` and `assistant`
                   # conversational turns. When creating a new `Message`, you specify the prior
                   # conversational turns with the `messages` parameter, and the model then generates
                   # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                   # in your request will be combined into a single turn.
                   # Each input message must be an object with a `role` and `content`. You can
                   # specify a single `user`-role message, or you can include multiple `user` and
                   # `assistant` messages.
                   # If the final message uses the `assistant` role, the response content will
                   # continue immediately from the content in that message. This can be used to
                   # constrain part of the model's response.
                   # Example with a single `user` message:
                   # ```json
                   # [{ "role": "user", "content": "Hello, Claude" }]
                   # ```
                   # Example with multiple conversational turns:
                   # ```json
                   # [
                   #   { "role": "user", "content": "Hello there." },
                   #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                   #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                   # ]
                   # ```
                   # Example with a partially-filled response from Claude:
                   # ```json
                   # [
                   #   {
                   #     "role": "user",
                   #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                   #   },
                   #   { "role": "assistant", "content": "The best answer is (" }
                   # ]
                   # ```
                   # Each input message `content` may be either a single `string` or an array of
                   # content blocks, where each block has a specific `type`. Using a `string` for
                   # `content` is shorthand for an array of one content block of type `"text"`. The
                   # following input messages are equivalent:
                   # ```json
                   # { "role": "user", "content": "Hello, Claude" }
                   # ```
                   # ```json
                   # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                   # ```
                   # Starting with Claude 3 models, you can also send image content blocks:
                   # ```json
                   # {
                   #   "role": "user",
                   #   "content": [
                   #     {
                   #       "type": "image",
                   #       "source": {
                   #         "type": "base64",
                   #         "media_type": "image/jpeg",
                   #         "data": "/9j/4AAQSkZJRg..."
                   #       }
                   #     },
                   #     { "type": "text", "text": "What is in this image?" }
                   #   ]
                   # }
                   # ```
                   # We currently support the `base64` source type for images, and the `image/jpeg`,
                   # `image/png`, `image/gif`, and `image/webp` media types.
                   # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                   # more input examples.
                   # Note that if you want to include a
                   # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                   # the top-level `system` parameter  there is no `"system"` role for input
                   # messages in the Messages API.
                   # There is a limit of 100,000 messages in a single request.
        model:, # The model that will complete your prompt.\n\nSee
                # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                # details and options.
        metadata: nil, # An object describing metadata about the request.
        service_tier: nil, # Determines whether to use priority capacity (if available) or standard capacity
                           # for this request.
                           # Anthropic offers different levels of service for your API requests. See
                           # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
        stop_sequences: nil, # Custom text sequences that will cause the model to stop generating.
                             # Our models will normally stop when they have naturally completed their turn,
                             # which will result in a response `stop_reason` of `"end_turn"`.
                             # If you want the model to stop generating when it encounters custom strings of
                             # text, you can use the `stop_sequences` parameter. If the model encounters one of
                             # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                             # and the response `stop_sequence` value will contain the matched stop sequence.
        system_: nil, # System prompt.
                      # A system prompt is a way of providing context and instructions to Claude, such
                      # as specifying a particular goal or role. See our
                      # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
        temperature: nil, # Amount of randomness injected into the response.
                          # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                          # for analytical / multiple choice, and closer to `1.0` for creative and
                          # generative tasks.
                          # Note that even with `temperature` of `0.0`, the results will not be fully
                          # deterministic.
        thinking: nil, # Configuration for enabling Claude's extended thinking.
                       # When enabled, responses include `thinking` content blocks showing Claude's
                       # thinking process before the final answer. Requires a minimum budget of 1,024
                       # tokens and counts towards your `max_tokens` limit.
                       # See
                       # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                       # for details.
        tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                          # any available tool, decide by itself, or not use tools at all.
        tools: nil, # Definitions of tools that the model may use.
                    # If you include `tools` in your API request, the model may return `tool_use`
                    # content blocks that represent the model's use of those tools. You can then run
                    # those tools using the tool input generated by the model and then optionally
                    # return results back to the model using `tool_result` content blocks.
                    # There are two types of tools: **client tools** and **server tools**. The
                    # behavior described below applies to client tools. For
                    # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                    # see their individual documentation as each has its own behavior (e.g., the
                    # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                    # Each tool definition includes:
                    # - `name`: Name of the tool.
                    # - `description`: Optional, but strongly-recommended description of the tool.
                    # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                    #   tool `input` shape that the model will produce in `tool_use` output content
                    #   blocks.
                    # For example, if you defined `tools` as:
                    # ```json
                    # [
                    #   {
                    #     "name": "get_stock_price",
                    #     "description": "Get the current stock price for a given ticker symbol.",
                    #     "input_schema": {
                    #       "type": "object",
                    #       "properties": {
                    #         "ticker": {
                    #           "type": "string",
                    #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                    #         }
                    #       },
                    #       "required": ["ticker"]
                    #     }
                    #   }
                    # ]
                    # ```
                    # And then asked the model "What's the S&P 500 at today?", the model might produce
                    # `tool_use` content blocks in the response like this:
                    # ```json
                    # [
                    #   {
                    #     "type": "tool_use",
                    #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                    #     "name": "get_stock_price",
                    #     "input": { "ticker": "^GSPC" }
                    #   }
                    # ]
                    # ```
                    # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                    # input, and return the following back to the model in a subsequent `user`
                    # message:
                    # ```json
                    # [
                    #   {
                    #     "type": "tool_result",
                    #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                    #     "content": "259.75 USD"
                    #   }
                    # ]
                    # ```
                    # Tools can be used for workflows that include running client-side tools and
                    # functions, or more generally whenever you want the model to produce a particular
                    # JSON structure of output.
                    # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
        top_k: nil, # Only sample from the top K options for each subsequent token.
                    # Used to remove "long tail" low probability responses.
                    # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        top_p: nil, # Use nucleus sampling.
                    # In nucleus sampling, we compute the cumulative distribution over all the options
                    # for each subsequent token in decreasing probability order and cut it off once it
                    # reaches a particular probability specified by `top_p`. You should either alter
                    # `temperature` or `top_p`, but not both.
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        stream: false, # There is no need to provide `stream:`. Instead, use `#stream_raw` or `#create`
                       # for streaming and non-streaming use cases, respectively.
        request_options: {}
); end

      # See {Anthropic::Resources::Messages#create} for non-streaming counterpart.
      #
      # Send a structured list of input messages with text and/or image content, and the
      # model will generate the next message in the conversation.
      #
      # The Messages API can be used for either single queries or stateless multi-turn
      # conversations.
      #
      # Learn more about the Messages API in our [user guide](/en/docs/initial-setup)
      sig do
        params(
          max_tokens: Integer,
          messages: T::Array[
              T.any(
                Anthropic::Models::MessageParam,
                Anthropic::Internal::AnyHash
              )
            ],
          model: T.any(Anthropic::Models::Model::OrSymbol, String),
          metadata: T.any(Anthropic::Models::Metadata, Anthropic::Internal::AnyHash),
          stop_sequences: T::Array[String],
          system_: T.any(
              String,
              T::Array[
                T.any(
                  Anthropic::Models::TextBlockParam,
                  Anthropic::Internal::AnyHash
                )
              ]
            ),
          temperature: Float,
          thinking: T.any(
              Anthropic::Models::ThinkingConfigEnabled,
              Anthropic::Internal::AnyHash,
              Anthropic::Models::ThinkingConfigDisabled
            ),
          tool_choice: T.any(
              Anthropic::Models::ToolChoiceAuto,
              Anthropic::Internal::AnyHash,
              Anthropic::Models::ToolChoiceAny,
              Anthropic::Models::ToolChoiceTool,
              Anthropic::Models::ToolChoiceNone
            ),
          tools: T::Array[
              T.any(
                Anthropic::Models::Tool,
                Anthropic::Internal::AnyHash,
                Anthropic::Models::ToolBash20250124,
                Anthropic::Models::ToolTextEditor20250124
              )
            ],
          top_k: Integer,
          top_p: Float,
          stream: T.noreturn,
          request_options: T.nilable(
              T.any(Anthropic::RequestOptions, Anthropic::Internal::AnyHash)
            )
        ).returns(Anthropic::Helpers::Streaming::MessageStream)
      end
      def stream(
        max_tokens:, # The maximum number of tokens to generate before stopping.
                     # Note that our models may stop _before_ reaching this maximum. This parameter
                     # only specifies the absolute maximum number of tokens to generate.
                     # Different models have different maximum values for this parameter. See
                     # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
        messages:, # Input messages.
                   # Our models are trained to operate on alternating `user` and `assistant`
                   # conversational turns. When creating a new `Message`, you specify the prior
                   # conversational turns with the `messages` parameter, and the model then generates
                   # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                   # in your request will be combined into a single turn.
                   # Each input message must be an object with a `role` and `content`. You can
                   # specify a single `user`-role message, or you can include multiple `user` and
                   # `assistant` messages.
                   # If the final message uses the `assistant` role, the response content will
                   # continue immediately from the content in that message. This can be used to
                   # constrain part of the model's response.
                   # Example with a single `user` message:
                   # ```json
                   # [{ "role": "user", "content": "Hello, Claude" }]
                   # ```
                   # Example with multiple conversational turns:
                   # ```json
                   # [
                   #   { "role": "user", "content": "Hello there." },
                   #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                   #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                   # ]
                   # ```
                   # Example with a partially-filled response from Claude:
                   # ```json
                   # [
                   #   {
                   #     "role": "user",
                   #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                   #   },
                   #   { "role": "assistant", "content": "The best answer is (" }
                   # ]
                   # ```
                   # Each input message `content` may be either a single `string` or an array of
                   # content blocks, where each block has a specific `type`. Using a `string` for
                   # `content` is shorthand for an array of one content block of type `"text"`. The
                   # following input messages are equivalent:
                   # ```json
                   # { "role": "user", "content": "Hello, Claude" }
                   # ```
                   # ```json
                   # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                   # ```
                   # Starting with Claude 3 models, you can also send image content blocks:
                   # ```json
                   # {
                   #   "role": "user",
                   #   "content": [
                   #     {
                   #       "type": "image",
                   #       "source": {
                   #         "type": "base64",
                   #         "media_type": "image/jpeg",
                   #         "data": "/9j/4AAQSkZJRg..."
                   #       }
                   #     },
                   #     { "type": "text", "text": "What is in this image?" }
                   #   ]
                   # }
                   # ```
                   # We currently support the `base64` source type for images, and the `image/jpeg`,
                   # `image/png`, `image/gif`, and `image/webp` media types.
                   # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                   # more input examples.
                   # Note that if you want to include a
                   # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                   # the top-level `system` parameter  there is no `"system"` role for input
                   # messages in the Messages API.
        model:, # The model that will complete your prompt.\n\nSee
                # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                # details and options.
        metadata: nil, # An object describing metadata about the request.
        stop_sequences: nil, # Custom text sequences that will cause the model to stop generating.
                             # Our models will normally stop when they have naturally completed their turn,
                             # which will result in a response `stop_reason` of `"end_turn"`.
                             # If you want the model to stop generating when it encounters custom strings of
                             # text, you can use the `stop_sequences` parameter. If the model encounters one of
                             # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                             # and the response `stop_sequence` value will contain the matched stop sequence.
        system_: nil, # System prompt.
                      # A system prompt is a way of providing context and instructions to Claude, such
                      # as specifying a particular goal or role. See our
                      # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
        temperature: nil, # Amount of randomness injected into the response.
                          # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                          # for analytical / multiple choice, and closer to `1.0` for creative and
                          # generative tasks.
                          # Note that even with `temperature` of `0.0`, the results will not be fully
                          # deterministic.
        thinking: nil, # Configuration for enabling Claude's extended thinking.
                       # When enabled, responses include `thinking` content blocks showing Claude's
                       # thinking process before the final answer. Requires a minimum budget of 1,024
                       # tokens and counts towards your `max_tokens` limit.
                       # See
                       # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                       # for details.
        tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                          # any available tool, decide by itself, or not use tools at all.
        tools: nil, # Definitions of tools that the model may use.
                    # If you include `tools` in your API request, the model may return `tool_use`
                    # content blocks that represent the model's use of those tools. You can then run
                    # those tools using the tool input generated by the model and then optionally
                    # return results back to the model using `tool_result` content blocks.
                    # Each tool definition includes:
                    # - `name`: Name of the tool.
                    # - `description`: Optional, but strongly-recommended description of the tool.
                    # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                    #   tool `input` shape that the model will produce in `tool_use` output content
                    #   blocks.
                    # For example, if you defined `tools` as:
                    # ```json
                    # [
                    #   {
                    #     "name": "get_stock_price",
                    #     "description": "Get the current stock price for a given ticker symbol.",
                    #     "input_schema": {
                    #       "type": "object",
                    #       "properties": {
                    #         "ticker": {
                    #           "type": "string",
                    #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                    #         }
                    #       },
                    #       "required": ["ticker"]
                    #     }
                    #   }
                    # ]
                    # ```
                    # And then asked the model "What's the S&P 500 at today?", the model might produce
                    # `tool_use` content blocks in the response like this:
                    # ```json
                    # [
                    #   {
                    #     "type": "tool_use",
                    #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                    #     "name": "get_stock_price",
                    #     "input": { "ticker": "^GSPC" }
                    #   }
                    # ]
                    # ```
                    # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                    # input, and return the following back to the model in a subsequent `user`
                    # message:
                    # ```json
                    # [
                    #   {
                    #     "type": "tool_result",
                    #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                    #     "content": "259.75 USD"
                    #   }
                    # ]
                    # ```
                    # Tools can be used for workflows that include running client-side tools and
                    # functions, or more generally whenever you want the model to produce a particular
                    # JSON structure of output.
                    # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
        top_k: nil, # Only sample from the top K options for each subsequent token.
                    # Used to remove "long tail" low probability responses.
                    # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        top_p: nil, # Use nucleus sampling.
                    # In nucleus sampling, we compute the cumulative distribution over all the options
                    # for each subsequent token in decreasing probability order and cut it off once it
                    # reaches a particular probability specified by `top_p`. You should either alter
                    # `temperature` or `top_p`, but not both.
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        stream: true, # There is no need to provide `stream:`. Instead, use `#stream_raw` or `#create`
                      # for streaming and non-streaming use cases, respectively.
        request_options: {}
); end

      sig do
        params(
          max_tokens: Integer,
          messages: T::Array[Anthropic::MessageParam::OrHash],
          model: T.any(Anthropic::Model::OrSymbol, String),
          metadata: Anthropic::Metadata::OrHash,
          service_tier: Anthropic::MessageCreateParams::ServiceTier::OrSymbol,
          stop_sequences: T::Array[String],
          system_: Anthropic::MessageCreateParams::System::Variants,
          temperature: Float,
          thinking: T.any(
              Anthropic::ThinkingConfigEnabled::OrHash,
              Anthropic::ThinkingConfigDisabled::OrHash
            ),
          tool_choice: T.any(
              Anthropic::ToolChoiceAuto::OrHash,
              Anthropic::ToolChoiceAny::OrHash,
              Anthropic::ToolChoiceTool::OrHash,
              Anthropic::ToolChoiceNone::OrHash
            ),
          tools: T::Array[
              T.any(
                Anthropic::Tool::OrHash,
                Anthropic::ToolBash20250124::OrHash,
                Anthropic::ToolTextEditor20250124::OrHash,
                Anthropic::ToolTextEditor20250429::OrHash,
                Anthropic::ToolTextEditor20250728::OrHash,
                Anthropic::WebSearchTool20250305::OrHash
              )
            ],
          top_k: Integer,
          top_p: Float,
          stream: T.noreturn,
          request_options: Anthropic::RequestOptions::OrHash
        ).returns(Anthropic::Internal::Stream[
            Anthropic::RawMessageStreamEvent::Variants
          ])
      end
      def stream_raw(
        max_tokens:, # The maximum number of tokens to generate before stopping.
                     # Note that our models may stop _before_ reaching this maximum. This parameter
                     # only specifies the absolute maximum number of tokens to generate.
                     # Different models have different maximum values for this parameter. See
                     # [models](https://docs.anthropic.com/en/docs/models-overview) for details.
        messages:, # Input messages.
                   # Our models are trained to operate on alternating `user` and `assistant`
                   # conversational turns. When creating a new `Message`, you specify the prior
                   # conversational turns with the `messages` parameter, and the model then generates
                   # the next `Message` in the conversation. Consecutive `user` or `assistant` turns
                   # in your request will be combined into a single turn.
                   # Each input message must be an object with a `role` and `content`. You can
                   # specify a single `user`-role message, or you can include multiple `user` and
                   # `assistant` messages.
                   # If the final message uses the `assistant` role, the response content will
                   # continue immediately from the content in that message. This can be used to
                   # constrain part of the model's response.
                   # Example with a single `user` message:
                   # ```json
                   # [{ "role": "user", "content": "Hello, Claude" }]
                   # ```
                   # Example with multiple conversational turns:
                   # ```json
                   # [
                   #   { "role": "user", "content": "Hello there." },
                   #   { "role": "assistant", "content": "Hi, I'm Claude. How can I help you?" },
                   #   { "role": "user", "content": "Can you explain LLMs in plain English?" }
                   # ]
                   # ```
                   # Example with a partially-filled response from Claude:
                   # ```json
                   # [
                   #   {
                   #     "role": "user",
                   #     "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
                   #   },
                   #   { "role": "assistant", "content": "The best answer is (" }
                   # ]
                   # ```
                   # Each input message `content` may be either a single `string` or an array of
                   # content blocks, where each block has a specific `type`. Using a `string` for
                   # `content` is shorthand for an array of one content block of type `"text"`. The
                   # following input messages are equivalent:
                   # ```json
                   # { "role": "user", "content": "Hello, Claude" }
                   # ```
                   # ```json
                   # { "role": "user", "content": [{ "type": "text", "text": "Hello, Claude" }] }
                   # ```
                   # Starting with Claude 3 models, you can also send image content blocks:
                   # ```json
                   # {
                   #   "role": "user",
                   #   "content": [
                   #     {
                   #       "type": "image",
                   #       "source": {
                   #         "type": "base64",
                   #         "media_type": "image/jpeg",
                   #         "data": "/9j/4AAQSkZJRg..."
                   #       }
                   #     },
                   #     { "type": "text", "text": "What is in this image?" }
                   #   ]
                   # }
                   # ```
                   # We currently support the `base64` source type for images, and the `image/jpeg`,
                   # `image/png`, `image/gif`, and `image/webp` media types.
                   # See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for
                   # more input examples.
                   # Note that if you want to include a
                   # [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use
                   # the top-level `system` parameter  there is no `"system"` role for input
                   # messages in the Messages API.
                   # There is a limit of 100,000 messages in a single request.
        model:, # The model that will complete your prompt.\n\nSee
                # [models](https://docs.anthropic.com/en/docs/models-overview) for additional
                # details and options.
        metadata: nil, # An object describing metadata about the request.
        service_tier: nil, # Determines whether to use priority capacity (if available) or standard capacity
                           # for this request.
                           # Anthropic offers different levels of service for your API requests. See
                           # [service-tiers](https://docs.anthropic.com/en/api/service-tiers) for details.
        stop_sequences: nil, # Custom text sequences that will cause the model to stop generating.
                             # Our models will normally stop when they have naturally completed their turn,
                             # which will result in a response `stop_reason` of `"end_turn"`.
                             # If you want the model to stop generating when it encounters custom strings of
                             # text, you can use the `stop_sequences` parameter. If the model encounters one of
                             # the custom sequences, the response `stop_reason` value will be `"stop_sequence"`
                             # and the response `stop_sequence` value will contain the matched stop sequence.
        system_: nil, # System prompt.
                      # A system prompt is a way of providing context and instructions to Claude, such
                      # as specifying a particular goal or role. See our
                      # [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).
        temperature: nil, # Amount of randomness injected into the response.
                          # Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`
                          # for analytical / multiple choice, and closer to `1.0` for creative and
                          # generative tasks.
                          # Note that even with `temperature` of `0.0`, the results will not be fully
                          # deterministic.
        thinking: nil, # Configuration for enabling Claude's extended thinking.
                       # When enabled, responses include `thinking` content blocks showing Claude's
                       # thinking process before the final answer. Requires a minimum budget of 1,024
                       # tokens and counts towards your `max_tokens` limit.
                       # See
                       # [extended thinking](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
                       # for details.
        tool_choice: nil, # How the model should use the provided tools. The model can use a specific tool,
                          # any available tool, decide by itself, or not use tools at all.
        tools: nil, # Definitions of tools that the model may use.
                    # If you include `tools` in your API request, the model may return `tool_use`
                    # content blocks that represent the model's use of those tools. You can then run
                    # those tools using the tool input generated by the model and then optionally
                    # return results back to the model using `tool_result` content blocks.
                    # There are two types of tools: **client tools** and **server tools**. The
                    # behavior described below applies to client tools. For
                    # [server tools](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#server-tools),
                    # see their individual documentation as each has its own behavior (e.g., the
                    # [web search tool](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
                    # Each tool definition includes:
                    # - `name`: Name of the tool.
                    # - `description`: Optional, but strongly-recommended description of the tool.
                    # - `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the
                    #   tool `input` shape that the model will produce in `tool_use` output content
                    #   blocks.
                    # For example, if you defined `tools` as:
                    # ```json
                    # [
                    #   {
                    #     "name": "get_stock_price",
                    #     "description": "Get the current stock price for a given ticker symbol.",
                    #     "input_schema": {
                    #       "type": "object",
                    #       "properties": {
                    #         "ticker": {
                    #           "type": "string",
                    #           "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
                    #         }
                    #       },
                    #       "required": ["ticker"]
                    #     }
                    #   }
                    # ]
                    # ```
                    # And then asked the model "What's the S&P 500 at today?", the model might produce
                    # `tool_use` content blocks in the response like this:
                    # ```json
                    # [
                    #   {
                    #     "type": "tool_use",
                    #     "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                    #     "name": "get_stock_price",
                    #     "input": { "ticker": "^GSPC" }
                    #   }
                    # ]
                    # ```
                    # You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an
                    # input, and return the following back to the model in a subsequent `user`
                    # message:
                    # ```json
                    # [
                    #   {
                    #     "type": "tool_result",
                    #     "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
                    #     "content": "259.75 USD"
                    #   }
                    # ]
                    # ```
                    # Tools can be used for workflows that include running client-side tools and
                    # functions, or more generally whenever you want the model to produce a particular
                    # JSON structure of output.
                    # See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.
        top_k: nil, # Only sample from the top K options for each subsequent token.
                    # Used to remove "long tail" low probability responses.
                    # [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        top_p: nil, # Use nucleus sampling.
                    # In nucleus sampling, we compute the cumulative distribution over all the options
                    # for each subsequent token in decreasing probability order and cut it off once it
                    # reaches a particular probability specified by `top_p`. You should either alter
                    # `temperature` or `top_p`, but not both.
                    # Recommended for advanced use cases only. You usually only need to use
                    # `temperature`.
        stream: true, # There is no need to provide `stream:`. Instead, use `#stream_raw` or `#create`
                      # for streaming and non-streaming use cases, respectively.
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Anthropic::Client).returns(T.attached_class) }
        def new(client:); end
      end

      class Batches
        # Batches may be canceled any time before processing ends. Once cancellation is
        # initiated, the batch enters a `canceling` state, at which time the system may
        # complete any in-progress, non-interruptible requests before finalizing
        # cancellation.
        #
        # The number of canceled requests is specified in `request_counts`. To determine
        # which requests were canceled, check the individual results within the batch.
        # Note that cancellation may not result in any canceled requests if they were
        # non-interruptible.
        #
        # Learn more about the Message Batches API in our
        # [user guide](/en/docs/build-with-claude/batch-processing)
        sig do
          params(
            message_batch_id: String,
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Messages::MessageBatch)
        end
        def cancel(
          message_batch_id, # ID of the Message Batch.
          request_options: {}
); end

        # Send a batch of Message creation requests.
        #
        # The Message Batches API can be used to process multiple Messages API requests at
        # once. Once a Message Batch is created, it begins processing immediately. Batches
        # can take up to 24 hours to complete.
        #
        # Learn more about the Message Batches API in our
        # [user guide](/en/docs/build-with-claude/batch-processing)
        sig do
          params(
            requests: T::Array[Anthropic::Messages::BatchCreateParams::Request::OrHash],
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Messages::MessageBatch)
        end
        def create(
          requests:, # List of requests for prompt completion. Each is an individual request to create
                     # a Message.
          request_options: {}
); end

        # Delete a Message Batch.
        #
        # Message Batches can only be deleted once they've finished processing. If you'd
        # like to delete an in-progress batch, you must first cancel it.
        #
        # Learn more about the Message Batches API in our
        # [user guide](/en/docs/build-with-claude/batch-processing)
        sig do
          params(
            message_batch_id: String,
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Messages::DeletedMessageBatch)
        end
        def delete(
          message_batch_id, # ID of the Message Batch.
          request_options: {}
); end

        # List all Message Batches within a Workspace. Most recently created batches are
        # returned first.
        #
        # Learn more about the Message Batches API in our
        # [user guide](/en/docs/build-with-claude/batch-processing)
        sig do
          params(
            after_id: String,
            before_id: String,
            limit: Integer,
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Internal::Page[Anthropic::Messages::MessageBatch])
        end
        def list(
          after_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                         # page of results immediately after this object.
          before_id: nil, # ID of the object to use as a cursor for pagination. When provided, returns the
                          # page of results immediately before this object.
          limit: nil, # Number of items to return per page.
                      # Defaults to `20`. Ranges from `1` to `1000`.
          request_options: {}
); end

        # Streams the results of a Message Batch as a `.jsonl` file.
        #
        # Each line in the file is a JSON object containing the result of a single request
        # in the Message Batch. Results are not guaranteed to be in the same order as
        # requests. Use the `custom_id` field to match results to requests.
        #
        # Learn more about the Message Batches API in our
        # [user guide](/en/docs/build-with-claude/batch-processing)
        sig do
          params(
            message_batch_id: String,
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Internal::JsonLStream[
              Anthropic::Messages::MessageBatchIndividualResponse
            ])
        end
        def results_streaming(
          message_batch_id, # ID of the Message Batch.
          request_options: {}
); end

        # This endpoint is idempotent and can be used to poll for Message Batch
        # completion. To access the results of a Message Batch, make a request to the
        # `results_url` field in the response.
        #
        # Learn more about the Message Batches API in our
        # [user guide](/en/docs/build-with-claude/batch-processing)
        sig do
          params(
            message_batch_id: String,
            request_options: Anthropic::RequestOptions::OrHash
          ).returns(Anthropic::Messages::MessageBatch)
        end
        def retrieve(
          message_batch_id, # ID of the Message Batch.
          request_options: {}
); end

        class << self
          # @api private
          sig { params(client: Anthropic::Client).returns(T.attached_class) }
          def new(client:); end
        end
      end
    end

    class Models
      # List available models.
      #
      # The Models API response can be used to determine which models are available for
      # use in the API. More recently released models are listed first.
      sig do
        params(
          after_id: String,
          before_id: String,
          limit: Integer,
          betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
          request_options: Anthropic::RequestOptions::OrHash
        ).returns(Anthropic::Internal::Page[Anthropic::ModelInfo])
      end
      def list(
        after_id: nil, # Query param: ID of the object to use as a cursor for pagination. When provided,
                       # returns the page of results immediately after this object.
        before_id: nil, # Query param: ID of the object to use as a cursor for pagination. When provided,
                        # returns the page of results immediately before this object.
        limit: nil, # Query param: Number of items to return per page.
                    # Defaults to `20`. Ranges from `1` to `1000`.
        betas: nil, # Header param: Optional header to specify the beta version(s) you want to use.
        request_options: {}
); end

      # Get a specific model.
      #
      # The Models API response can be used to determine information about a specific
      # model or resolve a model alias to a model ID.
      sig do
        params(
          model_id: String,
          betas: T::Array[T.any(String, Anthropic::AnthropicBeta::OrSymbol)],
          request_options: Anthropic::RequestOptions::OrHash
        ).returns(Anthropic::ModelInfo)
      end
      def retrieve(
        model_id, # Model identifier or alias.
        betas: nil, # Optional header to specify the beta version(s) you want to use.
        request_options: {}
); end

      class << self
        # @api private
        sig { params(client: Anthropic::Client).returns(T.attached_class) }
        def new(client:); end
      end
    end
  end

  SearchResultBlockParam = Anthropic::Models::SearchResultBlockParam
  ServerToolUsage = Anthropic::Models::ServerToolUsage
  ServerToolUseBlock = Anthropic::Models::ServerToolUseBlock
  ServerToolUseBlockParam = Anthropic::Models::ServerToolUseBlockParam
  SignatureDelta = Anthropic::Models::SignatureDelta
  StopReason = Anthropic::Models::StopReason
  Streaming = Anthropic::Helpers::Streaming
  TextBlock = Anthropic::Models::TextBlock
  TextBlockParam = Anthropic::Models::TextBlockParam
  TextCitation = Anthropic::Models::TextCitation
  TextCitationParam = Anthropic::Models::TextCitationParam
  TextDelta = Anthropic::Models::TextDelta
  ThinkingBlock = Anthropic::Models::ThinkingBlock
  ThinkingBlockParam = Anthropic::Models::ThinkingBlockParam
  ThinkingConfigDisabled = Anthropic::Models::ThinkingConfigDisabled
  ThinkingConfigEnabled = Anthropic::Models::ThinkingConfigEnabled
  ThinkingConfigParam = Anthropic::Models::ThinkingConfigParam
  ThinkingDelta = Anthropic::Models::ThinkingDelta
  Tool = Anthropic::Models::Tool
  ToolBash20250124 = Anthropic::Models::ToolBash20250124
  ToolChoice = Anthropic::Models::ToolChoice
  ToolChoiceAny = Anthropic::Models::ToolChoiceAny
  ToolChoiceAuto = Anthropic::Models::ToolChoiceAuto
  ToolChoiceNone = Anthropic::Models::ToolChoiceNone
  ToolChoiceTool = Anthropic::Models::ToolChoiceTool
  ToolResultBlockParam = Anthropic::Models::ToolResultBlockParam
  ToolTextEditor20250124 = Anthropic::Models::ToolTextEditor20250124
  ToolTextEditor20250429 = Anthropic::Models::ToolTextEditor20250429
  ToolTextEditor20250728 = Anthropic::Models::ToolTextEditor20250728
  ToolUnion = Anthropic::Models::ToolUnion
  ToolUseBlock = Anthropic::Models::ToolUseBlock
  ToolUseBlockParam = Anthropic::Models::ToolUseBlockParam
  URLImageSource = Anthropic::Models::URLImageSource
  URLPDFSource = Anthropic::Models::URLPDFSource
  Usage = Anthropic::Models::Usage
  VERSION = T.let(T.unsafe(nil), String)
  VertexClient = Anthropic::Helpers::Vertex::Client
  WebSearchResultBlock = Anthropic::Models::WebSearchResultBlock
  WebSearchResultBlockParam = Anthropic::Models::WebSearchResultBlockParam
  WebSearchTool20250305 = Anthropic::Models::WebSearchTool20250305
  WebSearchToolRequestError = Anthropic::Models::WebSearchToolRequestError
  WebSearchToolResultBlock = Anthropic::Models::WebSearchToolResultBlock

  WebSearchToolResultBlockContent = Anthropic::Models::WebSearchToolResultBlockContent

  WebSearchToolResultBlockParam = Anthropic::Models::WebSearchToolResultBlockParam

  WebSearchToolResultBlockParamContent = Anthropic::Models::WebSearchToolResultBlockParamContent

  WebSearchToolResultError = Anthropic::Models::WebSearchToolResultError
end
