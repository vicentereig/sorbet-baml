# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sorbet-result` gem.
# Please instead update this file by running `bin/tapioca gem sorbet-result`.


# source://sorbet-result//lib/typed/no_error_on_success_error.rb#4
module Typed
  class << self
    # source://sorbet-result//lib/typed/result.rb#159
    sig { type_parameters(:T).params(error: T.type_parameter(:T)).returns(Typed::Failure[T.type_parameter(:T)]) }
    def Failure(error); end

    # source://sorbet-result//lib/typed/result.rb#150
    sig { type_parameters(:T).params(payload: T.type_parameter(:T)).returns(Typed::Success[T.type_parameter(:T)]) }
    def Success(payload); end
  end
end

# source://sorbet-result//lib/typed/result.rb#163
class Typed::Failure < ::Typed::Result
  extend T::Generic

  Payload = type_member { { fixed: T.noreturn } }
  Error = type_member

  # source://sorbet-result//lib/typed/result.rb#188
  sig { params(error: Error).void }
  def initialize(error); end

  # source://sorbet-result//lib/typed/result.rb#239
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://sorbet-result//lib/typed/result.rb#214
  sig do
    override
      .type_parameters(:U, :T)
      .params(
        _block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(Typed::Result[T.type_parameter(:U), Error])
  end
  def and_then(&_block); end

  # source://sorbet-result//lib/typed/result.rb#171
  sig { override.returns(Error) }
  def error; end

  # source://sorbet-result//lib/typed/result.rb#199
  sig { override.returns(T::Boolean) }
  def failure?; end

  # source://sorbet-result//lib/typed/result.rb#223
  sig { override.params(block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&block); end

  # @raise [NoPayloadOnFailureError]
  #
  # source://sorbet-result//lib/typed/result.rb#204
  sig { override.returns(T.noreturn) }
  def payload; end

  # source://sorbet-result//lib/typed/result.rb#234
  sig do
    override
      .type_parameters(:Fallback)
      .params(
        value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(value); end

  # source://sorbet-result//lib/typed/result.rb#194
  sig { override.returns(T::Boolean) }
  def success?; end

  class << self
    # source://sorbet-result//lib/typed/result.rb#183
    sig { returns(Typed::Failure[::NilClass]) }
    def blank; end

    # source://sorbet-result//lib/typed/result.rb#178
    sig { type_parameters(:T).params(error: T.type_parameter(:T)).returns(Typed::Failure[T.type_parameter(:T)]) }
    def new(error); end
  end
end

# Error when user attempts to access payload from a Failure Result.
#
# source://sorbet-result//lib/typed/no_error_on_success_error.rb#6
class Typed::NoErrorOnSuccessError < ::StandardError
  # source://sorbet-result//lib/typed/no_error_on_success_error.rb#10
  sig { void }
  def initialize; end
end

# Error when user attempts to access payload from a Failure Result.
#
# source://sorbet-result//lib/typed/no_payload_on_failure_error.rb#6
class Typed::NoPayloadOnFailureError < ::StandardError
  # source://sorbet-result//lib/typed/no_payload_on_failure_error.rb#10
  sig { params(failure: Typed::Failure[T.untyped]).void }
  def initialize(failure); end
end

# A monad representing either a success or a failure. Contains payload and error information as well.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://sorbet-result//lib/typed/result.rb#11
class Typed::Result
  extend T::Generic

  abstract!
  sealed!

  Payload = type_member(:out)
  Error = type_member(:out)

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#44
  sig do
    abstract
      .type_parameters(:U, :T)
      .params(
        _block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(T.any(Typed::Result[T.type_parameter(:U), Error], Typed::Result[T.type_parameter(:U), T.type_parameter(:T)]))
  end
  def and_then(&_block); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#35
  sig { abstract.returns(Error) }
  def error; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#27
  sig { abstract.returns(T::Boolean) }
  def failure?; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#52
  sig { abstract.params(block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&block); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#31
  sig { abstract.returns(Payload) }
  def payload; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#61
  sig do
    abstract
      .type_parameters(:Fallback)
      .params(
        value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(value); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#23
  sig { abstract.returns(T::Boolean) }
  def success?; end
end

# source://sorbet-result//lib/typed/result.rb#65
class Typed::Success < ::Typed::Result
  extend T::Generic

  Payload = type_member
  Error = type_member { { fixed: T.noreturn } }

  # source://sorbet-result//lib/typed/result.rb#90
  sig { params(payload: Payload).void }
  def initialize(payload); end

  # source://sorbet-result//lib/typed/result.rb#140
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://sorbet-result//lib/typed/result.rb#116
  sig do
    override
      .type_parameters(:U, :T)
      .params(
        block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
  end
  def and_then(&block); end

  # @raise [NoErrorOnSuccessError]
  #
  # source://sorbet-result//lib/typed/result.rb#106
  sig { override.returns(T.noreturn) }
  def error; end

  # source://sorbet-result//lib/typed/result.rb#101
  sig { override.returns(T::Boolean) }
  def failure?; end

  # source://sorbet-result//lib/typed/result.rb#125
  sig { override.params(_block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&_block); end

  # source://sorbet-result//lib/typed/result.rb#73
  sig { override.returns(Payload) }
  def payload; end

  # source://sorbet-result//lib/typed/result.rb#135
  sig do
    override
      .type_parameters(:Fallback)
      .params(
        _value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(_value); end

  # source://sorbet-result//lib/typed/result.rb#96
  sig { override.returns(T::Boolean) }
  def success?; end

  class << self
    # source://sorbet-result//lib/typed/result.rb#85
    sig { returns(Typed::Success[::NilClass]) }
    def blank; end

    # source://sorbet-result//lib/typed/result.rb#80
    sig { type_parameters(:T).params(payload: T.type_parameter(:T)).returns(Typed::Success[T.type_parameter(:T)]) }
    def new(payload); end
  end
end
