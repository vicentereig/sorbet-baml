# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dspy` gem.
# Please instead update this file by running `bin/tapioca gem dspy`.


# source://dspy//lib/dspy/version.rb#3
module DSPy
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  class << self
    # source://dspy//lib/dspy.rb#49
    def create_logger; end

    # source://dspy//lib/dspy.rb#36
    def log(event, **attributes); end

    # source://dspy//lib/dspy.rb#32
    def logger; end
  end
end

# Enhances prediction by encouraging step-by-step reasoning
# before providing a final answer using Sorbet signatures.
#
# source://dspy//lib/dspy/chain_of_thought.rb#12
class DSPy::ChainOfThought < ::DSPy::Predict
  # source://dspy//lib/dspy/chain_of_thought.rb#19
  sig { params(signature_class: T.class_of(DSPy::Signature)).void }
  def initialize(signature_class); end

  # Override forward_untyped to add ChainOfThought-specific analysis
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#86
  sig { override.params(input_values: T.untyped).returns(T.untyped) }
  def forward_untyped(**input_values); end

  # Access to the original signature for optimization
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#82
  sig { returns(T.class_of(DSPy::Signature)) }
  def original_signature; end

  # source://dspy//lib/dspy/chain_of_thought.rb#61
  sig { override.params(examples: T::Array[::DSPy::FewShotExample]).returns(DSPy::ChainOfThought) }
  def with_examples(examples); end

  # source://dspy//lib/dspy/chain_of_thought.rb#55
  sig { override.params(instruction: ::String).returns(DSPy::ChainOfThought) }
  def with_instruction(instruction); end

  # Override prompt-based methods to maintain ChainOfThought behavior
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#30
  sig { override.params(new_prompt: ::DSPy::Prompt).returns(DSPy::ChainOfThought) }
  def with_prompt(new_prompt); end

  private

  # Analyzes reasoning in prediction result and emits instrumentation events
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#163
  sig { params(prediction_result: T.untyped).void }
  def analyze_reasoning(prediction_result); end

  # Builds enhanced signature with reasoning capabilities
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#100
  sig { params(signature_class: T.class_of(DSPy::Signature)).returns(T.class_of(DSPy::Signature)) }
  def build_enhanced_signature(signature_class); end

  # Count reasoning steps by looking for step indicators
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#185
  sig { params(reasoning_text: ::String).returns(::Integer) }
  def count_reasoning_steps(reasoning_text); end

  # Creates enhanced output struct with reasoning field
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#146
  sig { params(signature_class: T.class_of(DSPy::Signature)).returns(T.class_of(T::Struct)) }
  def create_enhanced_output_struct(signature_class); end

  # Creates signature class with enhanced description and reasoning field
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#107
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      enhanced_output_struct: T.class_of(T::Struct)
    ).returns(T.class_of(DSPy::Signature))
  end
  def create_signature_class(signature_class, enhanced_output_struct); end

  # Emits reasoning analysis instrumentation event
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#174
  sig { params(reasoning_content: ::String).void }
  def emit_reasoning_analysis(reasoning_content); end

  # Ensures instruction includes chain of thought prompt
  #
  # source://dspy//lib/dspy/chain_of_thought.rb#157
  sig { params(instruction: ::String).returns(::String) }
  def ensure_chain_of_thought_instruction(instruction); end
end

# source://dspy//lib/dspy/chain_of_thought.rb#16
DSPy::ChainOfThought::FieldDescriptor = DSPy::Signature::FieldDescriptor

# CodeAct Agent using Think-Code-Observe pattern
#
# source://dspy//lib/dspy/code_act.rb#89
class DSPy::CodeAct < ::DSPy::Predict
  # source://dspy//lib/dspy/code_act.rb#106
  sig { params(signature_class: T.class_of(DSPy::Signature), max_iterations: ::Integer).void }
  def initialize(signature_class, max_iterations: T.unsafe(nil)); end

  # source://dspy//lib/dspy/code_act.rb#97
  sig { returns(T.class_of(T::Struct)) }
  def enhanced_output_struct; end

  # source://dspy//lib/dspy/code_act.rb#103
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def execution_context; end

  # source://dspy//lib/dspy/code_act.rb#142
  sig { override.params(kwargs: T.untyped).returns(T.untyped) }
  def forward(**kwargs); end

  # source://dspy//lib/dspy/code_act.rb#100
  sig { returns(::Integer) }
  def max_iterations; end

  # source://dspy//lib/dspy/code_act.rb#94
  sig { returns(T.class_of(DSPy::Signature)) }
  def original_signature_class; end

  private

  # source://dspy//lib/dspy/code_act.rb#338
  sig { params(history: T::Array[::DSPy::CodeActHistoryEntry]).returns(::String) }
  def build_context_from_history(history); end

  # Creates enhanced output struct with CodeAct-specific fields
  #
  # source://dspy//lib/dspy/code_act.rb#263
  sig { params(signature_class: T.class_of(DSPy::Signature)).returns(T.class_of(T::Struct)) }
  def create_enhanced_output_struct(signature_class); end

  # Creates enhanced result struct
  #
  # source://dspy//lib/dspy/code_act.rb#279
  sig do
    params(
      input_kwargs: T::Hash[::Symbol, T.untyped],
      reasoning_result: T::Hash[::Symbol, T.untyped]
    ).returns(T.untyped)
  end
  def create_enhanced_result(input_kwargs, reasoning_result); end

  # source://dspy//lib/dspy/code_act.rb#311
  sig do
    params(
      step: ::Integer,
      thought: ::String,
      ruby_code: ::String,
      execution_result: T.nilable(::String),
      error_message: ::String
    ).returns(::DSPy::CodeActHistoryEntry)
  end
  def create_history_entry(step, thought, ruby_code, execution_result, error_message); end

  # source://dspy//lib/dspy/code_act.rb#374
  sig { returns(::String) }
  def default_no_answer_message; end

  # source://dspy//lib/dspy/code_act.rb#351
  sig do
    params(
      iteration: ::Integer,
      thought: ::String,
      ruby_code: ::String,
      execution_result: T.nilable(::String),
      error_message: T.nilable(::String)
    ).void
  end
  def emit_iteration_complete_event(iteration, thought, ruby_code, execution_result, error_message); end

  # Executes the main CodeAct reasoning loop (Think-Code-Observe)
  #
  # source://dspy//lib/dspy/code_act.rb#160
  sig { params(task: ::String).returns(T::Hash[::Symbol, T.untyped]) }
  def execute_codeact_reasoning_loop(task); end

  # Safe Ruby code execution method - placeholder for now
  #
  # source://dspy//lib/dspy/code_act.rb#380
  sig { params(ruby_code: ::String).returns([T.nilable(::String), ::String]) }
  def execute_ruby_code_safely(ruby_code); end

  # source://dspy//lib/dspy/code_act.rb#299
  sig { params(ruby_code: ::String, iteration: ::Integer).returns([T.nilable(::String), ::String]) }
  def execute_ruby_code_with_instrumentation(ruby_code, iteration); end

  # Executes a single iteration of the Think-Code-Observe loop
  #
  # source://dspy//lib/dspy/code_act.rb#194
  sig do
    params(
      task: ::String,
      history: T::Array[::DSPy::CodeActHistoryEntry],
      context: ::String,
      iteration: ::Integer
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def execute_single_iteration(task, history, context, iteration); end

  # Executes the Think-Code step: generates code and executes it
  #
  # source://dspy//lib/dspy/code_act.rb#219
  sig do
    params(
      task: ::String,
      context: ::String,
      history: T::Array[::DSPy::CodeActHistoryEntry],
      iteration: ::Integer
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def execute_think_code_step(task, context, history, iteration); end

  # Finalizes iteration by updating context and emitting events
  #
  # source://dspy//lib/dspy/code_act.rb#246
  sig do
    params(
      execution_state: T::Hash[::Symbol, T.untyped],
      iteration: ::Integer
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def finalize_iteration(execution_state, iteration); end

  # source://dspy//lib/dspy/code_act.rb#439
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def generate_example_output; end

  # source://dspy//lib/dspy/code_act.rb#363
  sig do
    params(
      iterations_count: ::Integer,
      final_answer: T.nilable(::String),
      history: T::Array[::DSPy::CodeActHistoryEntry]
    ).void
  end
  def handle_max_iterations_if_needed(iterations_count, final_answer, history); end

  # source://dspy//lib/dspy/code_act.rb#322
  sig do
    params(
      task: ::String,
      history: T::Array[::DSPy::CodeActHistoryEntry],
      execution_result: T.nilable(::String),
      error_message: ::String,
      iteration: ::Integer
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def process_observation_and_decide_next_step(task, history, execution_result, error_message, iteration); end

  # Helper methods for CodeAct logic
  #
  # source://dspy//lib/dspy/code_act.rb#294
  sig { params(iterations_count: ::Integer, final_answer: T.nilable(::String)).returns(T::Boolean) }
  def should_continue_iteration?(iterations_count, final_answer); end

  # source://dspy//lib/dspy/code_act.rb#411
  sig { params(output: T.untyped).void }
  def validate_output_schema!(output); end
end

# Define a simple struct for CodeAct history entries with proper type annotations
#
# source://dspy//lib/dspy/code_act.rb#14
class DSPy::CodeActHistoryEntry < ::T::Struct
  const :step, ::Integer
  prop :thought, T.nilable(::String)
  prop :ruby_code, T.nilable(::String)
  prop :execution_result, T.nilable(::String)
  prop :error_message, ::String

  # Custom serialization to ensure compatibility with the rest of the code
  #
  # source://dspy//lib/dspy/code_act.rb#22
  def to_h; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://dspy//lib/dspy/code_act.rb#56
class DSPy::CodeActNextStep < ::T::Enum
  enums do
    Continue = new
    Finish = new
  end
end

# source://dspy//lib/dspy/errors.rb#10
class DSPy::ConfigurationError < ::DSPy::Error
  class << self
    # source://dspy//lib/dspy/errors.rb#11
    def missing_lm(module_name); end
  end
end

# source://dspy//lib/dspy/context.rb#6
class DSPy::Context
  class << self
    # source://dspy//lib/dspy/context.rb#62
    def clear!; end

    # source://dspy//lib/dspy/context.rb#8
    def current; end

    # source://dspy//lib/dspy/context.rb#15
    def with_span(operation:, **attributes); end
  end
end

# source://dspy//lib/dspy/errors.rb#8
class DSPy::DeserializationError < ::DSPy::Error; end

# source://dspy//lib/dspy/errors.rb#4
class DSPy::Error < ::StandardError; end

# Utility class for formatting complex error messages into human-readable format
#
# source://dspy//lib/dspy/error_formatter.rb#7
class DSPy::ErrorFormatter
  class << self
    # Check if this is an ArgumentError (missing required fields, etc.)
    #
    # source://dspy//lib/dspy/error_formatter.rb#34
    sig { params(message: ::String).returns(T::Boolean) }
    def argument_error?(message); end

    # Clean up error messages by removing internal stack traces and formatting
    #
    # source://dspy//lib/dspy/error_formatter.rb#201
    sig { params(message: ::String).returns(::String) }
    def clean_error_message(message); end

    # Format ArgumentError messages (missing/unknown keywords)
    #
    # source://dspy//lib/dspy/error_formatter.rb#74
    sig { params(message: ::String).returns(::String) }
    def format_argument_error(message); end

    # Main entry point for formatting errors
    #
    # source://dspy//lib/dspy/error_formatter.rb#12
    sig { params(error_message: ::String, context: T.nilable(::String)).returns(::String) }
    def format_error(error_message, context = T.unsafe(nil)); end

    # Format missing required fields error
    #
    # source://dspy//lib/dspy/error_formatter.rb#88
    sig { params(fields: T::Array[::String]).returns(::String) }
    def format_missing_fields_error(fields); end

    # Format Sorbet type validation errors
    #
    # source://dspy//lib/dspy/error_formatter.rb#40
    sig { params(message: ::String).returns(::String) }
    def format_sorbet_type_error(message); end

    # Format unknown fields error
    #
    # source://dspy//lib/dspy/error_formatter.rb#108
    sig { params(fields: T::Array[::String]).returns(::String) }
    def format_unknown_fields_error(fields); end

    # Generate field and type-specific suggestions
    #
    # source://dspy//lib/dspy/error_formatter.rb#156
    sig { params(field_name: ::String, actual_type: ::String, expected_type: ::String).returns(::String) }
    def generate_suggestions(field_name, actual_type, expected_type); end

    # Generate type-specific explanations
    #
    # source://dspy//lib/dspy/error_formatter.rb#128
    sig { params(actual_type: ::String, expected_type: ::String).returns(::String) }
    def generate_type_specific_explanation(actual_type, expected_type); end

    # Check if this is a Sorbet runtime type validation error
    #
    # source://dspy//lib/dspy/error_formatter.rb#28
    sig { params(message: ::String).returns(T::Boolean) }
    def sorbet_type_error?(message); end
  end
end

# Core evaluation framework for DSPy programs
# Supports single evaluations, batch evaluations, and optimization workflows
#
# source://dspy//lib/dspy/evaluate.rb#9
class DSPy::Evaluate
  # source://dspy//lib/dspy/evaluate.rb#129
  sig do
    params(
      program: T.untyped,
      metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean)),
      num_threads: T.nilable(::Integer),
      max_errors: T.nilable(::Integer),
      provide_traceback: T::Boolean
    ).void
  end
  def initialize(program, metric: T.unsafe(nil), num_threads: T.unsafe(nil), max_errors: T.unsafe(nil), provide_traceback: T.unsafe(nil)); end

  # Evaluate program on a single example
  #
  # source://dspy//lib/dspy/evaluate.rb#139
  sig { params(example: T.untyped, trace: T.nilable(T.untyped)).returns(::DSPy::Evaluate::EvaluationResult) }
  def call(example, trace: T.unsafe(nil)); end

  # Evaluate program on multiple examples
  #
  # source://dspy//lib/dspy/evaluate.rb#212
  sig do
    params(
      devset: T::Array[T.untyped],
      display_progress: T::Boolean,
      display_table: T::Boolean,
      return_outputs: T::Boolean
    ).returns(::DSPy::Evaluate::BatchEvaluationResult)
  end
  def evaluate(devset, display_progress: T.unsafe(nil), display_table: T.unsafe(nil), return_outputs: T.unsafe(nil)); end

  # source://dspy//lib/dspy/evaluate.rb#115
  sig { returns(T.nilable(::Integer)) }
  def max_errors; end

  # source://dspy//lib/dspy/evaluate.rb#109
  sig { returns(T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))) }
  def metric; end

  # source://dspy//lib/dspy/evaluate.rb#112
  sig { returns(T.nilable(::Integer)) }
  def num_threads; end

  # source://dspy//lib/dspy/evaluate.rb#106
  sig { returns(T.untyped) }
  def program; end

  # source://dspy//lib/dspy/evaluate.rb#118
  sig { returns(T::Boolean) }
  def provide_traceback; end

  private

  # Aggregate metrics across all results
  #
  # source://dspy//lib/dspy/evaluate.rb#376
  sig { params(results: T::Array[::DSPy::Evaluate::EvaluationResult]).returns(T::Hash[::Symbol, T.untyped]) }
  def aggregate_metrics(results); end

  # Display results in a table format
  #
  # source://dspy//lib/dspy/evaluate.rb#414
  sig { params(batch_result: ::DSPy::Evaluate::BatchEvaluationResult).void }
  def display_results_table(batch_result); end

  # Extract expected values for metric comparison (used internally)
  #
  # source://dspy//lib/dspy/evaluate.rb#349
  sig { params(example: T.untyped).returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
  def extract_expected_values(example); end

  # Extract input values from example in various formats
  #
  # source://dspy//lib/dspy/evaluate.rb#292
  sig { params(example: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def extract_input_values(example); end
end

# Batch evaluation results with aggregated metrics
#
# source://dspy//lib/dspy/evaluate.rb#61
class DSPy::Evaluate::BatchEvaluationResult
  # source://dspy//lib/dspy/evaluate.rb#85
  sig do
    params(
      results: T::Array[::DSPy::Evaluate::EvaluationResult],
      aggregated_metrics: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(results:, aggregated_metrics:); end

  # source://dspy//lib/dspy/evaluate.rb#68
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def aggregated_metrics; end

  # source://dspy//lib/dspy/evaluate.rb#77
  sig { returns(::Float) }
  def pass_rate; end

  # source://dspy//lib/dspy/evaluate.rb#74
  sig { returns(::Integer) }
  def passed_examples; end

  # source://dspy//lib/dspy/evaluate.rb#65
  sig { returns(T::Array[::DSPy::Evaluate::EvaluationResult]) }
  def results; end

  # source://dspy//lib/dspy/evaluate.rb#94
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # source://dspy//lib/dspy/evaluate.rb#71
  sig { returns(::Integer) }
  def total_examples; end
end

# Result of evaluating a single example
#
# source://dspy//lib/dspy/evaluate.rb#13
class DSPy::Evaluate::EvaluationResult
  # source://dspy//lib/dspy/evaluate.rb#40
  sig do
    params(
      example: T.untyped,
      prediction: T.untyped,
      trace: T.untyped,
      metrics: T::Hash[::Symbol, T.untyped],
      passed: T::Boolean
    ).void
  end
  def initialize(example:, prediction:, trace:, metrics:, passed:); end

  # source://dspy//lib/dspy/evaluate.rb#17
  sig { returns(T.untyped) }
  def example; end

  # source://dspy//lib/dspy/evaluate.rb#26
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def metrics; end

  # source://dspy//lib/dspy/evaluate.rb#29
  sig { returns(T::Boolean) }
  def passed; end

  # source://dspy//lib/dspy/evaluate.rb#20
  sig { returns(T.untyped) }
  def prediction; end

  # source://dspy//lib/dspy/evaluate.rb#49
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # source://dspy//lib/dspy/evaluate.rb#23
  sig { returns(T.untyped) }
  def trace; end
end

# Represents a typed training/evaluation example with Signature validation
# Provides early validation and type safety for evaluation workflows
#
# source://dspy//lib/dspy/example.rb#9
class DSPy::Example
  # source://dspy//lib/dspy/example.rb#36
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      input: T::Hash[::Symbol, T.untyped],
      expected: T::Hash[::Symbol, T.untyped],
      id: T.nilable(::String),
      metadata: T.nilable(T::Hash[::Symbol, T.untyped])
    ).void
  end
  def initialize(signature_class:, input:, expected:, id: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # Custom equality comparison
  #
  # source://dspy//lib/dspy/example.rb#82
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://dspy//lib/dspy/example.rb#19
  sig { returns(::T::Struct) }
  def expected; end

  # Convert expected struct to hash for comparison
  #
  # source://dspy//lib/dspy/example.rb#72
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def expected_values; end

  # source://dspy//lib/dspy/example.rb#22
  sig { returns(T.nilable(::String)) }
  def id; end

  # source://dspy//lib/dspy/example.rb#16
  sig { returns(::T::Struct) }
  def input; end

  # Convert input struct to hash for program execution
  #
  # source://dspy//lib/dspy/example.rb#62
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def input_values; end

  # source://dspy//lib/dspy/example.rb#221
  sig { returns(::String) }
  def inspect; end

  # Check if prediction matches expected output using struct comparison
  #
  # source://dspy//lib/dspy/example.rb#93
  sig { params(prediction: T.untyped).returns(T::Boolean) }
  def matches_prediction?(prediction); end

  # source://dspy//lib/dspy/example.rb#25
  sig { returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
  def metadata; end

  # source://dspy//lib/dspy/example.rb#13
  sig { returns(T.class_of(DSPy::Signature)) }
  def signature_class; end

  # Serialization for persistence and debugging
  #
  # source://dspy//lib/dspy/example.rb#116
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # String representation for debugging
  #
  # source://dspy//lib/dspy/example.rb#196
  sig { returns(::String) }
  def to_s; end

  private

  # Format hash without escaping Unicode characters
  #
  # source://dspy//lib/dspy/example.rb#204
  sig { params(hash: T::Hash[::Symbol, T.untyped]).returns(::String) }
  def format_hash(hash); end

  class << self
    # Create Example from hash representation
    #
    # source://dspy//lib/dspy/example.rb#135
    sig do
      params(
        hash: T::Hash[::Symbol, T.untyped],
        signature_registry: T.nilable(T::Hash[::String, T.class_of(DSPy::Signature)])
      ).returns(::DSPy::Example)
    end
    def from_h(hash, signature_registry: T.unsafe(nil)); end

    # Batch validation for multiple examples
    #
    # source://dspy//lib/dspy/example.rb#163
    sig do
      params(
        signature_class: T.class_of(DSPy::Signature),
        examples_data: T::Array[T::Hash[::Symbol, T.untyped]]
      ).returns(T::Array[::DSPy::Example])
    end
    def validate_batch(signature_class, examples_data); end
  end
end

# source://dspy//lib/dspy/few_shot_example.rb#6
class DSPy::FewShotExample
  # source://dspy//lib/dspy/few_shot_example.rb#25
  sig do
    params(
      input: T::Hash[::Symbol, T.untyped],
      output: T::Hash[::Symbol, T.untyped],
      reasoning: T.nilable(::String)
    ).void
  end
  def initialize(input:, output:, reasoning: T.unsafe(nil)); end

  # source://dspy//lib/dspy/few_shot_example.rb#73
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://dspy//lib/dspy/few_shot_example.rb#10
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def input; end

  # source://dspy//lib/dspy/few_shot_example.rb#13
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def output; end

  # source://dspy//lib/dspy/few_shot_example.rb#16
  sig { returns(T.nilable(::String)) }
  def reasoning; end

  # source://dspy//lib/dspy/few_shot_example.rb#54
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # source://dspy//lib/dspy/few_shot_example.rb#32
  sig { returns(::String) }
  def to_prompt_section; end

  class << self
    # source://dspy//lib/dspy/few_shot_example.rb#64
    sig { params(hash: T::Hash[::Symbol, T.untyped]).returns(::DSPy::FewShotExample) }
    def from_h(hash); end
  end
end

# Define a simple struct for history entries with proper type annotations
#
# source://dspy//lib/dspy/re_act.rb#13
class DSPy::HistoryEntry < ::T::Struct
  const :step, ::Integer
  prop :thought, T.nilable(::String)
  prop :action, T.nilable(::String)
  prop :action_input, T.nilable(T.any(::Numeric, ::String, T::Array[T.untyped], T::Hash[T.untyped, T.untyped]))
  prop :observation, T.nilable(::String)

  # Custom serialization to ensure compatibility with the rest of the code
  #
  # source://dspy//lib/dspy/re_act.rb#21
  def to_h; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://dspy//lib/dspy/image.rb#7
class DSPy::Image
  # @return [Image] a new instance of Image
  #
  # source://dspy//lib/dspy/image.rb#25
  def initialize(url: T.unsafe(nil), base64: T.unsafe(nil), data: T.unsafe(nil), content_type: T.unsafe(nil), detail: T.unsafe(nil)); end

  # Returns the value of attribute base64.
  #
  # source://dspy//lib/dspy/image.rb#8
  def base64; end

  # Returns the value of attribute content_type.
  #
  # source://dspy//lib/dspy/image.rb#8
  def content_type; end

  # Returns the value of attribute data.
  #
  # source://dspy//lib/dspy/image.rb#8
  def data; end

  # Returns the value of attribute detail.
  #
  # source://dspy//lib/dspy/image.rb#8
  def detail; end

  # source://dspy//lib/dspy/image.rb#76
  def to_anthropic_format; end

  # source://dspy//lib/dspy/image.rb#102
  def to_base64; end

  # source://dspy//lib/dspy/image.rb#49
  def to_openai_format; end

  # Returns the value of attribute url.
  #
  # source://dspy//lib/dspy/image.rb#8
  def url; end

  # source://dspy//lib/dspy/image.rb#108
  def validate!; end

  # source://dspy//lib/dspy/image.rb#118
  def validate_for_provider!(provider); end

  private

  # source://dspy//lib/dspy/image.rb#179
  def infer_content_type_from_url(url); end

  # source://dspy//lib/dspy/image.rb#167
  def validate_content_type!; end

  # source://dspy//lib/dspy/image.rb#157
  def validate_input!(url, base64, data); end

  # source://dspy//lib/dspy/image.rb#173
  def validate_size!(size_bytes); end
end

# 5MB limit
#
# source://dspy//lib/dspy/image.rb#11
DSPy::Image::MAX_SIZE_BYTES = T.let(T.unsafe(nil), Integer)

# Provider capability registry
#
# source://dspy//lib/dspy/image.rb#14
DSPy::Image::PROVIDER_CAPABILITIES = T.let(T.unsafe(nil), Hash)

# source://dspy//lib/dspy/image.rb#10
DSPy::Image::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Array)

# source://dspy//lib/dspy/field.rb#4
class DSPy::InputField
  # @return [InputField] a new instance of InputField
  #
  # source://dspy//lib/dspy/field.rb#7
  def initialize(name, type, desc: T.unsafe(nil)); end

  # Returns the value of attribute desc.
  #
  # source://dspy//lib/dspy/field.rb#5
  def desc; end

  # Returns the value of attribute name.
  #
  # source://dspy//lib/dspy/field.rb#5
  def name; end

  # Returns the value of attribute type.
  #
  # source://dspy//lib/dspy/field.rb#5
  def type; end
end

# source://dspy//lib/dspy/lm/errors.rb#4
class DSPy::LM
  # @return [LM] a new instance of LM
  #
  # source://dspy//lib/dspy/lm.rb#31
  def initialize(model_id, api_key: T.unsafe(nil), **options); end

  # Returns the value of attribute adapter.
  #
  # source://dspy//lib/dspy/lm.rb#29
  def adapter; end

  # Returns the value of attribute api_key.
  #
  # source://dspy//lib/dspy/lm.rb#29
  def api_key; end

  # source://dspy//lib/dspy/lm.rb#42
  def chat(inference_module, input_values, &block); end

  # source://dspy//lib/dspy/lm.rb#326
  def execute_raw_chat(messages, &streaming_block); end

  # Convert Message objects to hash array for adapters
  #
  # source://dspy//lib/dspy/lm.rb#379
  def messages_to_hash_array(messages); end

  # Returns the value of attribute model.
  #
  # source://dspy//lib/dspy/lm.rb#29
  def model; end

  # Returns the value of attribute model_id.
  #
  # source://dspy//lib/dspy/lm.rb#29
  def model_id; end

  # Convert messages to normalized Message objects
  #
  # source://dspy//lib/dspy/lm.rb#339
  def normalize_messages(messages); end

  # Returns the value of attribute provider.
  #
  # source://dspy//lib/dspy/lm.rb#29
  def provider; end

  # source://dspy//lib/dspy/lm.rb#59
  def raw_chat(messages = T.unsafe(nil), &block); end

  # source://dspy//lib/dspy/lm.rb#304
  def validate_messages!(messages); end

  private

  # source://dspy//lib/dspy/lm.rb#164
  def build_messages(inference_module, input_values); end

  # source://dspy//lib/dspy/lm.rb#82
  def chat_with_strategy(messages, signature_class, &block); end

  # Common method to emit token usage events
  #
  # source://dspy//lib/dspy/lm.rb#249
  def emit_token_usage(response, signature_class_name); end

  # source://dspy//lib/dspy/lm.rb#100
  def execute_chat_with_strategy(messages, signature_class, strategy, &block); end

  # Extract token usage from API responses
  #
  # source://dspy//lib/dspy/lm.rb#267
  sig { params(response: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def extract_token_usage(response); end

  # Common instrumentation method for LM requests
  #
  # source://dspy//lib/dspy/lm.rb#210
  def instrument_lm_request(messages, signature_class_name, &execution_block); end

  # Determines if we're in a nested context where higher-level events are being emitted
  #
  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm.rb#139
  def is_nested_context?; end

  # source://dspy//lib/dspy/lm.rb#155
  def parse_model_id(model_id); end

  # source://dspy//lib/dspy/lm.rb#186
  def parse_response(response, input_values, signature_class); end

  # Determines if LM-level events should be emitted using smart consolidation
  #
  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm.rb#133
  def should_emit_lm_events?; end

  class << self
    # source://dspy//lib/dspy/lm/cache_manager.rb#146
    sig { returns(::DSPy::LM::CacheManager) }
    def cache_manager; end
  end
end

# Base adapter interface for all LM providers
#
# source://dspy//lib/dspy/lm/adapter.rb#6
class DSPy::LM::Adapter
  # @return [Adapter] a new instance of Adapter
  #
  # source://dspy//lib/dspy/lm/adapter.rb#9
  def initialize(model:, api_key:); end

  # Returns the value of attribute api_key.
  #
  # source://dspy//lib/dspy/lm/adapter.rb#7
  def api_key; end

  # Chat interface that all adapters must implement
  #
  # @param messages [Array<Hash>] Array of message hashes with :role and :content
  # @param signature [DSPy::Signature, nil] Optional signature for structured outputs
  # @param block [Proc] Optional streaming block
  # @raise [NotImplementedError]
  # @return [DSPy::LM::Response] Normalized response
  #
  # source://dspy//lib/dspy/lm/adapter.rb#20
  def chat(messages:, signature: T.unsafe(nil), &block); end

  # Returns the value of attribute model.
  #
  # source://dspy//lib/dspy/lm/adapter.rb#7
  def model; end

  private

  # Check if messages contain images
  #
  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm/adapter.rb#54
  def contains_images?(messages); end

  # Helper method to normalize message format
  #
  # source://dspy//lib/dspy/lm/adapter.rb#37
  def normalize_messages(messages); end

  # source://dspy//lib/dspy/lm/adapter.rb#30
  def validate_api_key!(api_key, provider); end

  # @raise [ConfigurationError]
  #
  # source://dspy//lib/dspy/lm/adapter.rb#26
  def validate_configuration!; end
end

# source://dspy//lib/dspy/lm/errors.rb#6
class DSPy::LM::AdapterError < ::DSPy::LM::Error; end

# Factory for creating appropriate adapters based on model_id
#
# source://dspy//lib/dspy/lm/adapter_factory.rb#6
class DSPy::LM::AdapterFactory
  class << self
    # Creates an adapter instance based on model_id
    #
    # @param model_id [String] Full model identifier (e.g., "openai/gpt-4")
    # @param api_key [String] API key for the provider
    # @param options [Hash] Additional adapter-specific options
    # @return [DSPy::LM::Adapter] Appropriate adapter instance
    #
    # source://dspy//lib/dspy/lm/adapter_factory.rb#20
    def create(model_id, api_key:, **options); end

    private

    # source://dspy//lib/dspy/lm/adapter_factory.rb#44
    def get_adapter_class(provider); end

    # Parse model_id to determine provider and model
    #
    # source://dspy//lib/dspy/lm/adapter_factory.rb#35
    def parse_model_id(model_id); end
  end
end

# Maps provider prefixes to adapter classes
#
# source://dspy//lib/dspy/lm/adapter_factory.rb#8
DSPy::LM::AdapterFactory::ADAPTER_MAP = T.let(T.unsafe(nil), Hash)

# source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#8
module DSPy::LM::Adapters; end

# source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#9
module DSPy::LM::Adapters::OpenAI; end

# Converts DSPy signatures to OpenAI structured output format
#
# source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#11
class DSPy::LM::Adapters::OpenAI::SchemaConverter
  class << self
    # source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#124
    sig { params(schema: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
    def add_additional_properties_recursively(schema); end

    # source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#194
    sig { params(schema: T::Hash[::Symbol, T.untyped], current_depth: ::Integer).returns(::Integer) }
    def calculate_depth(schema, current_depth = T.unsafe(nil)); end

    # source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#249
    sig { params(schema: T::Hash[::Symbol, T.untyped]).returns(T::Boolean) }
    def contains_conditional_schemas?(schema); end

    # source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#231
    sig { params(schema: T::Hash[::Symbol, T.untyped]).returns(T::Boolean) }
    def contains_pattern_properties?(schema); end

    # source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#182
    sig { params(signature_class: T.class_of(DSPy::Signature)).returns(::String) }
    def generate_schema_name(signature_class); end

    # source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#77
    sig { params(model: ::String).returns(T::Boolean) }
    def supports_structured_outputs?(model); end

    # source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#24
    sig do
      params(
        signature_class: T.class_of(DSPy::Signature),
        name: T.nilable(::String),
        strict: T::Boolean
      ).returns(T::Hash[::Symbol, T.untyped])
    end
    def to_openai_format(signature_class, name: T.unsafe(nil), strict: T.unsafe(nil)); end

    # source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#100
    sig { params(schema: T::Hash[::Symbol, T.untyped]).returns(T::Array[::String]) }
    def validate_compatibility(schema); end
  end
end

# Models that support structured outputs as of July 2025
#
# source://dspy//lib/dspy/lm/adapters/openai/schema_converter.rb#15
DSPy::LM::Adapters::OpenAI::SchemaConverter::STRUCTURED_OUTPUT_MODELS = T.let(T.unsafe(nil), Array)

# source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#8
class DSPy::LM::AnthropicAdapter < ::DSPy::LM::Adapter
  # @return [AnthropicAdapter] a new instance of AnthropicAdapter
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#9
  def initialize(model:, api_key:); end

  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#15
  def chat(messages:, signature: T.unsafe(nil), **extra_params, &block); end

  private

  # Add assistant message prefill to guide Claude
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#243
  def add_json_prefill(user_messages); end

  # Enhance the last user message with strong JSON instructions
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#223
  def enhance_json_instructions(user_messages); end

  # Enhanced JSON extraction specifically for Claude models
  # Handles multiple patterns of markdown-wrapped JSON responses
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#146
  def extract_json_from_response(content); end

  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#247
  def extract_system_message(messages); end

  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#262
  def format_multimodal_messages(messages); end

  # Simple heuristic to check if content looks like JSON
  #
  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#175
  def looks_like_json?(str); end

  # Prepare messages for JSON output by adding prefilling and strong instructions
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#183
  def prepare_messages_for_json(user_messages, system_message); end

  # Detect if the conversation requires JSON output
  #
  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#199
  def requires_json_output?(user_messages, system_message); end

  # Check if this is a Claude model that benefits from prefilling
  #
  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#211
  def supports_prefilling?; end

  # Check if this is a Claude model that tends to wrap JSON in markdown
  #
  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm/adapters/anthropic_adapter.rb#217
  def tends_to_wrap_json?; end
end

# Anthropic-specific metadata with additional fields
#
# source://dspy//lib/dspy/lm/response.rb#59
class DSPy::LM::AnthropicResponseMetadata < ::T::Struct
  const :provider, ::String
  const :model, ::String
  const :response_id, T.nilable(::String), default: T.unsafe(nil)
  const :created, T.nilable(::Integer), default: T.unsafe(nil)
  const :structured_output, T.nilable(T::Boolean), default: T.unsafe(nil)
  const :stop_reason, T.nilable(::String), default: T.unsafe(nil)
  const :stop_sequence, T.nilable(::String), default: T.unsafe(nil)
  const :tool_calls, T.nilable(T::Array[T::Hash[::Symbol, T.untyped]]), default: T.unsafe(nil)

  # source://dspy//lib/dspy/lm/response.rb#72
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Manages caching for schemas and capability detection
#
# source://dspy//lib/dspy/lm/cache_manager.rb#8
class DSPy::LM::CacheManager
  # source://dspy//lib/dspy/lm/cache_manager.rb#27
  sig { void }
  def initialize; end

  # Cache capability detection result
  #
  # source://dspy//lib/dspy/lm/cache_manager.rb#69
  sig { params(model: ::String, capability: ::String, result: T::Boolean).void }
  def cache_capability(model, capability, result); end

  # Cache a schema for a signature class
  #
  # source://dspy//lib/dspy/lm/cache_manager.rb#35
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      provider: ::String,
      schema: T.untyped,
      cache_params: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def cache_schema(signature_class, provider, schema, cache_params = T.unsafe(nil)); end

  # Clear all caches
  #
  # source://dspy//lib/dspy/lm/cache_manager.rb#103
  sig { void }
  def clear!; end

  # Get cached capability if available
  #
  # source://dspy//lib/dspy/lm/cache_manager.rb#84
  sig { params(model: ::String, capability: ::String).returns(T.nilable(T::Boolean)) }
  def get_capability(model, capability); end

  # Get cached schema if available
  #
  # source://dspy//lib/dspy/lm/cache_manager.rb#50
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      provider: ::String,
      cache_params: T::Hash[::Symbol, T.untyped]
    ).returns(T.nilable(T.untyped))
  end
  def get_schema(signature_class, provider, cache_params = T.unsafe(nil)); end

  # Get cache statistics
  #
  # source://dspy//lib/dspy/lm/cache_manager.rb#114
  sig { returns(T::Hash[::Symbol, ::Integer]) }
  def stats; end

  private

  # source://dspy//lib/dspy/lm/cache_manager.rb#134
  sig { params(model: ::String, capability: ::String).returns(::String) }
  def capability_key(model, capability); end

  # source://dspy//lib/dspy/lm/cache_manager.rb#127
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      provider: ::String,
      cache_params: T::Hash[::Symbol, T.untyped]
    ).returns(::String)
  end
  def schema_key(signature_class, provider, cache_params = T.unsafe(nil)); end
end

# Cache entry with TTL
#
# source://dspy//lib/dspy/lm/cache_manager.rb#12
class DSPy::LM::CacheManager::CacheEntry < ::T::Struct
  const :value, T.untyped
  const :expires_at, ::Time

  # source://dspy//lib/dspy/lm/cache_manager.rb#19
  sig { returns(T::Boolean) }
  def expired?; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# 1 hour
#
# source://dspy//lib/dspy/lm/cache_manager.rb#24
DSPy::LM::CacheManager::DEFAULT_TTL = T.let(T.unsafe(nil), Integer)

# source://dspy//lib/dspy/lm/errors.rb#8
class DSPy::LM::ConfigurationError < ::DSPy::LM::Error; end

# source://dspy//lib/dspy/lm/errors.rb#5
class DSPy::LM::Error < ::StandardError; end

# Raised when image features are incompatible with the target provider
#
# source://dspy//lib/dspy/lm/errors.rb#24
class DSPy::LM::IncompatibleImageFeatureError < ::DSPy::LM::AdapterError
  # @return [IncompatibleImageFeatureError] a new instance of IncompatibleImageFeatureError
  #
  # source://dspy//lib/dspy/lm/errors.rb#25
  def initialize(message); end
end

# Type-safe representation of chat messages
#
# source://dspy//lib/dspy/lm/message.rb#8
class DSPy::LM::Message < ::T::Struct
  const :role, ::DSPy::LM::Message::Role
  const :content, T.any(::String, T::Array[T::Hash[::Symbol, T.untyped]])
  const :name, T.nilable(::String), default: T.unsafe(nil)

  # source://dspy//lib/dspy/lm/message.rb#44
  sig { returns(T::Boolean) }
  def multimodal?; end

  # source://dspy//lib/dspy/lm/message.rb#73
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_anthropic_format; end

  # source://dspy//lib/dspy/lm/message.rb#25
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # source://dspy//lib/dspy/lm/message.rb#49
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_openai_format; end

  # source://dspy//lib/dspy/lm/message.rb#35
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Role enum for type safety
#
# source://dspy//lib/dspy/lm/message.rb#12
class DSPy::LM::Message::Role < ::T::Enum
  enums do
    Assistant = new
    System = new
    User = new
  end
end

# source://dspy//lib/dspy/lm/message_builder.rb#7
class DSPy::LM::MessageBuilder
  # @return [MessageBuilder] a new instance of MessageBuilder
  #
  # source://dspy//lib/dspy/lm/message_builder.rb#13
  def initialize; end

  # source://dspy//lib/dspy/lm/message_builder.rb#36
  sig { params(content: T.any(::String, T.untyped)).returns(::DSPy::LM::MessageBuilder) }
  def assistant(content); end

  # source://dspy//lib/dspy/lm/message_builder.rb#11
  sig { returns(T::Array[::DSPy::LM::Message]) }
  def messages; end

  # source://dspy//lib/dspy/lm/message_builder.rb#18
  sig { params(content: T.any(::String, T.untyped)).returns(::DSPy::LM::MessageBuilder) }
  def system(content); end

  # For backward compatibility, allow conversion to hash array
  #
  # source://dspy//lib/dspy/lm/message_builder.rb#74
  sig { returns(T::Array[T::Hash[::Symbol, T.untyped]]) }
  def to_h; end

  # source://dspy//lib/dspy/lm/message_builder.rb#27
  sig { params(content: T.any(::String, T.untyped)).returns(::DSPy::LM::MessageBuilder) }
  def user(content); end

  # source://dspy//lib/dspy/lm/message_builder.rb#45
  sig { params(text: ::String, image: ::DSPy::Image).returns(::DSPy::LM::MessageBuilder) }
  def user_with_image(text, image); end

  # source://dspy//lib/dspy/lm/message_builder.rb#59
  sig { params(text: ::String, images: T::Array[::DSPy::Image]).returns(::DSPy::LM::MessageBuilder) }
  def user_with_images(text, images); end
end

# Factory for creating Message objects from various formats
#
# source://dspy//lib/dspy/lm/message.rb#98
module DSPy::LM::MessageFactory
  class << self
    # source://dspy//lib/dspy/lm/message.rb#102
    sig { params(message_data: T.untyped).returns(T.nilable(::DSPy::LM::Message)) }
    def create(message_data); end

    # source://dspy//lib/dspy/lm/message.rb#129
    sig { params(data: T::Hash[::Symbol, T.untyped]).returns(T.nilable(::DSPy::LM::Message)) }
    def create_from_hash(data); end

    # source://dspy//lib/dspy/lm/message.rb#122
    sig { params(messages: T::Array[T.untyped]).returns(T::Array[::DSPy::LM::Message]) }
    def create_many(messages); end
  end
end

# Raised when API key is missing or invalid
#
# source://dspy//lib/dspy/lm/errors.rb#11
class DSPy::LM::MissingAPIKeyError < ::DSPy::LM::Error
  # @return [MissingAPIKeyError] a new instance of MissingAPIKeyError
  #
  # source://dspy//lib/dspy/lm/errors.rb#12
  def initialize(provider); end
end

# source://dspy//lib/dspy/lm/adapters/ollama_adapter.rb#7
class DSPy::LM::OllamaAdapter < ::DSPy::LM::OpenAIAdapter
  # @return [OllamaAdapter] a new instance of OllamaAdapter
  #
  # source://dspy//lib/dspy/lm/adapters/ollama_adapter.rb#10
  def initialize(model:, api_key: T.unsafe(nil), base_url: T.unsafe(nil), structured_outputs: T.unsafe(nil)); end

  # source://dspy//lib/dspy/lm/adapters/ollama_adapter.rb#32
  def chat(messages:, signature: T.unsafe(nil), response_format: T.unsafe(nil), &block); end

  private

  # Ollama may have different model support for structured outputs
  #
  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm/adapters/ollama_adapter.rb#66
  def supports_structured_outputs?; end

  # source://dspy//lib/dspy/lm/adapters/ollama_adapter.rb#56
  def validate_api_key!(api_key, provider); end

  # source://dspy//lib/dspy/lm/adapters/ollama_adapter.rb#51
  def validate_configuration!; end
end

# source://dspy//lib/dspy/lm/adapters/ollama_adapter.rb#8
DSPy::LM::OllamaAdapter::DEFAULT_BASE_URL = T.let(T.unsafe(nil), String)

# source://dspy//lib/dspy/lm/adapters/openai_adapter.rb#9
class DSPy::LM::OpenAIAdapter < ::DSPy::LM::Adapter
  # @return [OpenAIAdapter] a new instance of OpenAIAdapter
  #
  # source://dspy//lib/dspy/lm/adapters/openai_adapter.rb#10
  def initialize(model:, api_key:, structured_outputs: T.unsafe(nil)); end

  # source://dspy//lib/dspy/lm/adapters/openai_adapter.rb#17
  def chat(messages:, signature: T.unsafe(nil), response_format: T.unsafe(nil), &block); end

  private

  # source://dspy//lib/dspy/lm/adapters/openai_adapter.rb#117
  def format_multimodal_messages(messages); end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/lm/adapters/openai_adapter.rb#113
  def supports_structured_outputs?; end
end

# OpenAI-specific metadata with additional fields
#
# source://dspy//lib/dspy/lm/response.rb#32
class DSPy::LM::OpenAIResponseMetadata < ::T::Struct
  const :provider, ::String
  const :model, ::String
  const :response_id, T.nilable(::String), default: T.unsafe(nil)
  const :created, T.nilable(::Integer), default: T.unsafe(nil)
  const :structured_output, T.nilable(T::Boolean), default: T.unsafe(nil)
  const :system_fingerprint, T.nilable(::String), default: T.unsafe(nil)
  const :finish_reason, T.nilable(::String), default: T.unsafe(nil)

  # source://dspy//lib/dspy/lm/response.rb#44
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# OpenAI-specific usage information with additional fields
#
# source://dspy//lib/dspy/lm/usage.rb#26
class DSPy::LM::OpenAIUsage < ::T::Struct
  const :input_tokens, ::Integer
  const :output_tokens, ::Integer
  const :total_tokens, ::Integer
  const :prompt_tokens_details, T.nilable(T::Hash[::Symbol, ::Integer]), default: T.unsafe(nil)
  const :completion_tokens_details, T.nilable(T::Hash[::Symbol, ::Integer]), default: T.unsafe(nil)

  # source://dspy//lib/dspy/lm/usage.rb#36
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def to_h; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Normalized response format for all LM providers
#
# source://dspy//lib/dspy/lm/response.rb#88
class DSPy::LM::Response < ::T::Struct
  const :content, ::String
  const :usage, T.nilable(T.any(::DSPy::LM::OpenAIUsage, ::DSPy::LM::Usage)), default: T.unsafe(nil)
  const :metadata, T.any(::DSPy::LM::AnthropicResponseMetadata, ::DSPy::LM::OpenAIResponseMetadata, ::DSPy::LM::ResponseMetadata, T::Hash[::Symbol, T.untyped])

  # source://dspy//lib/dspy/lm/response.rb#101
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # source://dspy//lib/dspy/lm/response.rb#96
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Base metadata struct for common fields across providers
#
# source://dspy//lib/dspy/lm/response.rb#9
class DSPy::LM::ResponseMetadata < ::T::Struct
  const :provider, ::String
  const :model, ::String
  const :response_id, T.nilable(::String), default: T.unsafe(nil)
  const :created, T.nilable(::Integer), default: T.unsafe(nil)
  const :structured_output, T.nilable(T::Boolean), default: T.unsafe(nil)

  # source://dspy//lib/dspy/lm/response.rb#19
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Factory for creating response metadata objects
#
# source://dspy//lib/dspy/lm/response.rb#112
module DSPy::LM::ResponseMetadataFactory
  class << self
    # source://dspy//lib/dspy/lm/response.rb#116
    sig do
      params(
        provider: ::String,
        metadata: T.nilable(T::Hash[::Symbol, T.untyped])
      ).returns(T.any(::DSPy::LM::AnthropicResponseMetadata, ::DSPy::LM::OpenAIResponseMetadata, ::DSPy::LM::ResponseMetadata))
    end
    def create(provider, metadata); end
  end
end

# Handles retry logic with progressive fallback strategies
#
# source://dspy//lib/dspy/lm/retry_handler.rb#8
class DSPy::LM::RetryHandler
  # source://dspy//lib/dspy/lm/retry_handler.rb#15
  sig { params(adapter: ::DSPy::LM::Adapter, signature_class: T.class_of(DSPy::Signature)).void }
  def initialize(adapter, signature_class); end

  # Execute a block with retry logic and progressive fallback
  #
  # source://dspy//lib/dspy/lm/retry_handler.rb#30
  sig do
    type_parameters(:T)
      .params(
        initial_strategy: ::DSPy::LM::Strategies::BaseStrategy,
        block: T.proc.params(strategy: ::DSPy::LM::Strategies::BaseStrategy).returns(T.type_parameter(:T))
      ).returns(T.type_parameter(:T))
  end
  def with_retry(initial_strategy, &block); end

  private

  # Build a chain of strategies to try in order
  #
  # source://dspy//lib/dspy/lm/retry_handler.rb#83
  sig do
    params(
      initial_strategy: ::DSPy::LM::Strategies::BaseStrategy
    ).returns(T::Array[::DSPy::LM::Strategies::BaseStrategy])
  end
  def build_fallback_chain(initial_strategy); end

  # Calculate exponential backoff with jitter
  #
  # source://dspy//lib/dspy/lm/retry_handler.rb#109
  sig { params(attempt: ::Integer).returns(::Float) }
  def calculate_backoff(attempt); end

  # Different strategies get different retry counts
  #
  # source://dspy//lib/dspy/lm/retry_handler.rb#96
  sig { params(strategy: ::DSPy::LM::Strategies::BaseStrategy).returns(::Integer) }
  def max_retries_for_strategy(strategy); end
end

# seconds
#
# source://dspy//lib/dspy/lm/retry_handler.rb#12
DSPy::LM::RetryHandler::BACKOFF_BASE = T.let(T.unsafe(nil), Float)

# source://dspy//lib/dspy/lm/retry_handler.rb#11
DSPy::LM::RetryHandler::MAX_RETRIES = T.let(T.unsafe(nil), Integer)

# source://dspy//lib/dspy/lm/strategies/base_strategy.rb#7
module DSPy::LM::Strategies; end

# Strategy for using Anthropic's enhanced JSON extraction patterns
#
# source://dspy//lib/dspy/lm/strategies/anthropic_extraction_strategy.rb#9
class DSPy::LM::Strategies::AnthropicExtractionStrategy < ::DSPy::LM::Strategies::BaseStrategy
  # source://dspy//lib/dspy/lm/strategies/anthropic_extraction_strategy.rb#13
  sig { override.returns(T::Boolean) }
  def available?; end

  # source://dspy//lib/dspy/lm/strategies/anthropic_extraction_strategy.rb#34
  sig { override.params(response: ::DSPy::LM::Response).returns(T.nilable(::String)) }
  def extract_json(response); end

  # source://dspy//lib/dspy/lm/strategies/anthropic_extraction_strategy.rb#23
  sig { override.returns(::String) }
  def name; end

  # source://dspy//lib/dspy/lm/strategies/anthropic_extraction_strategy.rb#28
  sig do
    override
      .params(
        messages: T::Array[T::Hash[::Symbol, ::String]],
        request_params: T::Hash[::Symbol, T.untyped]
      ).void
  end
  def prepare_request(messages, request_params); end

  # source://dspy//lib/dspy/lm/strategies/anthropic_extraction_strategy.rb#18
  sig { override.returns(::Integer) }
  def priority; end

  private

  # source://dspy//lib/dspy/lm/strategies/anthropic_extraction_strategy.rb#47
  sig { params(content: T.nilable(::String)).returns(T.nilable(::String)) }
  def extract_json_fallback(content); end
end

# Strategy for using Anthropic's tool use feature for guaranteed JSON output
#
# source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#9
class DSPy::LM::Strategies::AnthropicToolUseStrategy < ::DSPy::LM::Strategies::BaseStrategy
  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#13
  sig { override.returns(T::Boolean) }
  def available?; end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#49
  sig { override.params(response: ::DSPy::LM::Response).returns(T.nilable(::String)) }
  def extract_json(response); end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#82
  sig { override.params(error: ::StandardError).returns(T::Boolean) }
  def handle_error(error); end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#24
  sig { override.returns(::String) }
  def name; end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#29
  sig do
    override
      .params(
        messages: T::Array[T::Hash[::Symbol, ::String]],
        request_params: T::Hash[::Symbol, T.untyped]
      ).void
  end
  def prepare_request(messages, request_params); end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#19
  sig { override.returns(::Integer) }
  def priority; end

  private

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#120
  sig { params(fields: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::String, T.untyped]) }
  def build_properties_from_fields(fields); end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#182
  sig { params(props: T.untyped).returns(T::Hash[::String, T.untyped]) }
  def build_properties_from_props(props); end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#103
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def convert_to_tool_schema; end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#131
  sig { params(type: T.untyped).returns(T::Hash[::String, T.untyped]) }
  def convert_type_to_json_schema(type); end

  # source://dspy//lib/dspy/lm/strategies/anthropic_tool_use_strategy.rb#95
  sig { returns(T::Boolean) }
  def supports_tool_use?; end
end

# Base class for JSON extraction strategies
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://dspy//lib/dspy/lm/strategies/base_strategy.rb#9
class DSPy::LM::Strategies::BaseStrategy
  abstract!

  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#15
  sig { params(adapter: ::DSPy::LM::Adapter, signature_class: T.class_of(DSPy::Signature)).void }
  def initialize(adapter, signature_class); end

  # Check if this strategy is available for the given adapter/model
  #
  # @abstract
  #
  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#22
  sig { abstract.returns(T::Boolean) }
  def available?; end

  # Extract JSON from the response
  #
  # @abstract
  #
  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#38
  sig { abstract.params(response: ::DSPy::LM::Response).returns(T.nilable(::String)) }
  def extract_json(response); end

  # Handle errors specific to this strategy
  #
  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#42
  sig { params(error: ::StandardError).returns(T::Boolean) }
  def handle_error(error); end

  # Name of the strategy for logging/debugging
  #
  # @abstract
  #
  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#30
  sig { abstract.returns(::String) }
  def name; end

  # Prepare the request for JSON extraction
  #
  # @abstract
  #
  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#34
  sig do
    abstract
      .params(
        messages: T::Array[T::Hash[::Symbol, ::String]],
        request_params: T::Hash[::Symbol, T.untyped]
      ).void
  end
  def prepare_request(messages, request_params); end

  # Priority for this strategy (higher = preferred)
  #
  # @abstract
  #
  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#26
  sig { abstract.returns(::Integer) }
  def priority; end

  protected

  # Returns the value of attribute adapter.
  #
  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#49
  def adapter; end

  # Returns the value of attribute signature_class.
  #
  # source://dspy//lib/dspy/lm/strategies/base_strategy.rb#49
  def signature_class; end
end

# Enhanced prompting strategy that works with any LLM
# Adds explicit JSON formatting instructions to improve reliability
#
# source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#10
class DSPy::LM::Strategies::EnhancedPromptingStrategy < ::DSPy::LM::Strategies::BaseStrategy
  # source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#14
  sig { override.returns(T::Boolean) }
  def available?; end

  # source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#56
  sig { override.params(response: ::DSPy::LM::Response).returns(T.nilable(::String)) }
  def extract_json(response); end

  # source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#25
  sig { override.returns(::String) }
  def name; end

  # source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#30
  sig do
    override
      .params(
        messages: T::Array[T::Hash[::Symbol, ::String]],
        request_params: T::Hash[::Symbol, T.untyped]
      ).void
  end
  def prepare_request(messages, request_params); end

  # source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#20
  sig { override.returns(::Integer) }
  def priority; end

  private

  # source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#90
  sig { params(prompt: ::String, schema: T::Hash[::Symbol, T.untyped]).returns(::String) }
  def enhance_prompt_with_json_instructions(prompt, schema); end

  # source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#112
  sig { params(schema: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::String, T.untyped]) }
  def generate_example_from_schema(schema); end

  # source://dspy//lib/dspy/lm/strategies/enhanced_prompting_strategy.rb#138
  sig { params(content: ::String).returns(T::Boolean) }
  def valid_json?(content); end
end

# Strategy for using OpenAI's native structured output feature
#
# source://dspy//lib/dspy/lm/strategies/openai_structured_output_strategy.rb#9
class DSPy::LM::Strategies::OpenAIStructuredOutputStrategy < ::DSPy::LM::Strategies::BaseStrategy
  # source://dspy//lib/dspy/lm/strategies/openai_structured_output_strategy.rb#13
  sig { override.returns(T::Boolean) }
  def available?; end

  # source://dspy//lib/dspy/lm/strategies/openai_structured_output_strategy.rb#44
  sig { override.params(response: ::DSPy::LM::Response).returns(T.nilable(::String)) }
  def extract_json(response); end

  # source://dspy//lib/dspy/lm/strategies/openai_structured_output_strategy.rb#51
  sig { override.params(error: ::StandardError).returns(T::Boolean) }
  def handle_error(error); end

  # source://dspy//lib/dspy/lm/strategies/openai_structured_output_strategy.rb#32
  sig { override.returns(::String) }
  def name; end

  # source://dspy//lib/dspy/lm/strategies/openai_structured_output_strategy.rb#37
  sig do
    override
      .params(
        messages: T::Array[T::Hash[::Symbol, ::String]],
        request_params: T::Hash[::Symbol, T.untyped]
      ).void
  end
  def prepare_request(messages, request_params); end

  # source://dspy//lib/dspy/lm/strategies/openai_structured_output_strategy.rb#27
  sig { override.returns(::Integer) }
  def priority; end
end

# Selects the best JSON extraction strategy based on the adapter and capabilities
#
# source://dspy//lib/dspy/lm/strategy_selector.rb#13
class DSPy::LM::StrategySelector
  # source://dspy//lib/dspy/lm/strategy_selector.rb#25
  sig { params(adapter: ::DSPy::LM::Adapter, signature_class: T.class_of(DSPy::Signature)).void }
  def initialize(adapter, signature_class); end

  # Get all available strategies
  #
  # source://dspy//lib/dspy/lm/strategy_selector.rb#63
  sig { returns(T::Array[::DSPy::LM::Strategies::BaseStrategy]) }
  def available_strategies; end

  # Select the best available strategy
  #
  # source://dspy//lib/dspy/lm/strategy_selector.rb#33
  sig { returns(::DSPy::LM::Strategies::BaseStrategy) }
  def select; end

  # Check if a specific strategy is available
  #
  # source://dspy//lib/dspy/lm/strategy_selector.rb#69
  sig { params(strategy_name: ::String).returns(T::Boolean) }
  def strategy_available?(strategy_name); end

  private

  # source://dspy//lib/dspy/lm/strategy_selector.rb#117
  sig { returns(T::Array[::DSPy::LM::Strategies::BaseStrategy]) }
  def build_strategies; end

  # source://dspy//lib/dspy/lm/strategy_selector.rb#122
  sig { params(name: ::String).returns(T.nilable(::DSPy::LM::Strategies::BaseStrategy)) }
  def find_strategy_by_name(name); end

  # Check if preference is for strict (provider-optimized) strategies
  #
  # source://dspy//lib/dspy/lm/strategy_selector.rb#93
  sig { params(preference: ::DSPy::Strategy).returns(T::Boolean) }
  def is_strict_preference?(preference); end

  # Select the best provider-optimized strategy for the current adapter
  #
  # source://dspy//lib/dspy/lm/strategy_selector.rb#99
  sig { returns(T.nilable(::DSPy::LM::Strategies::BaseStrategy)) }
  def select_provider_optimized_strategy; end

  # Select internal strategy based on user preference
  #
  # source://dspy//lib/dspy/lm/strategy_selector.rb#78
  sig { params(preference: ::DSPy::Strategy).returns(T.nilable(::DSPy::LM::Strategies::BaseStrategy)) }
  def select_strategy_from_preference(preference); end
end

# Available strategies in order of registration
#
# source://dspy//lib/dspy/lm/strategy_selector.rb#17
DSPy::LM::StrategySelector::STRATEGIES = T.let(T.unsafe(nil), Array)

# source://dspy//lib/dspy/lm/errors.rb#7
class DSPy::LM::UnsupportedProviderError < ::DSPy::LM::Error; end

# Base class for token usage information
#
# source://dspy//lib/dspy/lm/usage.rb#8
class DSPy::LM::Usage < ::T::Struct
  const :input_tokens, ::Integer
  const :output_tokens, ::Integer
  const :total_tokens, ::Integer

  # source://dspy//lib/dspy/lm/usage.rb#16
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def to_h; end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Factory for creating appropriate usage objects
#
# source://dspy//lib/dspy/lm/usage.rb#49
module DSPy::LM::UsageFactory
  class << self
    # source://dspy//lib/dspy/lm/usage.rb#106
    sig { params(value: T.untyped).returns(T.nilable(T::Hash[::Symbol, ::Integer])) }
    def convert_to_hash(value); end

    # source://dspy//lib/dspy/lm/usage.rb#53
    sig do
      params(
        provider: ::String,
        usage_data: T.untyped
      ).returns(T.nilable(T.any(::DSPy::LM::OpenAIUsage, ::DSPy::LM::Usage)))
    end
    def create(provider, usage_data); end

    # source://dspy//lib/dspy/lm/usage.rb#123
    sig { params(data: T::Hash[::Symbol, T.untyped]).returns(T.nilable(::DSPy::LM::Usage)) }
    def create_anthropic_usage(data); end

    # source://dspy//lib/dspy/lm/usage.rb#140
    sig { params(data: T::Hash[::Symbol, T.untyped]).returns(T.nilable(::DSPy::LM::Usage)) }
    def create_generic_usage(data); end

    # source://dspy//lib/dspy/lm/usage.rb#83
    sig { params(data: T::Hash[::Symbol, T.untyped]).returns(T.nilable(::DSPy::LM::OpenAIUsage)) }
    def create_openai_usage(data); end
  end
end

# source://dspy//lib/dspy/lm/vision_models.rb#5
module DSPy::LM::VisionModels
  class << self
    # @return [Boolean]
    #
    # source://dspy//lib/dspy/lm/vision_models.rb#29
    def supports_vision?(provider, model); end

    # source://dspy//lib/dspy/lm/vision_models.rb#40
    def validate_vision_support!(provider, model); end

    # source://dspy//lib/dspy/lm/vision_models.rb#46
    def vision_models_for(provider); end
  end
end

# Anthropic vision-capable models
#
# source://dspy//lib/dspy/lm/vision_models.rb#20
DSPy::LM::VisionModels::ANTHROPIC_VISION_MODELS = T.let(T.unsafe(nil), Array)

# OpenAI vision-capable models
#
# source://dspy//lib/dspy/lm/vision_models.rb#7
DSPy::LM::VisionModels::OPENAI_VISION_MODELS = T.let(T.unsafe(nil), Array)

# Memory system for persistent, searchable agent memory
#
# source://dspy//lib/dspy/memory/memory_record.rb#7
module DSPy::Memory
  class << self
    # Configure the memory system
    #
    # source://dspy//lib/dspy/memory.rb#19
    sig { returns(::DSPy::Memory::MemoryManager) }
    def manager; end

    # Reset the memory system (useful for testing)
    #
    # source://dspy//lib/dspy/memory.rb#25
    sig { void }
    def reset!; end
  end
end

# Abstract base class for embedding engines
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://dspy//lib/dspy/memory/embedding_engine.rb#8
class DSPy::Memory::EmbeddingEngine
  abstract!

  # Calculate cosine similarity between two vectors
  #
  # source://dspy//lib/dspy/memory/embedding_engine.rb#55
  sig { params(a: T::Array[::Float], b: T::Array[::Float]).returns(::Float) }
  def cosine_similarity(a, b); end

  # Generate embeddings for a single text
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/embedding_engine.rb#15
  sig { abstract.params(text: ::String).returns(T::Array[::Float]) }
  def embed(text); end

  # Generate embeddings for multiple texts (batch processing)
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/embedding_engine.rb#19
  sig { abstract.params(texts: T::Array[::String]).returns(T::Array[T::Array[::Float]]) }
  def embed_batch(texts); end

  # Get the dimension of embeddings produced by this engine
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/embedding_engine.rb#23
  sig { abstract.returns(::Integer) }
  def embedding_dimension; end

  # Get the model name/identifier
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/embedding_engine.rb#27
  sig { abstract.returns(::String) }
  def model_name; end

  # Normalize a vector to unit length
  #
  # source://dspy//lib/dspy/memory/embedding_engine.rb#47
  sig { params(vector: T::Array[::Float]).returns(T::Array[::Float]) }
  def normalize_vector(vector); end

  # Check if the engine is ready to use
  #
  # source://dspy//lib/dspy/memory/embedding_engine.rb#31
  sig { returns(T::Boolean) }
  def ready?; end

  # Get engine statistics
  #
  # source://dspy//lib/dspy/memory/embedding_engine.rb#37
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def stats; end
end

# In-memory implementation of MemoryStore for development and testing
#
# source://dspy//lib/dspy/memory/in_memory_store.rb#9
class DSPy::Memory::InMemoryStore < ::DSPy::Memory::MemoryStore
  # source://dspy//lib/dspy/memory/in_memory_store.rb#13
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#163
  sig { override.params(user_id: T.nilable(::String)).returns(::Integer) }
  def clear(user_id: T.unsafe(nil)); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#152
  sig { override.params(user_id: T.nilable(::String)).returns(::Integer) }
  def count(user_id: T.unsafe(nil)); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#48
  sig { override.params(id: ::String).returns(T::Boolean) }
  def delete(id); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#55
  sig do
    override
      .params(
        user_id: T.nilable(::String),
        limit: T.nilable(::Integer),
        offset: T.nilable(::Integer)
      ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def list(user_id: T.unsafe(nil), limit: T.unsafe(nil), offset: T.unsafe(nil)); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#27
  sig { override.params(id: ::String).returns(T.nilable(::DSPy::Memory::MemoryRecord)) }
  def retrieve(id); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#74
  sig do
    override
      .params(
        query: ::String,
        user_id: T.nilable(::String),
        limit: T.nilable(::Integer)
      ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def search(query, user_id: T.unsafe(nil), limit: T.unsafe(nil)); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#98
  sig do
    override
      .params(
        tags: T::Array[::String],
        user_id: T.nilable(::String),
        limit: T.nilable(::Integer)
      ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def search_by_tags(tags, user_id: T.unsafe(nil), limit: T.unsafe(nil)); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#183
  sig { override.returns(T::Hash[::Symbol, T.untyped]) }
  def stats; end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#19
  sig { override.params(record: ::DSPy::Memory::MemoryRecord).returns(T::Boolean) }
  def store(record); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#178
  sig { override.returns(T::Boolean) }
  def supports_vector_search?; end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#36
  sig { override.params(record: ::DSPy::Memory::MemoryRecord).returns(T::Boolean) }
  def update(record); end

  # source://dspy//lib/dspy/memory/in_memory_store.rb#120
  sig do
    override
      .params(
        embedding: T::Array[::Float],
        user_id: T.nilable(::String),
        limit: T.nilable(::Integer),
        threshold: T.nilable(::Float)
      ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def vector_search(embedding, user_id: T.unsafe(nil), limit: T.unsafe(nil), threshold: T.unsafe(nil)); end

  private

  # Calculate cosine similarity between two vectors
  #
  # source://dspy//lib/dspy/memory/in_memory_store.rb#203
  sig { params(a: T::Array[::Float], b: T::Array[::Float]).returns(::Float) }
  def cosine_similarity(a, b); end
end

# Local embedding engine using ankane/informers for privacy-preserving embeddings
#
# source://dspy//lib/dspy/memory/local_embedding_engine.rb#12
class DSPy::Memory::LocalEmbeddingEngine < ::DSPy::Memory::EmbeddingEngine
  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#28
  sig { params(model_name: ::String).void }
  def initialize(model_name = T.unsafe(nil)); end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#38
  sig { override.params(text: ::String).returns(T::Array[::Float]) }
  def embed(text); end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#53
  sig { override.params(texts: T::Array[::String]).returns(T::Array[T::Array[::Float]]) }
  def embed_batch(texts); end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#76
  sig { override.returns(::Integer) }
  def embedding_dimension; end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#81
  sig { override.returns(::String) }
  def model_name; end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#86
  sig { override.returns(T::Boolean) }
  def ready?; end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#91
  sig { override.returns(T::Hash[::Symbol, T.untyped]) }
  def stats; end

  private

  # Ensure the model is ready
  #
  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#140
  sig { void }
  def ensure_ready!; end

  # Load the embedding model
  #
  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#117
  sig { void }
  def load_model!; end

  # Load model information (dimension, etc.)
  #
  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#130
  sig { returns(::Integer) }
  def load_model_info!; end

  # Preprocess text for better embeddings
  #
  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#148
  sig { params(text: ::String).returns(::String) }
  def preprocess_text(text); end

  class << self
    # Check if a model is supported
    #
    # source://dspy//lib/dspy/memory/local_embedding_engine.rb#103
    sig { params(model_name: ::String).returns(T::Boolean) }
    def model_supported?(model_name); end

    # List all supported models
    #
    # source://dspy//lib/dspy/memory/local_embedding_engine.rb#109
    sig { returns(T::Array[::String]) }
    def supported_models; end
  end
end

# Default models supported by informers
#
# source://dspy//lib/dspy/memory/local_embedding_engine.rb#16
DSPy::Memory::LocalEmbeddingEngine::DEFAULT_MODEL = T.let(T.unsafe(nil), String)

# source://dspy//lib/dspy/memory/local_embedding_engine.rb#17
DSPy::Memory::LocalEmbeddingEngine::SUPPORTED_MODELS = T.let(T.unsafe(nil), Array)

# Simple memory compaction system with inline triggers
# Handles deduplication, relevance pruning, and conflict resolution
#
# source://dspy//lib/dspy/memory/memory_compactor.rb#9
class DSPy::Memory::MemoryCompactor
  # source://dspy//lib/dspy/memory/memory_compactor.rb#38
  sig do
    params(
      max_memories: ::Integer,
      max_age_days: ::Integer,
      similarity_threshold: ::Float,
      low_access_threshold: ::Float
    ).void
  end
  def initialize(max_memories: T.unsafe(nil), max_age_days: T.unsafe(nil), similarity_threshold: T.unsafe(nil), low_access_threshold: T.unsafe(nil)); end

  # Check if age-based compaction is needed
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#86
  sig { params(store: ::DSPy::Memory::MemoryStore, user_id: T.nilable(::String)).returns(T::Boolean) }
  def age_compaction_needed?(store, user_id); end

  # Main compaction entry point - checks all triggers and compacts if needed
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#52
  sig do
    params(
      store: ::DSPy::Memory::MemoryStore,
      embedding_engine: ::DSPy::Memory::EmbeddingEngine,
      user_id: T.nilable(::String)
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def compact_if_needed!(store, embedding_engine, user_id: T.unsafe(nil)); end

  # Check if deduplication is needed (simple heuristic)
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#96
  sig do
    params(
      store: ::DSPy::Memory::MemoryStore,
      embedding_engine: ::DSPy::Memory::EmbeddingEngine,
      user_id: T.nilable(::String)
    ).returns(T::Boolean)
  end
  def duplication_compaction_needed?(store, embedding_engine, user_id); end

  # source://dspy//lib/dspy/memory/memory_compactor.rb#28
  sig { returns(::Float) }
  def low_access_threshold; end

  # source://dspy//lib/dspy/memory/memory_compactor.rb#22
  sig { returns(::Integer) }
  def max_age_days; end

  # source://dspy//lib/dspy/memory/memory_compactor.rb#19
  sig { returns(::Integer) }
  def max_memories; end

  # Check if relevance-based pruning is needed
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#121
  sig { params(store: ::DSPy::Memory::MemoryStore, user_id: T.nilable(::String)).returns(T::Boolean) }
  def relevance_compaction_needed?(store, user_id); end

  # source://dspy//lib/dspy/memory/memory_compactor.rb#25
  sig { returns(::Float) }
  def similarity_threshold; end

  # Check if size-based compaction is needed
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#80
  sig { params(store: ::DSPy::Memory::MemoryStore, user_id: T.nilable(::String)).returns(T::Boolean) }
  def size_compaction_needed?(store, user_id); end

  private

  # Remove memories older than age limit
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#183
  sig do
    params(
      store: ::DSPy::Memory::MemoryStore,
      user_id: T.nilable(::String)
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def perform_age_compaction!(store, user_id); end

  # Remove near-duplicate memories using embedding similarity
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#207
  sig do
    params(
      store: ::DSPy::Memory::MemoryStore,
      embedding_engine: ::DSPy::Memory::EmbeddingEngine,
      user_id: T.nilable(::String)
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def perform_deduplication!(store, embedding_engine, user_id); end

  # Remove memories with low relevance (low access patterns)
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#260
  sig do
    params(
      store: ::DSPy::Memory::MemoryStore,
      user_id: T.nilable(::String)
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def perform_relevance_pruning!(store, user_id); end

  # Remove oldest memories when over size limit
  #
  # source://dspy//lib/dspy/memory/memory_compactor.rb#144
  sig do
    params(
      store: ::DSPy::Memory::MemoryStore,
      user_id: T.nilable(::String)
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def perform_size_compaction!(store, user_id); end
end

# source://dspy//lib/dspy/memory/memory_compactor.rb#16
DSPy::Memory::MemoryCompactor::DEFAULT_LOW_ACCESS_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://dspy//lib/dspy/memory/memory_compactor.rb#14
DSPy::Memory::MemoryCompactor::DEFAULT_MAX_AGE_DAYS = T.let(T.unsafe(nil), Integer)

# Compaction thresholds
#
# source://dspy//lib/dspy/memory/memory_compactor.rb#13
DSPy::Memory::MemoryCompactor::DEFAULT_MAX_MEMORIES = T.let(T.unsafe(nil), Integer)

# source://dspy//lib/dspy/memory/memory_compactor.rb#15
DSPy::Memory::MemoryCompactor::DEFAULT_SIMILARITY_THRESHOLD = T.let(T.unsafe(nil), Float)

# High-level memory management interface implementing MemoryTools API
#
# source://dspy//lib/dspy/memory/memory_manager.rb#14
class DSPy::Memory::MemoryManager
  # source://dspy//lib/dspy/memory/memory_manager.rb#27
  sig do
    params(
      store: T.nilable(::DSPy::Memory::MemoryStore),
      embedding_engine: T.nilable(::DSPy::Memory::EmbeddingEngine),
      compactor: T.nilable(::DSPy::Memory::MemoryCompactor)
    ).void
  end
  def initialize(store: T.unsafe(nil), embedding_engine: T.unsafe(nil), compactor: T.unsafe(nil)); end

  # Clear all memories for a user
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#130
  sig { params(user_id: T.nilable(::String)).returns(::Integer) }
  def clear_memories(user_id: T.unsafe(nil)); end

  # Trigger memory compaction if needed
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#212
  sig { params(user_id: T.nilable(::String)).returns(T::Hash[::Symbol, T.untyped]) }
  def compact_if_needed!(user_id = T.unsafe(nil)); end

  # source://dspy//lib/dspy/memory/memory_manager.rb#24
  sig { returns(::DSPy::Memory::MemoryCompactor) }
  def compactor; end

  # Count memories
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#124
  sig { params(user_id: T.nilable(::String)).returns(::Integer) }
  def count_memories(user_id: T.unsafe(nil)); end

  # Delete a memory
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#85
  sig { params(memory_id: ::String).returns(T::Boolean) }
  def delete_memory(memory_id); end

  # source://dspy//lib/dspy/memory/memory_manager.rb#21
  sig { returns(::DSPy::Memory::EmbeddingEngine) }
  def embedding_engine; end

  # Export memories to hash format
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#192
  sig { params(user_id: T.nilable(::String)).returns(T::Array[T::Hash[::String, T.untyped]]) }
  def export_memories(user_id: T.unsafe(nil)); end

  # Find similar memories to a given memory
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#136
  sig do
    params(
      memory_id: ::String,
      limit: T.nilable(::Integer),
      threshold: T.nilable(::Float)
    ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def find_similar(memory_id, limit: T.unsafe(nil), threshold: T.unsafe(nil)); end

  # Force memory compaction (useful for testing or manual cleanup)
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#218
  sig { params(user_id: T.nilable(::String)).returns(T::Hash[::Symbol, T.untyped]) }
  def force_compact!(user_id = T.unsafe(nil)); end

  # Get all memories for a user
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#91
  sig do
    params(
      user_id: T.nilable(::String),
      limit: T.nilable(::Integer),
      offset: T.nilable(::Integer)
    ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def get_all_memories(user_id: T.unsafe(nil), limit: T.unsafe(nil), offset: T.unsafe(nil)); end

  # Retrieve a memory by ID
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#60
  sig { params(memory_id: ::String).returns(T.nilable(::DSPy::Memory::MemoryRecord)) }
  def get_memory(memory_id); end

  # Health check
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#186
  sig { returns(T::Boolean) }
  def healthy?; end

  # Import memories from hash format
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#199
  sig { params(memories_data: T::Array[T::Hash[::String, T.untyped]]).returns(::Integer) }
  def import_memories(memories_data); end

  # Search by tags
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#112
  sig do
    params(
      tags: T::Array[::String],
      user_id: T.nilable(::String),
      limit: T.nilable(::Integer)
    ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def search_by_tags(tags, user_id: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Semantic search using embeddings
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#97
  sig do
    params(
      query: ::String,
      user_id: T.nilable(::String),
      limit: T.nilable(::Integer),
      threshold: T.nilable(::Float)
    ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def search_memories(query, user_id: T.unsafe(nil), limit: T.unsafe(nil), threshold: T.unsafe(nil)); end

  # Text-based search (fallback when embeddings not available)
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#118
  sig do
    params(
      query: ::String,
      user_id: T.nilable(::String),
      limit: T.nilable(::Integer)
    ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def search_text(query, user_id: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Get memory statistics
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#173
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def stats; end

  # source://dspy//lib/dspy/memory/memory_manager.rb#18
  sig { returns(::DSPy::Memory::MemoryStore) }
  def store; end

  # Batch operations
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#148
  sig do
    params(
      contents: T::Array[::String],
      user_id: T.nilable(::String),
      tags: T::Array[::String]
    ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def store_memories_batch(contents, user_id: T.unsafe(nil), tags: T.unsafe(nil)); end

  # Store a memory with automatic embedding generation
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#35
  sig do
    params(
      content: ::String,
      user_id: T.nilable(::String),
      tags: T::Array[::String],
      metadata: T::Hash[::String, T.untyped]
    ).returns(::DSPy::Memory::MemoryRecord)
  end
  def store_memory(content, user_id: T.unsafe(nil), tags: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # Update an existing memory
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#66
  sig do
    params(
      memory_id: ::String,
      new_content: ::String,
      tags: T.nilable(T::Array[::String]),
      metadata: T.nilable(T::Hash[::String, T.untyped])
    ).returns(T::Boolean)
  end
  def update_memory(memory_id, new_content, tags: T.unsafe(nil), metadata: T.unsafe(nil)); end

  private

  # Create default embedding engine
  #
  # source://dspy//lib/dspy/memory/memory_manager.rb#241
  sig { returns(::DSPy::Memory::EmbeddingEngine) }
  def create_default_embedding_engine; end
end

# Represents a single memory entry with metadata and embeddings
#
# source://dspy//lib/dspy/memory/memory_record.rb#9
class DSPy::Memory::MemoryRecord
  # source://dspy//lib/dspy/memory/memory_record.rb#52
  sig do
    params(
      content: ::String,
      user_id: T.nilable(::String),
      tags: T::Array[::String],
      embedding: T.nilable(T::Array[::Float]),
      id: T.nilable(::String),
      metadata: T::Hash[::String, T.untyped]
    ).void
  end
  def initialize(content:, user_id: T.unsafe(nil), tags: T.unsafe(nil), embedding: T.unsafe(nil), id: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # source://dspy//lib/dspy/memory/memory_record.rb#34
  sig { returns(::Integer) }
  def access_count; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#34
  def access_count=(_arg0); end

  # Check if memory has been accessed recently (within last N seconds)
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#93
  sig { params(seconds: ::Integer).returns(T::Boolean) }
  def accessed_recently?(seconds = T.unsafe(nil)); end

  # Add a tag if not already present
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#106
  sig { params(tag: ::String).void }
  def add_tag(tag); end

  # Calculate age in days
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#87
  sig { returns(::Float) }
  def age_in_days; end

  # Calculate age in seconds
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#81
  sig { returns(::Float) }
  def age_in_seconds; end

  # source://dspy//lib/dspy/memory/memory_record.rb#16
  sig { returns(::String) }
  def content; end

  # @return [String]
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#16
  def content=(_arg0); end

  # source://dspy//lib/dspy/memory/memory_record.rb#28
  sig { returns(::Time) }
  def created_at; end

  # source://dspy//lib/dspy/memory/memory_record.rb#25
  sig { returns(T.nilable(T::Array[::Float])) }
  def embedding; end

  # @return [Array<Float>, nil]
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#25
  def embedding=(_arg0); end

  # Check if memory matches a tag
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#100
  sig { params(tag: ::String).returns(T::Boolean) }
  def has_tag?(tag); end

  # source://dspy//lib/dspy/memory/memory_record.rb#13
  sig { returns(::String) }
  def id; end

  # source://dspy//lib/dspy/memory/memory_record.rb#158
  sig { returns(::String) }
  def inspect; end

  # source://dspy//lib/dspy/memory/memory_record.rb#37
  sig { returns(T.nilable(::Time)) }
  def last_accessed_at; end

  # @return [Time, nil]
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#37
  def last_accessed_at=(_arg0); end

  # source://dspy//lib/dspy/memory/memory_record.rb#40
  sig { returns(T::Hash[::String, T.untyped]) }
  def metadata; end

  # @return [Hash{String => T.untyped}]
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#40
  def metadata=(_arg0); end

  # Record an access to this memory
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#67
  sig { void }
  def record_access!; end

  # Remove a tag
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#112
  sig { params(tag: ::String).void }
  def remove_tag(tag); end

  # source://dspy//lib/dspy/memory/memory_record.rb#22
  sig { returns(T::Array[::String]) }
  def tags; end

  # @return [Array<String>]
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#22
  def tags=(_arg0); end

  # Convert to hash for serialization
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#118
  sig { returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # String representation
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#153
  sig { returns(::String) }
  def to_s; end

  # Update the content and timestamp
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#74
  sig { params(new_content: ::String).void }
  def update_content!(new_content); end

  # source://dspy//lib/dspy/memory/memory_record.rb#31
  sig { returns(::Time) }
  def updated_at; end

  # @return [Time]
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#31
  def updated_at=(_arg0); end

  # source://dspy//lib/dspy/memory/memory_record.rb#19
  sig { returns(T.nilable(::String)) }
  def user_id; end

  # @return [String, nil]
  #
  # source://dspy//lib/dspy/memory/memory_record.rb#19
  def user_id=(_arg0); end

  class << self
    # Create from hash (for deserialization)
    #
    # source://dspy//lib/dspy/memory/memory_record.rb#135
    sig { params(hash: T::Hash[::String, T.untyped]).returns(::DSPy::Memory::MemoryRecord) }
    def from_h(hash); end
  end
end

# Abstract base class for memory storage backends
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://dspy//lib/dspy/memory/memory_store.rb#8
class DSPy::Memory::MemoryStore
  abstract!

  # Clear all memories for a user (or all if user_id is nil)
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#51
  sig { abstract.params(user_id: T.nilable(::String)).returns(::Integer) }
  def clear(user_id: T.unsafe(nil)); end

  # Count total memories
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#47
  sig { abstract.params(user_id: T.nilable(::String)).returns(::Integer) }
  def count(user_id: T.unsafe(nil)); end

  # Delete a memory record by ID
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#27
  sig { abstract.params(id: ::String).returns(T::Boolean) }
  def delete(id); end

  # source://dspy//lib/dspy/memory/memory_store.rb#85
  sig { params(ids: T::Array[::String]).returns(T::Array[T::Boolean]) }
  def delete_batch(ids); end

  # List all memory records for a user
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#31
  sig do
    abstract
      .params(
        user_id: T.nilable(::String),
        limit: T.nilable(::Integer),
        offset: T.nilable(::Integer)
      ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def list(user_id: T.unsafe(nil), limit: T.unsafe(nil), offset: T.unsafe(nil)); end

  # Retrieve a memory record by ID
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#19
  sig { abstract.params(id: ::String).returns(T.nilable(::DSPy::Memory::MemoryRecord)) }
  def retrieve(id); end

  # source://dspy//lib/dspy/memory/memory_store.rb#75
  sig { params(ids: T::Array[::String]).returns(T::Array[T.nilable(::DSPy::Memory::MemoryRecord)]) }
  def retrieve_batch(ids); end

  # Search memories by content (basic text search)
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#35
  sig do
    abstract
      .params(
        query: ::String,
        user_id: T.nilable(::String),
        limit: T.nilable(::Integer)
      ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def search(query, user_id: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Search memories by tags
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#39
  sig do
    abstract
      .params(
        tags: T::Array[::String],
        user_id: T.nilable(::String),
        limit: T.nilable(::Integer)
      ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def search_by_tags(tags, user_id: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Get store statistics
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#61
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def stats; end

  # Store a memory record
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#15
  sig { abstract.params(record: ::DSPy::Memory::MemoryRecord).returns(T::Boolean) }
  def store(record); end

  # Batch operations
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#70
  sig { params(records: T::Array[::DSPy::Memory::MemoryRecord]).returns(T::Array[T::Boolean]) }
  def store_batch(records); end

  # Check if the store supports vector search
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#55
  sig { returns(T::Boolean) }
  def supports_vector_search?; end

  # Update an existing memory record
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#23
  sig { abstract.params(record: ::DSPy::Memory::MemoryRecord).returns(T::Boolean) }
  def update(record); end

  # source://dspy//lib/dspy/memory/memory_store.rb#80
  sig { params(records: T::Array[::DSPy::Memory::MemoryRecord]).returns(T::Array[T::Boolean]) }
  def update_batch(records); end

  # Vector similarity search (if supported by backend)
  #
  # @abstract
  #
  # source://dspy//lib/dspy/memory/memory_store.rb#43
  sig do
    abstract
      .params(
        embedding: T::Array[::Float],
        user_id: T.nilable(::String),
        limit: T.nilable(::Integer),
        threshold: T.nilable(::Float)
      ).returns(T::Array[::DSPy::Memory::MemoryRecord])
  end
  def vector_search(embedding, user_id: T.unsafe(nil), limit: T.unsafe(nil), threshold: T.unsafe(nil)); end
end

# Fallback embedding engine when informers is not available
#
# source://dspy//lib/dspy/memory/local_embedding_engine.rb#165
class DSPy::Memory::NoOpEmbeddingEngine < ::DSPy::Memory::EmbeddingEngine
  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#169
  sig { override.params(text: ::String).returns(T::Array[::Float]) }
  def embed(text); end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#175
  sig { override.params(texts: T::Array[::String]).returns(T::Array[T::Array[::Float]]) }
  def embed_batch(texts); end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#180
  sig { override.returns(::Integer) }
  def embedding_dimension; end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#185
  sig { override.returns(::String) }
  def model_name; end

  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#190
  sig { override.returns(T::Boolean) }
  def ready?; end

  private

  # Generate a simple hash-based embedding that captures semantic similarity
  #
  # source://dspy//lib/dspy/memory/local_embedding_engine.rb#198
  sig { params(text: ::String).returns(T::Array[::Float]) }
  def simple_hash_embedding(text); end
end

# Common metric functions for evaluation
#
# source://dspy//lib/dspy/evaluate.rb#435
module DSPy::Metrics
  class << self
    # Composite metric - combines multiple metrics with AND logic
    #
    # source://dspy//lib/dspy/evaluate.rb#516
    def composite_and(*metrics); end

    # Contains metric - checks if prediction contains expected substring
    #
    # source://dspy//lib/dspy/evaluate.rb#467
    sig do
      params(
        field: ::Symbol,
        case_sensitive: T::Boolean
      ).returns(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
    end
    def contains(field: T.unsafe(nil), case_sensitive: T.unsafe(nil)); end

    # Exact match metric - checks if prediction exactly matches expected output
    #
    # source://dspy//lib/dspy/evaluate.rb#445
    sig do
      params(
        field: ::Symbol,
        case_sensitive: T::Boolean
      ).returns(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
    end
    def exact_match(field: T.unsafe(nil), case_sensitive: T.unsafe(nil)); end

    # Extract field value from example or prediction
    #
    # source://dspy//lib/dspy/evaluate.rb#543
    sig { params(obj: T.untyped, field: ::Symbol).returns(T.untyped) }
    def extract_field(obj, field); end

    # Numeric difference metric - checks if prediction is within tolerance of expected value
    #
    # source://dspy//lib/dspy/evaluate.rb#489
    sig do
      params(
        field: ::Symbol,
        tolerance: ::Float
      ).returns(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Hash[::Symbol, T.untyped]))
    end
    def numeric_difference(field: T.unsafe(nil), tolerance: T.unsafe(nil)); end
  end
end

# source://dspy//lib/dspy/mixins/struct_builder.rb#7
module DSPy::Mixins; end

# Shared module for building enhanced structs with input/output properties
#
# source://dspy//lib/dspy/mixins/struct_builder.rb#9
module DSPy::Mixins::StructBuilder
  private

  # Builds a new struct class with properties from multiple sources
  #
  # source://dspy//lib/dspy/mixins/struct_builder.rb#16
  sig do
    params(
      property_sources: T::Hash[::Symbol, T::Hash[::Symbol, T.untyped]],
      additional_fields: T::Hash[::Symbol, T.untyped]
    ).returns(T.class_of(T::Struct))
  end
  def build_enhanced_struct(property_sources, additional_fields = T.unsafe(nil)); end

  # Builds properties from a props hash (from T::Struct.props)
  #
  # source://dspy//lib/dspy/mixins/struct_builder.rb#59
  sig { params(props: T::Hash[::Symbol, T.untyped]).void }
  def build_properties_from_hash(props); end

  # Builds a single property with type and options
  #
  # source://dspy//lib/dspy/mixins/struct_builder.rb#65
  sig { params(name: ::Symbol, prop: T.untyped).void }
  def build_single_property(name, prop); end

  # Extracts options from property configuration
  #
  # source://dspy//lib/dspy/mixins/struct_builder.rb#94
  sig { params(prop: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def extract_options_from_prop(prop); end

  # Extracts type from property configuration
  #
  # source://dspy//lib/dspy/mixins/struct_builder.rb#80
  sig { params(prop: T.untyped).returns(T.untyped) }
  def extract_type_from_prop(prop); end
end

# Module for adding serialization capabilities to enhanced structs
#
# source://dspy//lib/dspy/mixins/struct_builder.rb#105
module DSPy::Mixins::StructSerialization
  # source://dspy//lib/dspy/mixins/struct_builder.rb#109
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  private

  # source://dspy//lib/dspy/mixins/struct_builder.rb#117
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def input_values_hash; end

  # source://dspy//lib/dspy/mixins/struct_builder.rb#126
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def output_properties_hash; end
end

# Shared module for type coercion logic across DSPy modules
#
# source://dspy//lib/dspy/mixins/type_coercion.rb#9
module DSPy::Mixins::TypeCoercion
  private

  # Checks if a type is an array type
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#86
  sig { params(type: T.untyped).returns(T::Boolean) }
  def array_type?(type); end

  # Coerces an array value, converting each element as needed
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#119
  sig { params(value: T.untyped, prop_type: T.untyped).returns(T.untyped) }
  def coerce_array_value(value, prop_type); end

  # Coerces output attributes to match their expected types
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#16
  sig do
    params(
      output_attributes: T::Hash[::Symbol, T.untyped],
      output_props: T::Hash[::Symbol, T.untyped]
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def coerce_output_attributes(output_attributes, output_props); end

  # Coerces a struct value from a hash
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#129
  sig { params(value: T.untyped, prop_type: T.untyped).returns(T.untyped) }
  def coerce_struct_value(value, prop_type); end

  # Coerces a union value by using _type discriminator
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#153
  sig { params(value: T.untyped, union_type: T.untyped).returns(T.untyped) }
  def coerce_union_value(value, union_type); end

  # Coerces a single value to match its expected type
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#26
  sig { params(value: T.untyped, prop_type: T.untyped).returns(T.untyped) }
  def coerce_value_to_type(value, prop_type); end

  # Checks if a type is an enum type
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#52
  sig { params(type: T.untyped).returns(T::Boolean) }
  def enum_type?(type); end

  # Extracts the enum class from a type
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#68
  sig { params(prop_type: T.untyped).returns(T.class_of(T::Enum)) }
  def extract_enum_class(prop_type); end

  # Checks if a type is nilable (contains NilClass)
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#113
  sig { params(type: T.untyped).returns(T::Boolean) }
  def is_nilable_type?(type); end

  # Checks if a type matches a simple type (like Float, Integer)
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#80
  sig { params(type: T.untyped, target_type: T.untyped).returns(T::Boolean) }
  def simple_type_match?(type, target_type); end

  # Checks if a type is a struct type
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#93
  sig { params(type: T.untyped).returns(T::Boolean) }
  def struct_type?(type); end

  # Checks if a type is a union type (T.any)
  #
  # source://dspy//lib/dspy/mixins/type_coercion.rb#107
  sig { params(type: T.untyped).returns(T::Boolean) }
  def union_type?(type); end
end

# source://dspy//lib/dspy/module.rb#7
class DSPy::Module
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # The main call method that users will call is generic and type parameterized
  #
  # source://dspy//lib/dspy/module.rb#42
  sig { type_parameters(:I).params(input_values: T.type_parameter(:I)).returns(T.type_parameter(:O)) }
  def call(**input_values); end

  # The implementation method for call
  #
  # source://dspy//lib/dspy/module.rb#48
  sig { params(input_values: T.untyped).returns(T.untyped) }
  def call_untyped(**input_values); end

  # The main forward method that users will call is generic and type parameterized
  #
  # source://dspy//lib/dspy/module.rb#23
  sig { type_parameters(:I).params(input_values: T.type_parameter(:I)).returns(T.type_parameter(:O)) }
  def forward(**input_values); end

  # The implementation method that subclasses must override
  #
  # @raise [NotImplementedError]
  #
  # source://dspy//lib/dspy/module.rb#30
  sig { params(input_values: T.untyped).returns(T.untyped) }
  def forward_untyped(**input_values); end

  # Get the configured LM for this instance, falling back to global
  #
  # source://dspy//lib/dspy/module.rb#54
  sig { returns(T.untyped) }
  def lm; end
end

# source://dspy//lib/dspy/re_act.rb#45
class DSPy::NextStep < ::T::Enum
  enums do
    Continue = new
    Finish = new
  end
end

# source://dspy//lib/dspy/observability.rb#6
class DSPy::Observability
  class << self
    # source://dspy//lib/dspy/observability.rb#10
    def configure!; end

    # Returns the value of attribute enabled.
    #
    # source://dspy//lib/dspy/observability.rb#8
    def enabled; end

    # @return [Boolean]
    #
    # source://dspy//lib/dspy/observability.rb#72
    def enabled?; end

    # Returns the value of attribute endpoint.
    #
    # source://dspy//lib/dspy/observability.rb#8
    def endpoint; end

    # source://dspy//lib/dspy/observability.rb#94
    def finish_span(span); end

    # source://dspy//lib/dspy/observability.rb#102
    def reset!; end

    # source://dspy//lib/dspy/observability.rb#76
    def start_span(operation_name, attributes = T.unsafe(nil)); end

    # Returns the value of attribute tracer.
    #
    # source://dspy//lib/dspy/observability.rb#8
    def tracer; end
  end
end

# source://dspy//lib/dspy/field.rb#14
class DSPy::OutputField
  # @return [OutputField] a new instance of OutputField
  #
  # source://dspy//lib/dspy/field.rb#17
  def initialize(name, type, desc: T.unsafe(nil)); end

  # Returns the value of attribute desc.
  #
  # source://dspy//lib/dspy/field.rb#15
  def desc; end

  # Returns the value of attribute name.
  #
  # source://dspy//lib/dspy/field.rb#15
  def name; end

  # Returns the value of attribute type.
  #
  # source://dspy//lib/dspy/field.rb#15
  def type; end
end

# source://dspy//lib/dspy/predict.rb#44
class DSPy::Predict < ::DSPy::Module
  include ::DSPy::Mixins::StructBuilder
  include ::DSPy::Mixins::TypeCoercion

  # source://dspy//lib/dspy/predict.rb#56
  sig { params(signature_class: T.class_of(DSPy::Signature)).void }
  def initialize(signature_class); end

  # source://dspy//lib/dspy/predict.rb#93
  sig { params(examples: T::Array[::DSPy::FewShotExample]).returns(DSPy::Predict) }
  def add_examples(examples); end

  # source://dspy//lib/dspy/predict.rb#98
  sig { override.params(kwargs: T.untyped).returns(T.type_parameter(:O)) }
  def forward(**kwargs); end

  # source://dspy//lib/dspy/predict.rb#104
  sig { params(input_values: T.untyped).returns(T.untyped) }
  def forward_untyped(**input_values); end

  # source://dspy//lib/dspy/predict.rb#53
  sig { returns(::DSPy::Prompt) }
  def prompt; end

  # source://dspy//lib/dspy/predict.rb#50
  sig { returns(T.class_of(DSPy::Signature)) }
  def signature_class; end

  # Backward compatibility methods - delegate to prompt object
  #
  # source://dspy//lib/dspy/predict.rb#64
  sig { returns(::String) }
  def system_signature; end

  # source://dspy//lib/dspy/predict.rb#69
  sig { params(input_values: T::Hash[::Symbol, T.untyped]).returns(::String) }
  def user_signature(input_values); end

  # source://dspy//lib/dspy/predict.rb#88
  sig { params(examples: T::Array[::DSPy::FewShotExample]).returns(DSPy::Predict) }
  def with_examples(examples); end

  # source://dspy//lib/dspy/predict.rb#83
  sig { params(instruction: ::String).returns(DSPy::Predict) }
  def with_instruction(instruction); end

  # New prompt-based interface for optimization
  #
  # source://dspy//lib/dspy/predict.rb#75
  sig { params(new_prompt: ::DSPy::Prompt).returns(DSPy::Predict) }
  def with_prompt(new_prompt); end

  private

  # Applies default values to missing output fields
  #
  # source://dspy//lib/dspy/predict.rb#184
  sig { params(output_attributes: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def apply_defaults_to_output(output_attributes); end

  # Creates a combined struct class with input and output properties
  #
  # source://dspy//lib/dspy/predict.rb#172
  sig { returns(T.class_of(T::Struct)) }
  def create_combined_struct_class; end

  # Creates the final prediction result struct
  #
  # source://dspy//lib/dspy/predict.rb#158
  sig do
    params(
      input_values: T::Hash[::Symbol, T.untyped],
      output_attributes: T::Hash[::Symbol, T.untyped]
    ).returns(T.untyped)
  end
  def create_prediction_result(input_values, output_attributes); end

  # Processes LM output with type coercion
  #
  # source://dspy//lib/dspy/predict.rb#146
  sig { params(output_attributes: T::Hash[T.untyped, T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def process_lm_output(output_attributes); end

  # Validates input using signature struct
  #
  # source://dspy//lib/dspy/predict.rb#133
  sig { params(input_values: T::Hash[::Symbol, T.untyped]).void }
  def validate_input_struct(input_values); end
end

# source://dspy//lib/dspy/prediction.rb#5
class DSPy::Prediction
  include ::T::Props
  include ::T::Props::Plugin
  include ::T::Props::Optional
  include ::T::Props::PrettyPrintable
  include ::T::Props::Serializable
  extend ::T::Props::ClassMethods
  extend ::T::Props::Plugin::ClassMethods
  extend ::T::Props::Serializable::ClassMethods

  # source://dspy//lib/dspy/prediction.rb#25
  sig { params(schema: T.nilable(T.any(::T::Types::Base, T::Class[::T::Struct])), attributes: T.untyped).void }
  def initialize(schema = T.unsafe(nil), **attributes); end

  # Schema information for type conversion
  #
  # source://dspy//lib/dspy/prediction.rb#17
  sig { returns(T.nilable(T::Class[::T::Struct])) }
  def _schema; end

  # The underlying struct that holds the actual data
  #
  # source://dspy//lib/dspy/prediction.rb#13
  sig { returns(T.untyped) }
  def _struct; end

  # Delegate all method calls to the underlying struct
  #
  # source://dspy//lib/dspy/prediction.rb#42
  sig { params(method: ::Symbol, args: T.untyped, block: T.untyped).returns(T.untyped) }
  def method_missing(method, *args, &block); end

  # source://dspy//lib/dspy/prediction.rb#56
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  private

  # source://dspy//lib/dspy/prediction.rb#204
  sig { params(union_type: ::T::Types::Union, discriminator_type: T.untyped).returns(T::Hash[::String, T.untyped]) }
  def build_type_mapping_from_union(union_type, discriminator_type); end

  # source://dspy//lib/dspy/prediction.rb#419
  sig { params(array: T::Array[T.untyped], type: T.untyped).returns(T::Array[T.untyped]) }
  def convert_array_elements(array, type); end

  # source://dspy//lib/dspy/prediction.rb#75
  sig { params(attributes: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def convert_attributes_with_schema(attributes); end

  # source://dspy//lib/dspy/prediction.rb#451
  sig { params(hash: T::Hash[::Symbol, T.untyped], union_type: ::T::Types::Union).returns(T.untyped) }
  def convert_hash_to_union_struct(hash, union_type); end

  # source://dspy//lib/dspy/prediction.rb#316
  sig { params(value: T::Hash[::Symbol, T.untyped], type: T.untyped).returns(T.untyped) }
  def convert_to_struct(value, type); end

  # source://dspy//lib/dspy/prediction.rb#267
  sig do
    params(
      value: T.untyped,
      discriminator_value: T.untyped,
      type_mapping: T::Hash[::String, T.untyped],
      union_type: T.untyped
    ).returns(T.untyped)
  end
  def convert_union_type(value, discriminator_value, type_mapping, union_type); end

  # source://dspy//lib/dspy/prediction.rb#517
  sig { params(attributes: T::Hash[::Symbol, T.untyped]).returns(T::Class[::T::Struct]) }
  def create_dynamic_struct(attributes); end

  # source://dspy//lib/dspy/prediction.rb#145
  sig { params(schema: T::Class[::T::Struct]).returns(T::Hash[::Symbol, [::Symbol, T::Hash[::String, T.untyped]]]) }
  def detect_discriminator_fields(schema); end

  # source://dspy//lib/dspy/prediction.rb#63
  sig { params(schema: T.untyped).returns(T.nilable(T::Class[::T::Struct])) }
  def extract_struct_class(schema); end

  # source://dspy//lib/dspy/prediction.rb#189
  sig { params(type: T.untyped).returns(T::Boolean) }
  def is_enum_type?(type); end

  # source://dspy//lib/dspy/prediction.rb#174
  sig { params(type: T.untyped).returns(T::Boolean) }
  def is_nilable_type?(type); end

  # source://dspy//lib/dspy/prediction.rb#179
  sig { params(type: T.untyped).returns(T::Boolean) }
  def is_string_type?(type); end

  # source://dspy//lib/dspy/prediction.rb#169
  sig { params(type: T.untyped).returns(T::Boolean) }
  def is_union_type?(type); end

  # source://dspy//lib/dspy/prediction.rb#399
  sig { params(type: T.untyped).returns(T::Boolean) }
  def needs_array_conversion?(type); end

  # source://dspy//lib/dspy/prediction.rb#303
  sig { params(type: T.untyped).returns(T::Boolean) }
  def needs_struct_conversion?(type); end

  # source://dspy//lib/dspy/prediction.rb#51
  sig { params(method: ::Symbol, include_all: T::Boolean).returns(T::Boolean) }
  def respond_to_missing?(method, include_all = T.unsafe(nil)); end
end

# Exception raised when prediction fails validation
#
# source://dspy//lib/dspy/predict.rb#12
class DSPy::PredictionInvalidError < ::StandardError
  # source://dspy//lib/dspy/predict.rb#16
  sig { params(errors: T::Hash[T.untyped, T.untyped], context: T.nilable(::String)).void }
  def initialize(errors, context: T.unsafe(nil)); end

  # source://dspy//lib/dspy/predict.rb#41
  sig { returns(T.nilable(::String)) }
  def context; end

  # source://dspy//lib/dspy/predict.rb#38
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def errors; end
end

# source://dspy//lib/dspy/prompt.rb#7
class DSPy::Prompt
  # source://dspy//lib/dspy/prompt.rb#34
  sig do
    params(
      instruction: ::String,
      input_schema: T::Hash[::Symbol, T.untyped],
      output_schema: T::Hash[::Symbol, T.untyped],
      few_shot_examples: T::Array[::DSPy::FewShotExample],
      signature_class_name: T.nilable(::String)
    ).void
  end
  def initialize(instruction:, input_schema:, output_schema:, few_shot_examples: T.unsafe(nil), signature_class_name: T.unsafe(nil)); end

  # Comparison and diff methods for optimization
  #
  # source://dspy//lib/dspy/prompt.rb#182
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://dspy//lib/dspy/prompt.rb#66
  sig { params(new_examples: T::Array[::DSPy::FewShotExample]).returns(::DSPy::Prompt) }
  def add_examples(new_examples); end

  # source://dspy//lib/dspy/prompt.rb#192
  sig { params(other: ::DSPy::Prompt).returns(T::Hash[::Symbol, T.untyped]) }
  def diff(other); end

  # source://dspy//lib/dspy/prompt.rb#14
  sig { returns(T::Array[::DSPy::FewShotExample]) }
  def few_shot_examples; end

  # source://dspy//lib/dspy/prompt.rb#17
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def input_schema; end

  # source://dspy//lib/dspy/prompt.rb#11
  sig { returns(::String) }
  def instruction; end

  # source://dspy//lib/dspy/prompt.rb#20
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def output_schema; end

  # Core prompt rendering methods
  #
  # source://dspy//lib/dspy/prompt.rb#73
  sig { returns(::String) }
  def render_system_prompt; end

  # source://dspy//lib/dspy/prompt.rb#119
  sig { params(input_values: T::Hash[::Symbol, T.untyped]).returns(::String) }
  def render_user_prompt(input_values); end

  # source://dspy//lib/dspy/prompt.rb#23
  sig { returns(T.nilable(::String)) }
  def signature_class_name; end

  # Statistics for optimization tracking
  #
  # source://dspy//lib/dspy/prompt.rb#212
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def stats; end

  # Serialization for persistence and optimization
  #
  # source://dspy//lib/dspy/prompt.rb#145
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # Generate messages for LM adapter
  #
  # source://dspy//lib/dspy/prompt.rb#136
  sig { params(input_values: T::Hash[::Symbol, T.untyped]).returns(T::Array[T::Hash[::Symbol, ::String]]) }
  def to_messages(input_values); end

  # source://dspy//lib/dspy/prompt.rb#55
  sig { params(new_examples: T::Array[::DSPy::FewShotExample]).returns(::DSPy::Prompt) }
  def with_examples(new_examples); end

  # Immutable update methods for optimization
  #
  # source://dspy//lib/dspy/prompt.rb#44
  sig { params(new_instruction: ::String).returns(::DSPy::Prompt) }
  def with_instruction(new_instruction); end

  private

  # Recursively serialize complex objects for JSON representation
  #
  # source://dspy//lib/dspy/prompt.rb#226
  sig { params(obj: T.untyped).returns(T.untyped) }
  def serialize_for_json(obj); end

  # Fallback method to serialize T::Struct to hash when to_h is not available
  #
  # source://dspy//lib/dspy/prompt.rb#253
  sig { params(struct_obj: ::T::Struct).returns(T::Hash[::Symbol, T.untyped]) }
  def serialize_struct_to_hash(struct_obj); end

  class << self
    # source://dspy//lib/dspy/prompt.rb#156
    sig { params(hash: T::Hash[::Symbol, T.untyped]).returns(::DSPy::Prompt) }
    def from_h(hash); end

    # Create prompt from signature class
    #
    # source://dspy//lib/dspy/prompt.rb#170
    sig { params(signature_class: T.class_of(DSPy::Signature)).returns(::DSPy::Prompt) }
    def from_signature(signature_class); end
  end
end

# source://dspy//lib/dspy/propose/grounded_proposer.rb#8
module DSPy::Propose; end

# Grounded Proposer for generating better instructions based on training data
# Analyzes task patterns and creates contextually appropriate instructions
#
# source://dspy//lib/dspy/propose/grounded_proposer.rb#11
class DSPy::Propose::GroundedProposer
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#92
  sig { params(config: T.nilable(::DSPy::Propose::GroundedProposer::Config)).void }
  def initialize(config: T.unsafe(nil)); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#89
  sig { returns(::DSPy::Propose::GroundedProposer::Config) }
  def config; end

  # Generate instruction candidates for a signature and training examples
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#105
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      examples: T::Array[T.untyped],
      few_shot_examples: T.nilable(T::Array[T.untyped]),
      current_instruction: T.nilable(::String)
    ).returns(::DSPy::Propose::GroundedProposer::ProposalResult)
  end
  def propose_instructions(signature_class, examples, few_shot_examples: T.unsafe(nil), current_instruction: T.unsafe(nil)); end

  private

  # Analyze patterns in training examples
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#186
  sig { params(examples: T::Array[T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def analyze_example_patterns(examples); end

  # Analyze few-shot example patterns
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#277
  sig { params(few_shot_examples: T::Array[T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def analyze_few_shot_patterns(few_shot_examples); end

  # Analyze input patterns in examples
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#200
  sig { params(examples: T::Array[T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def analyze_input_patterns(examples); end

  # Analyze output patterns in examples
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#227
  sig { params(examples: T::Array[T.untyped]).returns(T::Hash[::Symbol, T.untyped]) }
  def analyze_output_patterns(examples); end

  # Analyze the task based on signature and training examples
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#155
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      examples: T::Array[T.untyped],
      few_shot_examples: T.nilable(T::Array[T.untyped])
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def analyze_task(signature_class, examples, few_shot_examples); end

  # Assess variety in examples
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#503
  sig { params(examples: T::Array[T.untyped]).returns(::String) }
  def assess_example_variety(examples); end

  # Assess task complexity indicators
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#292
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      examples: T::Array[T.untyped]
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def assess_task_complexity(signature_class, examples); end

  # Build context for instruction generation
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#361
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      analysis: T::Hash[::Symbol, T.untyped],
      current_instruction: T.nilable(::String)
    ).returns(::String)
  end
  def build_generation_context(signature_class, analysis, current_instruction); end

  # Build requirements text for instruction generation
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#384
  sig { params(analysis: T::Hash[::Symbol, T.untyped]).returns(::String) }
  def build_requirements_text(analysis); end

  # Create signature for instruction generation
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#407
  sig { returns(T.class_of(DSPy::Signature)) }
  def create_instruction_generation_signature; end

  # Emit instruction proposal completion event
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#551
  sig { params(result: ::DSPy::Propose::GroundedProposer::ProposalResult).void }
  def emit_proposal_complete_event(result); end

  # Extract common themes from examples
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#250
  sig { params(examples: T::Array[T.untyped]).returns(T::Array[::String]) }
  def extract_common_themes(examples); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#483
  sig { params(example: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def extract_expected_values(example); end

  # Extract field information from struct classes
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#173
  sig { params(struct_class: T.class_of(T::Struct)).returns(T::Array[T::Hash[::Symbol, T.untyped]]) }
  def extract_field_info(struct_class); end

  # Helper methods for extracting values from examples
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#471
  sig { params(example: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def extract_input_values(example); end

  # Filter and rank instruction candidates
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#442
  sig { params(candidates: T::Array[::String], analysis: T::Hash[::Symbol, T.untyped]).returns(T::Array[::String]) }
  def filter_and_rank_candidates(candidates, analysis); end

  # Generate a fallback instruction when LLM generation fails
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#430
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      analysis: T::Hash[::Symbol, T.untyped]
    ).returns(::String)
  end
  def generate_fallback_instruction(signature_class, analysis); end

  # Generate instruction candidates using LLM
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#309
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      analysis: T::Hash[::Symbol, T.untyped],
      current_instruction: T.nilable(::String)
    ).returns(T::Array[::String])
  end
  def generate_instruction_candidates(signature_class, analysis, current_instruction); end

  # Check if signature has complex output types
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#521
  sig { params(signature_class: T.class_of(DSPy::Signature)).returns(T::Boolean) }
  def has_complex_output_types?(signature_class); end

  # Check if example has reasoning field
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#496
  sig { params(example: T.untyped).returns(T::Boolean) }
  def has_reasoning_field?(example); end

  # Check if task requires reasoning
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#530
  sig { params(signature_class: T.class_of(DSPy::Signature), examples: T::Array[T.untyped]).returns(T::Boolean) }
  def task_requires_reasoning?(signature_class, examples); end
end

# Configuration for instruction proposal
#
# source://dspy//lib/dspy/propose/grounded_proposer.rb#15
class DSPy::Propose::GroundedProposer::Config
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#40
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#22
  sig { returns(::Integer) }
  def max_examples_for_analysis; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#22
  def max_examples_for_analysis=(_arg0); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#25
  sig { returns(::Integer) }
  def max_instruction_length; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#25
  def max_instruction_length=(_arg0); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#19
  sig { returns(::Integer) }
  def num_instruction_candidates; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#19
  def num_instruction_candidates=(_arg0); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#37
  sig { returns(::String) }
  def proposal_model; end

  # @return [String]
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#37
  def proposal_model=(_arg0); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#34
  sig { returns(T::Boolean) }
  def use_few_shot_examples; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#34
  def use_few_shot_examples=(_arg0); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#31
  sig { returns(T::Boolean) }
  def use_input_output_analysis; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#31
  def use_input_output_analysis=(_arg0); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#28
  sig { returns(T::Boolean) }
  def use_task_description; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#28
  def use_task_description=(_arg0); end
end

# Result of instruction proposal
#
# source://dspy//lib/dspy/propose/grounded_proposer.rb#52
class DSPy::Propose::GroundedProposer::ProposalResult
  # source://dspy//lib/dspy/propose/grounded_proposer.rb#71
  sig do
    params(
      candidate_instructions: T::Array[::String],
      analysis: T::Hash[::Symbol, T.untyped],
      metadata: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(candidate_instructions:, analysis:, metadata:); end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#59
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def analysis; end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#78
  sig { returns(::String) }
  def best_instruction; end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#56
  sig { returns(T::Array[::String]) }
  def candidate_instructions; end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#62
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def metadata; end

  # source://dspy//lib/dspy/propose/grounded_proposer.rb#83
  sig { returns(::Integer) }
  def num_candidates; end
end

# ReAct Agent using Sorbet signatures
#
# source://dspy//lib/dspy/re_act.rb#65
class DSPy::ReAct < ::DSPy::Predict
  # source://dspy//lib/dspy/re_act.rb#84
  sig do
    params(
      signature_class: T.class_of(DSPy::Signature),
      tools: T::Array[::DSPy::Tools::Base],
      max_iterations: ::Integer
    ).void
  end
  def initialize(signature_class, tools: T.unsafe(nil), max_iterations: T.unsafe(nil)); end

  # source://dspy//lib/dspy/re_act.rb#74
  sig { returns(T.class_of(T::Struct)) }
  def enhanced_output_struct; end

  # source://dspy//lib/dspy/re_act.rb#125
  sig { override.params(kwargs: T.untyped).returns(T.untyped) }
  def forward(**kwargs); end

  # source://dspy//lib/dspy/re_act.rb#80
  sig { returns(::Integer) }
  def max_iterations; end

  # source://dspy//lib/dspy/re_act.rb#71
  sig { returns(T.class_of(DSPy::Signature)) }
  def original_signature_class; end

  # source://dspy//lib/dspy/re_act.rb#77
  sig { returns(T::Hash[::String, T.untyped]) }
  def tools; end

  private

  # Creates enhanced output struct with ReAct-specific fields
  #
  # source://dspy//lib/dspy/re_act.rb#303
  sig { params(signature_class: T.class_of(DSPy::Signature)).returns(T.class_of(T::Struct)) }
  def create_enhanced_output_struct(signature_class); end

  # Creates enhanced result struct
  #
  # source://dspy//lib/dspy/re_act.rb#319
  sig do
    params(
      input_kwargs: T::Hash[::Symbol, T.untyped],
      reasoning_result: T::Hash[::Symbol, T.untyped]
    ).returns(T.untyped)
  end
  def create_enhanced_result(input_kwargs, reasoning_result); end

  # source://dspy//lib/dspy/re_act.rb#366
  sig do
    params(
      step: ::Integer,
      thought: ::String,
      action: ::String,
      action_input: T.untyped,
      observation: ::String
    ).returns(::DSPy::HistoryEntry)
  end
  def create_history_entry(step, thought, action, action_input, observation); end

  # Creates a dynamic observation signature that includes the original input fields
  #
  # source://dspy//lib/dspy/re_act.rb#173
  sig { params(signature_class: T.class_of(DSPy::Signature)).returns(T.class_of(DSPy::Signature)) }
  def create_observation_signature(signature_class); end

  # Creates a dynamic Thought signature that includes the original input fields
  #
  # source://dspy//lib/dspy/re_act.rb#143
  sig { params(signature_class: T.class_of(DSPy::Signature)).returns(T.class_of(DSPy::Signature)) }
  def create_thought_signature(signature_class); end

  # source://dspy//lib/dspy/re_act.rb#440
  sig { returns(::String) }
  def default_no_answer_message; end

  # source://dspy//lib/dspy/re_act.rb#416
  sig do
    params(
      iteration: ::Integer,
      thought: ::String,
      action: ::String,
      action_input: T.untyped,
      observation: ::String,
      tools_used: T::Array[::String]
    ).void
  end
  def emit_iteration_complete_event(iteration, thought, action, action_input, observation, tools_used); end

  # Tool execution method
  #
  # source://dspy//lib/dspy/re_act.rb#446
  sig { params(action: ::String, action_input: T.untyped).returns(::String) }
  def execute_action(action, action_input); end

  # Executes the main ReAct reasoning loop
  #
  # source://dspy//lib/dspy/re_act.rb#201
  sig { params(input_struct: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def execute_react_reasoning_loop(input_struct); end

  # Executes a single iteration of the ReAct loop
  #
  # source://dspy//lib/dspy/re_act.rb#238
  sig do
    params(
      input_struct: T.untyped,
      history: T::Array[::DSPy::HistoryEntry],
      available_tools_desc: T::Array[T::Hash[::String, T.untyped]],
      iteration: ::Integer,
      tools_used: T::Array[::String],
      last_observation: T.nilable(::String)
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def execute_single_iteration(input_struct, history, available_tools_desc, iteration, tools_used, last_observation); end

  # source://dspy//lib/dspy/re_act.rb#349
  sig { params(action: T.nilable(::String), action_input: T.untyped, iteration: ::Integer).returns(::String) }
  def execute_tool_with_instrumentation(action, action_input, iteration); end

  # source://dspy//lib/dspy/re_act.rb#339
  sig { params(action: T.nilable(::String)).returns(T::Boolean) }
  def finish_action?(action); end

  # source://dspy//lib/dspy/re_act.rb#496
  sig { returns(T.untyped) }
  def generate_example_output; end

  # source://dspy//lib/dspy/re_act.rb#396
  sig do
    params(
      input_struct: T.untyped,
      history: T::Array[::DSPy::HistoryEntry],
      available_tools_desc: T::Array[T::Hash[::String, T.untyped]],
      observation_result: T.untyped,
      iteration: ::Integer
    ).returns(::String)
  end
  def generate_forced_final_answer(input_struct, history, available_tools_desc, observation_result, iteration); end

  # source://dspy//lib/dspy/re_act.rb#513
  sig do
    params(
      action_input: T.untyped,
      last_observation: T.nilable(::String),
      step: ::Integer,
      thought: ::String,
      action: ::String,
      history: T::Array[::DSPy::HistoryEntry]
    ).returns(::String)
  end
  def handle_finish_action(action_input, last_observation, step, thought, action, history); end

  # source://dspy//lib/dspy/re_act.rb#428
  sig do
    params(
      iterations_count: ::Integer,
      final_answer: T.nilable(::String),
      tools_used: T::Array[::String],
      history: T::Array[::DSPy::HistoryEntry]
    ).void
  end
  def handle_max_iterations_if_needed(iterations_count, final_answer, tools_used, history); end

  # source://dspy//lib/dspy/re_act.rb#377
  sig do
    params(
      input_struct: T.untyped,
      history: T::Array[::DSPy::HistoryEntry],
      observation: ::String,
      available_tools_desc: T::Array[T::Hash[::String, T.untyped]],
      iteration: ::Integer
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def process_observation_and_decide_next_step(input_struct, history, observation, available_tools_desc, iteration); end

  # Helper methods for ReAct logic
  #
  # source://dspy//lib/dspy/re_act.rb#334
  sig { params(iterations_count: ::Integer, final_answer: T.nilable(::String)).returns(T::Boolean) }
  def should_continue_iteration?(iterations_count, final_answer); end

  # source://dspy//lib/dspy/re_act.rb#344
  sig { params(action: T.nilable(::String)).returns(T::Boolean) }
  def valid_tool?(action); end

  # source://dspy//lib/dspy/re_act.rb#468
  sig { params(output: T.untyped).void }
  def validate_output_schema!(output); end
end

# source://dspy//lib/dspy/re_act.rb#69
DSPy::ReAct::FINISH_ACTION = T.let(T.unsafe(nil), String)

# Base class for observation processing - will be customized per input type
#
# source://dspy//lib/dspy/re_act.rb#53
class DSPy::ReActObservationBase < ::DSPy::Signature; end

# source://dspy//lib/dspy/registry/signature_registry.rb#9
module DSPy::Registry; end

# High-level registry manager that integrates with the DSPy ecosystem
# Provides automatic version management and integration with optimization results
#
# source://dspy//lib/dspy/registry/registry_manager.rb#10
class DSPy::Registry::RegistryManager
  # source://dspy//lib/dspy/registry/registry_manager.rb#70
  sig do
    params(
      registry_config: T.nilable(::DSPy::Registry::SignatureRegistry::RegistryConfig),
      integration_config: T.nilable(::DSPy::Registry::RegistryManager::RegistryIntegrationConfig)
    ).void
  end
  def initialize(registry_config: T.unsafe(nil), integration_config: T.unsafe(nil)); end

  # Bulk operations for managing multiple signatures
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#229
  sig { params(signature_names: T::Array[::String]).returns(T::Hash[::String, T.untyped]) }
  def bulk_deployment_status(signature_names); end

  # Clean up old versions across all signatures
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#241
  sig { returns(T::Hash[::Symbol, ::Integer]) }
  def cleanup_old_versions; end

  # Create a safe deployment plan
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#182
  sig { params(signature_name: ::String, target_version: ::String).returns(T::Hash[::Symbol, T.untyped]) }
  def create_deployment_plan(signature_name, target_version); end

  # Create a deployment strategy
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#126
  sig do
    params(
      signature_name: ::String,
      strategy: ::String
    ).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion))
  end
  def deploy_with_strategy(signature_name, strategy: T.unsafe(nil)); end

  # Get deployment status and recommendations
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#164
  sig { params(signature_name: ::String).returns(T::Hash[::Symbol, T.untyped]) }
  def get_deployment_status(signature_name); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#62
  sig { returns(::DSPy::Registry::RegistryManager::RegistryIntegrationConfig) }
  def integration_config; end

  # Monitor and rollback if needed
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#143
  sig { params(signature_name: ::String, current_score: ::Float).returns(T::Boolean) }
  def monitor_and_rollback(signature_name, current_score); end

  # Register an optimization result automatically
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#83
  sig do
    params(
      optimization_result: T.untyped,
      signature_name: T.nilable(::String),
      metadata: T::Hash[::Symbol, T.untyped]
    ).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion))
  end
  def register_optimization_result(optimization_result, signature_name: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#59
  sig { returns(::DSPy::Registry::SignatureRegistry) }
  def registry; end

  private

  # source://dspy//lib/dspy/registry/registry_manager.rb#365
  sig { params(signature_name: ::String, version: ::DSPy::Registry::SignatureRegistry::SignatureVersion).void }
  def check_auto_deployment(signature_name, version); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#410
  sig { params(signature_name: ::String).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion)) }
  def deploy_aggressive(signature_name); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#421
  sig { params(signature_name: ::String).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion)) }
  def deploy_best_score(signature_name); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#385
  sig { params(signature_name: ::String).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion)) }
  def deploy_conservative(signature_name); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#484
  sig { params(signature_name: ::String, version: ::String).void }
  def emit_auto_deployment_event(signature_name, version); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#492
  sig { params(signature_name: ::String, current_score: ::Float, previous_score: ::Float).void }
  def emit_automatic_rollback_event(signature_name, current_score, previous_score); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#465
  sig { params(configuration: T::Hash[::Symbol, T.untyped]).returns(::Float) }
  def estimate_configuration_complexity(configuration); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#293
  sig { params(optimization_result: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def extract_configuration(optimization_result); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#343
  sig { params(optimization_result: T.untyped).returns(T.nilable(::String)) }
  def extract_optimization_timestamp(optimization_result); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#334
  sig { params(optimization_result: T.untyped).returns(T.nilable(::String)) }
  def extract_optimizer_name(optimization_result); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#325
  sig { params(optimization_result: T.untyped).returns(T.nilable(::Float)) }
  def extract_performance_score(optimization_result); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#357
  sig { params(optimization_result: T.untyped).returns(T.nilable(::String)) }
  def extract_program_id(optimization_result); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#283
  sig { params(optimization_result: T.untyped).returns(T.nilable(::String)) }
  def extract_signature_name(optimization_result); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#350
  sig { params(optimization_result: T.untyped).returns(T.nilable(::Integer)) }
  def extract_trials_count(optimization_result); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#432
  sig do
    params(
      signature_name: ::String,
      versions: T::Array[::DSPy::Registry::SignatureRegistry::SignatureVersion],
      deployed: T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion)
    ).returns(T::Array[::String])
  end
  def generate_deployment_recommendations(signature_name, versions, deployed); end

  class << self
    # source://dspy//lib/dspy/registry/registry_manager.rb#276
    sig do
      params(
        registry_config: ::DSPy::Registry::SignatureRegistry::RegistryConfig,
        integration_config: ::DSPy::Registry::RegistryManager::RegistryIntegrationConfig
      ).void
    end
    def configure(registry_config: T.unsafe(nil), integration_config: T.unsafe(nil)); end

    # source://dspy//lib/dspy/registry/registry_manager.rb#271
    sig { returns(::DSPy::Registry::RegistryManager) }
    def instance; end
  end
end

# Configuration for automatic registry integration
#
# source://dspy//lib/dspy/registry/registry_manager.rb#14
class DSPy::Registry::RegistryManager::RegistryIntegrationConfig
  # source://dspy//lib/dspy/registry/registry_manager.rb#36
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/registry/registry_manager.rb#21
  sig { returns(T::Boolean) }
  def auto_deploy_best_versions; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#21
  def auto_deploy_best_versions=(_arg0); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#24
  sig { returns(::Float) }
  def auto_deploy_threshold; end

  # @return [Float]
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#24
  def auto_deploy_threshold=(_arg0); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#18
  sig { returns(T::Boolean) }
  def auto_register_optimizations; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#18
  def auto_register_optimizations=(_arg0); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#33
  sig { returns(::String) }
  def deployment_strategy; end

  # @return [String]
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#33
  def deployment_strategy=(_arg0); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#27
  sig { returns(T::Boolean) }
  def rollback_on_performance_drop; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#27
  def rollback_on_performance_drop=(_arg0); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#30
  sig { returns(::Float) }
  def rollback_threshold; end

  # @return [Float]
  #
  # source://dspy//lib/dspy/registry/registry_manager.rb#30
  def rollback_threshold=(_arg0); end

  # source://dspy//lib/dspy/registry/registry_manager.rb#46
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end
end

# Registry for managing signature versions and deployments
# Provides version control, rollback capabilities, and deployment tracking
#
# source://dspy//lib/dspy/registry/signature_registry.rb#12
class DSPy::Registry::SignatureRegistry
  # source://dspy//lib/dspy/registry/signature_registry.rb#210
  sig { params(config: T.nilable(::DSPy::Registry::SignatureRegistry::RegistryConfig)).void }
  def initialize(config: T.unsafe(nil)); end

  # Compare two versions
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#444
  sig do
    params(
      signature_name: ::String,
      version1: ::String,
      version2: ::String
    ).returns(T.nilable(T::Hash[::Symbol, T.untyped]))
  end
  def compare_versions(signature_name, version1, version2); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#207
  sig { returns(::DSPy::Registry::SignatureRegistry::RegistryConfig) }
  def config; end

  # Deploy a specific version
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#270
  sig do
    params(
      signature_name: ::String,
      version: ::String
    ).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion))
  end
  def deploy_version(signature_name, version); end

  # Export registry state
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#476
  sig { params(export_path: ::String).void }
  def export_registry(export_path); end

  # Get currently deployed version
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#374
  sig { params(signature_name: ::String).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion)) }
  def get_deployed_version(signature_name); end

  # Get performance history for a signature
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#410
  sig { params(signature_name: ::String).returns(T::Hash[::Symbol, T.untyped]) }
  def get_performance_history(signature_name); end

  # Import registry state
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#493
  sig { params(import_path: ::String).void }
  def import_registry(import_path); end

  # List all signatures in registry
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#387
  sig { returns(T::Array[::String]) }
  def list_signatures; end

  # List all versions for a signature
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#381
  sig { params(signature_name: ::String).returns(T::Array[::DSPy::Registry::SignatureRegistry::SignatureVersion]) }
  def list_versions(signature_name); end

  # Register a new signature version
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#226
  sig do
    params(
      signature_name: ::String,
      configuration: T::Hash[::Symbol, T.untyped],
      metadata: T::Hash[::Symbol, T.untyped],
      program_id: T.nilable(::String),
      version: T.nilable(::String)
    ).returns(::DSPy::Registry::SignatureRegistry::SignatureVersion)
  end
  def register_version(signature_name, configuration, metadata: T.unsafe(nil), program_id: T.unsafe(nil), version: T.unsafe(nil)); end

  # Rollback to previous deployed version
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#324
  sig { params(signature_name: ::String).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion)) }
  def rollback(signature_name); end

  # Update performance score for a version
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#395
  sig do
    params(
      signature_name: ::String,
      version: ::String,
      score: ::Float
    ).returns(T.nilable(::DSPy::Registry::SignatureRegistry::SignatureVersion))
  end
  def update_performance_score(signature_name, version, score); end

  private

  # source://dspy//lib/dspy/registry/signature_registry.rb#574
  sig { params(versions: T::Array[::DSPy::Registry::SignatureRegistry::SignatureVersion]).returns(::Float) }
  def calculate_improvement_trend(versions); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#593
  sig do
    params(
      config1: T::Hash[::Symbol, T.untyped],
      config2: T::Hash[::Symbol, T.untyped]
    ).returns(T::Array[::String])
  end
  def compare_configurations(config1, config2); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#565
  sig { params(version: ::DSPy::Registry::SignatureRegistry::SignatureVersion).void }
  def create_deployment_backup(version); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#647
  sig { params(version: ::DSPy::Registry::SignatureRegistry::SignatureVersion).void }
  def emit_deploy_complete_event(version); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#656
  sig { params(signature_name: ::String, version: ::String, error: ::Exception).void }
  def emit_deploy_error_event(signature_name, version, error); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#639
  sig { params(signature_name: ::String, version: ::String).void }
  def emit_deploy_start_event(signature_name, version); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#697
  sig { params(export_path: ::String, signature_count: ::Integer).void }
  def emit_export_event(export_path, signature_count); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#705
  sig { params(import_path: ::String, signature_count: ::Integer).void }
  def emit_import_event(import_path, signature_count); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#688
  sig { params(version: ::DSPy::Registry::SignatureRegistry::SignatureVersion).void }
  def emit_performance_update_event(version); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#621
  sig { params(version: ::DSPy::Registry::SignatureRegistry::SignatureVersion).void }
  def emit_register_complete_event(version); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#630
  sig { params(signature_name: ::String, version: T.nilable(::String), error: ::Exception).void }
  def emit_register_error_event(signature_name, version, error); end

  # Event emission methods
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#613
  sig { params(signature_name: ::String, version: T.nilable(::String)).void }
  def emit_register_start_event(signature_name, version); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#672
  sig { params(version: ::DSPy::Registry::SignatureRegistry::SignatureVersion).void }
  def emit_rollback_complete_event(version); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#680
  sig { params(signature_name: ::String, error_message: ::String).void }
  def emit_rollback_error_event(signature_name, error_message); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#665
  sig { params(signature_name: ::String).void }
  def emit_rollback_start_event(signature_name); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#538
  sig { returns(::String) }
  def generate_version_name; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#520
  sig { void }
  def load_or_create_config; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#543
  sig { params(signature_name: ::String).returns(T::Array[::DSPy::Registry::SignatureRegistry::SignatureVersion]) }
  def load_signature_versions(signature_name); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#532
  sig { void }
  def save_config; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#553
  sig do
    params(
      signature_name: ::String,
      versions: T::Array[::DSPy::Registry::SignatureRegistry::SignatureVersion]
    ).void
  end
  def save_signature_versions(signature_name, versions); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#509
  sig { void }
  def setup_registry_directory; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#560
  sig { params(signature_name: ::String).returns(::String) }
  def signature_file_path(signature_name); end
end

# Configuration for the registry
#
# source://dspy//lib/dspy/registry/signature_registry.rb#152
class DSPy::Registry::SignatureRegistry::RegistryConfig
  # source://dspy//lib/dspy/registry/signature_registry.rb#174
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#162
  sig { returns(T::Boolean) }
  def auto_version; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#162
  def auto_version=(_arg0); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#168
  sig { returns(T::Boolean) }
  def backup_on_deploy; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#168
  def backup_on_deploy=(_arg0); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#159
  sig { returns(::String) }
  def config_file; end

  # @return [String]
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#159
  def config_file=(_arg0); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#196
  sig { params(data: T::Hash[::Symbol, T.untyped]).void }
  def from_h(data); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#165
  sig { returns(::Integer) }
  def max_versions_per_signature; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#165
  def max_versions_per_signature=(_arg0); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#156
  sig { returns(::String) }
  def registry_path; end

  # @return [String]
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#156
  def registry_path=(_arg0); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#184
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#171
  sig { returns(::String) }
  def version_format; end

  # @return [String]
  #
  # source://dspy//lib/dspy/registry/signature_registry.rb#171
  def version_format=(_arg0); end
end

# Represents a versioned signature with deployment information
#
# source://dspy//lib/dspy/registry/signature_registry.rb#16
class DSPy::Registry::SignatureRegistry::SignatureVersion
  # source://dspy//lib/dspy/registry/signature_registry.rb#57
  sig do
    params(
      signature_name: ::String,
      version: ::String,
      configuration: T::Hash[::Symbol, T.untyped],
      metadata: T::Hash[::Symbol, T.untyped],
      program_id: T.nilable(::String),
      is_deployed: T::Boolean,
      performance_score: T.nilable(::Float)
    ).void
  end
  def initialize(signature_name:, version:, configuration:, metadata: T.unsafe(nil), program_id: T.unsafe(nil), is_deployed: T.unsafe(nil), performance_score: T.unsafe(nil)); end

  # source://dspy//lib/dspy/registry/signature_registry.rb#29
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def configuration; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#35
  sig { returns(::Time) }
  def created_at; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#117
  sig { returns(::DSPy::Registry::SignatureRegistry::SignatureVersion) }
  def deploy; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#41
  sig { returns(T::Boolean) }
  def is_deployed; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#32
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def metadata; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#44
  sig { returns(T.nilable(::Float)) }
  def performance_score; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#38
  sig { returns(T.nilable(::String)) }
  def program_id; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#20
  sig { returns(::String) }
  def signature_name; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#73
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#130
  sig { returns(::DSPy::Registry::SignatureRegistry::SignatureVersion) }
  def undeploy; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#23
  sig { returns(::String) }
  def version; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#26
  sig { returns(::String) }
  def version_hash; end

  # source://dspy//lib/dspy/registry/signature_registry.rb#104
  sig { params(score: ::Float).returns(::DSPy::Registry::SignatureRegistry::SignatureVersion) }
  def with_performance_score(score); end

  private

  # source://dspy//lib/dspy/registry/signature_registry.rb#145
  sig { returns(::String) }
  def generate_version_hash; end

  class << self
    # source://dspy//lib/dspy/registry/signature_registry.rb#88
    sig { params(data: T::Hash[::Symbol, T.untyped]).returns(::DSPy::Registry::SignatureRegistry::SignatureVersion) }
    def from_h(data); end
  end
end

# Defines the signature for Ruby code generation
#
# source://dspy//lib/dspy/code_act.rb#34
class DSPy::RubyCodeGeneration < ::DSPy::Signature; end

# Defines the signature for processing code execution results
#
# source://dspy//lib/dspy/code_act.rb#64
class DSPy::RubyCodeObservation < ::DSPy::Signature; end

# Schema adapters for integrating sorbet-schema with T::Struct
#
# source://dspy//lib/dspy/schema_adapters.rb#7
module DSPy::SchemaAdapters; end

# Handles sorbet-schema integration for serialization/deserialization
#
# source://dspy//lib/dspy/schema_adapters.rb#9
class DSPy::SchemaAdapters::SorbetSchemaAdapter
  class << self
    # Serialize a hash to a T::Struct using sorbet-schema
    #
    # source://dspy//lib/dspy/schema_adapters.rb#18
    sig { params(struct_class: T.class_of(T::Struct), hash_data: T::Hash[T.untyped, T.untyped]).returns(::T::Struct) }
    def from_hash(struct_class, hash_data); end

    # Deserialize a T::Struct to a hash using sorbet-schema
    #
    # source://dspy//lib/dspy/schema_adapters.rb#29
    sig { params(struct_instance: ::T::Struct).returns(T::Hash[T.untyped, T.untyped]) }
    def to_hash(struct_instance); end

    # Validate data against a T::Struct schema using sorbet-schema
    #
    # source://dspy//lib/dspy/schema_adapters.rb#45
    sig do
      params(
        struct_class: T.class_of(T::Struct),
        hash_data: T::Hash[T.untyped, T.untyped]
      ).returns([T::Boolean, T.untyped])
    end
    def validate(struct_class, hash_data); end
  end
end

# source://dspy//lib/dspy/signature.rb#7
class DSPy::Signature
  class << self
    # source://dspy//lib/dspy/signature.rb#75
    sig { returns(T.nilable(::String)) }
    def desc; end

    # source://dspy//lib/dspy/signature.rb#90
    sig { params(desc: T.nilable(::String)).returns(T.nilable(::String)) }
    def description(desc = T.unsafe(nil)); end

    # source://dspy//lib/dspy/signature.rb#99
    sig { params(block: T.proc.void).void }
    def input(&block); end

    # source://dspy//lib/dspy/signature.rb#84
    sig { returns(T::Hash[::Symbol, ::DSPy::Signature::FieldDescriptor]) }
    def input_field_descriptors; end

    # source://dspy//lib/dspy/signature.rb#129
    sig { returns(T::Hash[::Symbol, T.untyped]) }
    def input_json_schema; end

    # source://dspy//lib/dspy/signature.rb#151
    sig { returns(T.nilable(T.class_of(T::Struct))) }
    def input_schema; end

    # source://dspy//lib/dspy/signature.rb#78
    sig { returns(T.nilable(T.class_of(T::Struct))) }
    def input_struct_class; end

    # source://dspy//lib/dspy/signature.rb#114
    sig { params(block: T.proc.void).void }
    def output(&block); end

    # source://dspy//lib/dspy/signature.rb#87
    sig { returns(T::Hash[::Symbol, ::DSPy::Signature::FieldDescriptor]) }
    def output_field_descriptors; end

    # source://dspy//lib/dspy/signature.rb#156
    sig { returns(T::Hash[::Symbol, T.untyped]) }
    def output_json_schema; end

    # source://dspy//lib/dspy/signature.rb#178
    sig { returns(T.nilable(T.class_of(T::Struct))) }
    def output_schema; end

    # source://dspy//lib/dspy/signature.rb#81
    sig { returns(T.nilable(T.class_of(T::Struct))) }
    def output_struct_class; end

    private

    # Generate JSON schema for custom T::Struct classes
    #
    # source://dspy//lib/dspy/signature.rb#289
    sig { params(struct_class: T.class_of(T::Struct)).returns(T::Hash[::Symbol, T.untyped]) }
    def generate_struct_schema(struct_class); end

    # source://dspy//lib/dspy/signature.rb#185
    sig { params(type: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
    def type_to_json_schema(type); end
  end
end

# Container for field type and description
#
# source://dspy//lib/dspy/signature.rb#11
class DSPy::Signature::FieldDescriptor
  # source://dspy//lib/dspy/signature.rb#27
  sig do
    params(
      type: T.untyped,
      description: T.nilable(::String),
      has_default: T::Boolean,
      default_value: T.untyped
    ).void
  end
  def initialize(type, description = T.unsafe(nil), has_default = T.unsafe(nil), default_value = T.unsafe(nil)); end

  # source://dspy//lib/dspy/signature.rb#24
  sig { returns(T.untyped) }
  def default_value; end

  # source://dspy//lib/dspy/signature.rb#18
  sig { returns(T.nilable(::String)) }
  def description; end

  # source://dspy//lib/dspy/signature.rb#21
  sig { returns(T::Boolean) }
  def has_default; end

  # source://dspy//lib/dspy/signature.rb#15
  sig { returns(T.untyped) }
  def type; end
end

# DSL helper for building struct classes with field descriptions
#
# source://dspy//lib/dspy/signature.rb#36
class DSPy::Signature::StructBuilder
  # source://dspy//lib/dspy/signature.rb#43
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/signature.rb#56
  sig { returns(T.class_of(T::Struct)) }
  def build_struct_class; end

  # source://dspy//lib/dspy/signature.rb#48
  sig { params(name: ::Symbol, type: T.untyped, kwargs: T.untyped).void }
  def const(name, type, **kwargs); end

  # source://dspy//lib/dspy/signature.rb#40
  sig { returns(T::Hash[::Symbol, ::DSPy::Signature::FieldDescriptor]) }
  def field_descriptors; end
end

# source://dspy//lib/dspy/storage/program_storage.rb#9
module DSPy::Storage; end

# Storage system for saving and loading optimized DSPy programs
# Handles serialization of optimization results, program state, and history tracking
#
# source://dspy//lib/dspy/storage/program_storage.rb#12
class DSPy::Storage::ProgramStorage
  # source://dspy//lib/dspy/storage/program_storage.rb#140
  sig { params(storage_path: ::String, create_directories: T::Boolean).void }
  def initialize(storage_path: T.unsafe(nil), create_directories: T.unsafe(nil)); end

  # source://dspy//lib/dspy/storage/program_storage.rb#132
  sig { returns(T::Boolean) }
  def create_directories; end

  # Delete a saved program
  #
  # source://dspy//lib/dspy/storage/program_storage.rb#232
  sig { params(program_id: ::String).returns(T::Boolean) }
  def delete_program(program_id); end

  # Export multiple programs to a single file
  #
  # source://dspy//lib/dspy/storage/program_storage.rb#247
  sig { params(program_ids: T::Array[::String], export_path: ::String).void }
  def export_programs(program_ids, export_path); end

  # Get program history with performance metrics
  #
  # source://dspy//lib/dspy/storage/program_storage.rb#223
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def get_history; end

  # Import programs from an exported file
  #
  # source://dspy//lib/dspy/storage/program_storage.rb#268
  sig { params(import_path: ::String).returns(T::Array[::DSPy::Storage::ProgramStorage::SavedProgram]) }
  def import_programs(import_path); end

  # List all saved programs
  #
  # source://dspy//lib/dspy/storage/program_storage.rb#213
  sig { returns(T::Array[T::Hash[::Symbol, T.untyped]]) }
  def list_programs; end

  # Load a program by its ID
  #
  # source://dspy//lib/dspy/storage/program_storage.rb#188
  sig { params(program_id: ::String).returns(T.nilable(::DSPy::Storage::ProgramStorage::SavedProgram)) }
  def load_program(program_id); end

  # Save an optimized program with its optimization results
  #
  # source://dspy//lib/dspy/storage/program_storage.rb#156
  sig do
    params(
      program: T.untyped,
      optimization_result: T.untyped,
      program_id: T.nilable(::String),
      metadata: T::Hash[::Symbol, T.untyped]
    ).returns(::DSPy::Storage::ProgramStorage::SavedProgram)
  end
  def save_program(program, optimization_result, program_id: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # source://dspy//lib/dspy/storage/program_storage.rb#129
  sig { returns(::String) }
  def storage_path; end

  private

  # source://dspy//lib/dspy/storage/program_storage.rb#410
  sig { params(program_id: ::String).void }
  def emit_delete_event(program_id); end

  # source://dspy//lib/dspy/storage/program_storage.rb#417
  sig { params(export_path: ::String, program_count: ::Integer).void }
  def emit_export_event(export_path, program_count); end

  # source://dspy//lib/dspy/storage/program_storage.rb#425
  sig { params(import_path: ::String, program_count: ::Integer).void }
  def emit_import_event(import_path, program_count); end

  # source://dspy//lib/dspy/storage/program_storage.rb#392
  sig { params(saved_program: ::DSPy::Storage::ProgramStorage::SavedProgram).void }
  def emit_load_complete_event(saved_program); end

  # source://dspy//lib/dspy/storage/program_storage.rb#401
  sig { params(program_id: ::String, error: T.any(::Exception, ::String)).void }
  def emit_load_error_event(program_id, error); end

  # source://dspy//lib/dspy/storage/program_storage.rb#385
  sig { params(program_id: ::String).void }
  def emit_load_start_event(program_id); end

  # source://dspy//lib/dspy/storage/program_storage.rb#367
  sig { params(saved_program: ::DSPy::Storage::ProgramStorage::SavedProgram).void }
  def emit_save_complete_event(saved_program); end

  # source://dspy//lib/dspy/storage/program_storage.rb#376
  sig { params(program_id: T.nilable(::String), error: ::Exception).void }
  def emit_save_error_event(program_id, error); end

  # Event emission methods
  #
  # source://dspy//lib/dspy/storage/program_storage.rb#359
  sig { params(program_id: T.nilable(::String)).void }
  def emit_save_start_event(program_id); end

  # source://dspy//lib/dspy/storage/program_storage.rb#299
  sig { params(program_id: ::String).returns(::String) }
  def program_file_path(program_id); end

  # source://dspy//lib/dspy/storage/program_storage.rb#340
  sig { params(program_id: ::String).void }
  def remove_from_history(program_id); end

  # source://dspy//lib/dspy/storage/program_storage.rb#290
  sig { void }
  def setup_storage_directory; end

  # source://dspy//lib/dspy/storage/program_storage.rb#304
  sig { params(saved_program: ::DSPy::Storage::ProgramStorage::SavedProgram).void }
  def update_history(saved_program); end
end

# Represents a saved program with metadata
#
# source://dspy//lib/dspy/storage/program_storage.rb#16
class DSPy::Storage::ProgramStorage::SavedProgram
  # source://dspy//lib/dspy/storage/program_storage.rb#43
  sig do
    params(
      program: T.untyped,
      optimization_result: T::Hash[::Symbol, T.untyped],
      metadata: T::Hash[::Symbol, T.untyped],
      program_id: T.nilable(::String),
      saved_at: T.nilable(::Time)
    ).void
  end
  def initialize(program:, optimization_result:, metadata: T.unsafe(nil), program_id: T.unsafe(nil), saved_at: T.unsafe(nil)); end

  # source://dspy//lib/dspy/storage/program_storage.rb#26
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def metadata; end

  # source://dspy//lib/dspy/storage/program_storage.rb#23
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def optimization_result; end

  # source://dspy//lib/dspy/storage/program_storage.rb#20
  sig { returns(T.untyped) }
  def program; end

  # source://dspy//lib/dspy/storage/program_storage.rb#29
  sig { returns(::String) }
  def program_id; end

  # source://dspy//lib/dspy/storage/program_storage.rb#32
  sig { returns(::Time) }
  def saved_at; end

  # source://dspy//lib/dspy/storage/program_storage.rb#62
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  private

  # source://dspy//lib/dspy/storage/program_storage.rb#108
  sig { params(program: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def extract_program_state(program); end

  # source://dspy//lib/dspy/storage/program_storage.rb#86
  sig { returns(::String) }
  def generate_program_id; end

  # source://dspy//lib/dspy/storage/program_storage.rb#92
  sig { params(program: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
  def serialize_program(program); end

  class << self
    # source://dspy//lib/dspy/storage/program_storage.rb#101
    sig { params(data: T::Hash[::Symbol, T.untyped]).returns(T.untyped) }
    def deserialize_program(data); end

    # source://dspy//lib/dspy/storage/program_storage.rb#73
    sig { params(data: T::Hash[::Symbol, T.untyped]).returns(::DSPy::Storage::ProgramStorage::SavedProgram) }
    def from_h(data); end
  end
end

# High-level storage manager that integrates with the teleprompter system
# Provides easy saving/loading of optimization results
#
# source://dspy//lib/dspy/storage/storage_manager.rb#10
class DSPy::Storage::StorageManager
  # source://dspy//lib/dspy/storage/storage_manager.rb#60
  sig { params(config: T.nilable(::DSPy::Storage::StorageManager::StorageConfig)).void }
  def initialize(config: T.unsafe(nil)); end

  # Clean up old programs based on configuration
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#229
  sig { returns(::Integer) }
  def cleanup_old_programs; end

  # Compare two programs
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#268
  sig { params(program_id_1: ::String, program_id_2: ::String).returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
  def compare_programs(program_id_1, program_id_2); end

  # source://dspy//lib/dspy/storage/storage_manager.rb#54
  sig { returns(::DSPy::Storage::StorageManager::StorageConfig) }
  def config; end

  # Create a checkpoint from current optimization state
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#158
  sig do
    params(
      optimization_result: T.untyped,
      checkpoint_name: ::String,
      metadata: T::Hash[::Symbol, T.untyped]
    ).returns(T.nilable(::DSPy::Storage::ProgramStorage::SavedProgram))
  end
  def create_checkpoint(optimization_result, checkpoint_name, metadata: T.unsafe(nil)); end

  # Find programs by criteria
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#110
  sig do
    params(
      optimizer: T.nilable(::String),
      min_score: T.nilable(::Float),
      max_age_days: T.nilable(::Integer),
      tags: T::Array[::String],
      signature_class: T.nilable(::String)
    ).returns(T::Array[T::Hash[::Symbol, T.untyped]])
  end
  def find_programs(optimizer: T.unsafe(nil), min_score: T.unsafe(nil), max_age_days: T.unsafe(nil), tags: T.unsafe(nil), signature_class: T.unsafe(nil)); end

  # Get the best performing program for a signature class
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#142
  sig { params(signature_class: ::String).returns(T.nilable(::DSPy::Storage::ProgramStorage::SavedProgram)) }
  def get_best_program(signature_class); end

  # Get optimization history and trends
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#189
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def get_optimization_history; end

  # Restore from a checkpoint
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#175
  sig { params(checkpoint_name: ::String).returns(T.nilable(::DSPy::Storage::ProgramStorage::SavedProgram)) }
  def restore_checkpoint(checkpoint_name); end

  # Save optimization result from teleprompter
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#77
  sig do
    params(
      optimization_result: T.untyped,
      tags: T::Array[::String],
      description: T.nilable(::String),
      metadata: T::Hash[::Symbol, T.untyped]
    ).returns(T.nilable(::DSPy::Storage::ProgramStorage::SavedProgram))
  end
  def save_optimization_result(optimization_result, tags: T.unsafe(nil), description: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # source://dspy//lib/dspy/storage/storage_manager.rb#57
  sig { returns(::DSPy::Storage::ProgramStorage) }
  def storage; end

  class << self
    # source://dspy//lib/dspy/storage/storage_manager.rb#325
    sig { params(signature_class: ::String).returns(T.nilable(::DSPy::Storage::ProgramStorage::SavedProgram)) }
    def best(signature_class); end

    # Configure global storage
    #
    # source://dspy//lib/dspy/storage/storage_manager.rb#309
    sig { params(config: ::DSPy::Storage::StorageManager::StorageConfig).void }
    def configure(config); end

    # Get global storage instance
    #
    # source://dspy//lib/dspy/storage/storage_manager.rb#303
    sig { returns(::DSPy::Storage::StorageManager) }
    def instance; end

    # source://dspy//lib/dspy/storage/storage_manager.rb#320
    sig { params(program_id: ::String).returns(T.nilable(::DSPy::Storage::ProgramStorage::SavedProgram)) }
    def load(program_id); end

    # Shorthand methods for common operations
    #
    # source://dspy//lib/dspy/storage/storage_manager.rb#315
    sig do
      params(
        optimization_result: T.untyped,
        metadata: T::Hash[::Symbol, T.untyped]
      ).returns(T.nilable(::DSPy::Storage::ProgramStorage::SavedProgram))
    end
    def save(optimization_result, metadata: T.unsafe(nil)); end
  end
end

# Configuration for storage behavior
#
# source://dspy//lib/dspy/storage/storage_manager.rb#14
class DSPy::Storage::StorageManager::StorageConfig
  # source://dspy//lib/dspy/storage/storage_manager.rb#33
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/storage/storage_manager.rb#21
  sig { returns(T::Boolean) }
  def auto_save; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#21
  def auto_save=(_arg0); end

  # source://dspy//lib/dspy/storage/storage_manager.rb#30
  sig { returns(T::Boolean) }
  def compress_old_programs; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#30
  def compress_old_programs=(_arg0); end

  # source://dspy//lib/dspy/storage/storage_manager.rb#27
  sig { returns(::Integer) }
  def max_stored_programs; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#27
  def max_stored_programs=(_arg0); end

  # source://dspy//lib/dspy/storage/storage_manager.rb#24
  sig { returns(T::Boolean) }
  def save_intermediate_results; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#24
  def save_intermediate_results=(_arg0); end

  # source://dspy//lib/dspy/storage/storage_manager.rb#18
  sig { returns(::String) }
  def storage_path; end

  # @return [String]
  #
  # source://dspy//lib/dspy/storage/storage_manager.rb#18
  def storage_path=(_arg0); end

  # source://dspy//lib/dspy/storage/storage_manager.rb#42
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end
end

# User-facing enum for structured output strategy preferences
#
# source://dspy//lib/dspy/strategy.rb#7
class DSPy::Strategy < ::T::Enum
  enums do
    Compatible = new
    Strict = new
  end
end

# source://dspy//lib/dspy/teleprompt/teleprompter.rb#8
module DSPy::Teleprompt; end

# Data handling for optimization with efficient operations
# Provides operations for large datasets during bootstrap and optimization
#
# source://dspy//lib/dspy/teleprompt/data_handler.rb#10
class DSPy::Teleprompt::DataHandler
  # source://dspy//lib/dspy/teleprompt/data_handler.rb#17
  sig { params(examples: T::Array[T.untyped]).void }
  def initialize(examples); end

  # Create multiple candidate sets efficiently
  #
  # source://dspy//lib/dspy/teleprompt/data_handler.rb#82
  sig do
    params(
      num_sets: ::Integer,
      set_size: ::Integer,
      random_state: T.nilable(::Integer)
    ).returns(T::Array[T::Array[T.untyped]])
  end
  def create_candidate_sets(num_sets, set_size, random_state: T.unsafe(nil)); end

  # Get examples in batches for processing
  #
  # source://dspy//lib/dspy/teleprompt/data_handler.rb#49
  sig { params(batch_size: ::Integer).returns(T::Enumerator[T::Array[T.untyped]]) }
  def each_batch(batch_size); end

  # source://dspy//lib/dspy/teleprompt/data_handler.rb#14
  sig { returns(T::Array[T.untyped]) }
  def examples; end

  # Filter examples based on success/failure
  #
  # source://dspy//lib/dspy/teleprompt/data_handler.rb#55
  sig { params(successful_indices: T::Array[::Integer]).returns([T::Array[T.untyped], T::Array[T.untyped]]) }
  def partition_by_success(successful_indices); end

  # Sample examples efficiently
  #
  # source://dspy//lib/dspy/teleprompt/data_handler.rb#23
  sig { params(n: ::Integer, random_state: T.nilable(::Integer)).returns(T::Array[T.untyped]) }
  def sample(n, random_state: T.unsafe(nil)); end

  # Shuffle examples efficiently
  #
  # source://dspy//lib/dspy/teleprompt/data_handler.rb#39
  sig { params(random_state: T.nilable(::Integer)).returns(T::Array[T.untyped]) }
  def shuffle(random_state: T.unsafe(nil)); end

  # Get statistics about the data
  #
  # source://dspy//lib/dspy/teleprompt/data_handler.rb#72
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def statistics; end

  # Create stratified samples maintaining distribution
  #
  # source://dspy//lib/dspy/teleprompt/data_handler.rb#65
  sig { params(n: ::Integer, stratify_column: T.nilable(::String)).returns(T::Array[T.untyped]) }
  def stratified_sample(n, stratify_column: T.unsafe(nil)); end
end

# MIPROv2: Multi-prompt Instruction Proposal with Retrieval Optimization
# State-of-the-art prompt optimization combining bootstrap sampling,
# instruction generation, and Bayesian optimization
#
# source://dspy//lib/dspy/teleprompt/mipro_v2.rb#14
class DSPy::Teleprompt::MIPROv2 < ::DSPy::Teleprompt::Teleprompter
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#243
  sig do
    params(
      metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T.untyped)),
      config: T.nilable(::DSPy::Teleprompt::MIPROv2::MIPROv2Config)
    ).void
  end
  def initialize(metric: T.unsafe(nil), config: T.unsafe(nil)); end

  # Main MIPROv2 optimization method
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#260
  sig do
    params(
      program: T.untyped,
      trainset: T::Array[T.untyped],
      valset: T.nilable(T::Array[T.untyped])
    ).returns(::DSPy::Teleprompt::MIPROv2::MIPROv2Result)
  end
  def compile(program, trainset:, valset: T.unsafe(nil)); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#232
  sig { returns(::DSPy::Teleprompt::MIPROv2::MIPROv2Config) }
  def mipro_config; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#235
  sig { returns(T.nilable(::DSPy::Propose::GroundedProposer)) }
  def proposer; end

  private

  # Apply candidate configuration to program
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#631
  sig { params(program: T.untyped, candidate: ::DSPy::Teleprompt::MIPROv2::CandidateConfig).returns(T.untyped) }
  def apply_candidate_configuration(program, candidate); end

  # Build final MIPROv2 result
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#708
  sig do
    params(
      optimization_result: T::Hash[::Symbol, T.untyped],
      bootstrap_result: ::DSPy::Teleprompt::Utils::BootstrapResult,
      proposal_result: ::DSPy::Propose::GroundedProposer::ProposalResult
    ).returns(::DSPy::Teleprompt::MIPROv2::MIPROv2Result)
  end
  def build_miprov2_result(optimization_result, bootstrap_result, proposal_result); end

  # Calculate diversity score for candidate
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#692
  sig { params(candidate: ::DSPy::Teleprompt::MIPROv2::CandidateConfig).returns(::Float) }
  def calculate_diversity_score(candidate); end

  # Evaluate a candidate configuration
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#616
  sig do
    params(
      program: T.untyped,
      candidate: ::DSPy::Teleprompt::MIPROv2::CandidateConfig,
      evaluation_set: T::Array[::DSPy::Example]
    ).returns([::Float, T.untyped])
  end
  def evaluate_candidate(program, candidate, evaluation_set); end

  # Helper methods
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#747
  sig { params(program: T.untyped).returns(T.nilable(::String)) }
  def extract_current_instruction(program); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#764
  sig { params(example: T.untyped).returns(T.nilable(::String)) }
  def extract_reasoning_from_example(example); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#759
  sig { params(program: T.untyped).returns(T.nilable(T.class_of(DSPy::Signature))) }
  def extract_signature_class(program); end

  # Generate candidate configurations from proposals and bootstrap results
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#457
  sig do
    params(
      proposal_result: ::DSPy::Propose::GroundedProposer::ProposalResult,
      bootstrap_result: ::DSPy::Teleprompt::Utils::BootstrapResult
    ).returns(T::Array[::DSPy::Teleprompt::MIPROv2::CandidateConfig])
  end
  def generate_candidate_configurations(proposal_result, bootstrap_result); end

  # Infer auto mode based on configuration
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#781
  sig { returns(::String) }
  def infer_auto_mode; end

  # Initialize optimization state for candidate selection
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#508
  sig do
    params(
      candidates: T::Array[::DSPy::Teleprompt::MIPROv2::CandidateConfig]
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def initialize_optimization_state(candidates); end

  # Phase 1: Bootstrap few-shot examples from training data
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#325
  sig do
    params(
      program: T.untyped,
      trainset: T::Array[::DSPy::Example]
    ).returns(::DSPy::Teleprompt::Utils::BootstrapResult)
  end
  def phase_1_bootstrap(program, trainset); end

  # Phase 2: Generate instruction candidates using grounded proposer
  #
  # @raise [ArgumentError]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#344
  sig do
    params(
      program: T.untyped,
      trainset: T::Array[::DSPy::Example],
      bootstrap_result: ::DSPy::Teleprompt::Utils::BootstrapResult
    ).returns(::DSPy::Propose::GroundedProposer::ProposalResult)
  end
  def phase_2_propose_instructions(program, trainset, bootstrap_result); end

  # Phase 3: Bayesian optimization to find best configuration
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#375
  sig do
    params(
      program: T.untyped,
      evaluation_set: T::Array[::DSPy::Example],
      proposal_result: ::DSPy::Propose::GroundedProposer::ProposalResult,
      bootstrap_result: ::DSPy::Teleprompt::Utils::BootstrapResult
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def phase_3_optimize(program, evaluation_set, proposal_result, bootstrap_result); end

  # Adaptive candidate selection (balance exploration and exploitation)
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#561
  sig do
    params(
      candidates: T::Array[::DSPy::Teleprompt::MIPROv2::CandidateConfig],
      state: T::Hash[::Symbol, T.untyped],
      trial_idx: ::Integer
    ).returns(::DSPy::Teleprompt::MIPROv2::CandidateConfig)
  end
  def select_candidate_adaptive(candidates, state, trial_idx); end

  # Bayesian candidate selection (use probabilistic model)
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#602
  sig do
    params(
      candidates: T::Array[::DSPy::Teleprompt::MIPROv2::CandidateConfig],
      state: T::Hash[::Symbol, T.untyped],
      trial_idx: ::Integer
    ).returns(::DSPy::Teleprompt::MIPROv2::CandidateConfig)
  end
  def select_candidate_bayesian(candidates, state, trial_idx); end

  # Greedy candidate selection (exploit best known configurations)
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#543
  sig do
    params(
      candidates: T::Array[::DSPy::Teleprompt::MIPROv2::CandidateConfig],
      state: T::Hash[::Symbol, T.untyped]
    ).returns(::DSPy::Teleprompt::MIPROv2::CandidateConfig)
  end
  def select_candidate_greedy(candidates, state); end

  # Select next candidate based on optimization strategy
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#528
  sig do
    params(
      candidates: T::Array[::DSPy::Teleprompt::MIPROv2::CandidateConfig],
      state: T::Hash[::Symbol, T.untyped],
      trial_idx: ::Integer
    ).returns(::DSPy::Teleprompt::MIPROv2::CandidateConfig)
  end
  def select_next_candidate(candidates, state, trial_idx); end

  # Check if optimization should stop early
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#682
  sig { params(state: T::Hash[::Symbol, T.untyped], trial_idx: ::Integer).returns(T::Boolean) }
  def should_early_stop?(state, trial_idx); end

  # Update optimization state after candidate evaluation
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#662
  sig do
    params(
      state: T::Hash[::Symbol, T.untyped],
      candidate: ::DSPy::Teleprompt::MIPROv2::CandidateConfig,
      score: ::Float
    ).void
  end
  def update_optimization_state(state, candidate, score); end
end

# Auto-configuration modes for different optimization needs
#
# source://dspy//lib/dspy/teleprompt/mipro_v2.rb#18
module DSPy::Teleprompt::MIPROv2::AutoMode
  class << self
    # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#48
    sig { returns(::DSPy::Teleprompt::MIPROv2) }
    def heavy; end

    # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#22
    sig { returns(::DSPy::Teleprompt::MIPROv2) }
    def light; end

    # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#35
    sig { returns(::DSPy::Teleprompt::MIPROv2) }
    def medium; end
  end
end

# Candidate configuration for optimization trials
#
# source://dspy//lib/dspy/teleprompt/mipro_v2.rb#127
class DSPy::Teleprompt::MIPROv2::CandidateConfig
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#149
  sig do
    params(
      instruction: ::String,
      few_shot_examples: T::Array[T.untyped],
      metadata: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(instruction:, few_shot_examples:, metadata: T.unsafe(nil)); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#140
  sig { returns(::String) }
  def config_id; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#134
  sig { returns(T::Array[T.untyped]) }
  def few_shot_examples; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#131
  sig { returns(::String) }
  def instruction; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#137
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def metadata; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#157
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  private

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#169
  sig { returns(::String) }
  def generate_config_id; end
end

# Configuration for MIPROv2 optimization
#
# source://dspy//lib/dspy/teleprompt/mipro_v2.rb#62
class DSPy::Teleprompt::MIPROv2::MIPROv2Config < ::DSPy::Teleprompt::Teleprompter::Config
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#96
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#72
  sig { returns(::Integer) }
  def bootstrap_sets; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#72
  def bootstrap_sets=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#84
  sig { returns(::Integer) }
  def early_stopping_patience; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#84
  def early_stopping_patience=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#81
  sig { returns(::Float) }
  def final_temperature; end

  # @return [Float]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#81
  def final_temperature=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#78
  sig { returns(::Float) }
  def init_temperature; end

  # @return [Float]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#78
  def init_temperature=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#69
  sig { returns(::Integer) }
  def num_instruction_candidates; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#69
  def num_instruction_candidates=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#66
  sig { returns(::Integer) }
  def num_trials; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#66
  def num_trials=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#75
  sig { returns(::String) }
  def optimization_strategy; end

  # @return [String]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#75
  def optimization_strategy=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#93
  sig { returns(::DSPy::Propose::GroundedProposer::Config) }
  def proposer_config; end

  # @return [DSPy::Propose::GroundedProposer::Config]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#93
  def proposer_config=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#111
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#90
  sig { returns(T::Boolean) }
  def track_diversity; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#90
  def track_diversity=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#87
  sig { returns(T::Boolean) }
  def use_bayesian_optimization; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#87
  def use_bayesian_optimization=(_arg0); end
end

# Result of MIPROv2 optimization
#
# source://dspy//lib/dspy/teleprompt/mipro_v2.rb#176
class DSPy::Teleprompt::MIPROv2::MIPROv2Result < ::DSPy::Teleprompt::Teleprompter::OptimizationResult
  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#205
  sig do
    params(
      optimized_program: T.untyped,
      scores: T::Hash[::Symbol, T.untyped],
      history: T::Hash[::Symbol, T.untyped],
      evaluated_candidates: T::Array[::DSPy::Teleprompt::MIPROv2::CandidateConfig],
      optimization_trace: T::Hash[::Symbol, T.untyped],
      bootstrap_statistics: T::Hash[::Symbol, T.untyped],
      proposal_statistics: T::Hash[::Symbol, T.untyped],
      best_score_name: T.nilable(::String),
      best_score_value: T.nilable(::Float),
      metadata: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(optimized_program:, scores:, history:, evaluated_candidates:, optimization_trace:, bootstrap_statistics:, proposal_statistics:, best_score_name: T.unsafe(nil), best_score_value: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#186
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def bootstrap_statistics; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#180
  sig { returns(T::Array[::DSPy::Teleprompt::MIPROv2::CandidateConfig]) }
  def evaluated_candidates; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#183
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def optimization_trace; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#189
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def proposal_statistics; end

  # source://dspy//lib/dspy/teleprompt/mipro_v2.rb#221
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end
end

# Simple optimization algorithm using random/grid search
# Uses grounded proposer for instruction generation and bootstrap for examples
#
# source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#12
class DSPy::Teleprompt::SimpleOptimizer < ::DSPy::Teleprompt::Teleprompter
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#109
  sig do
    params(
      metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T.untyped)),
      config: T.nilable(::DSPy::Teleprompt::SimpleOptimizer::OptimizerConfig)
    ).void
  end
  def initialize(metric: T.unsafe(nil), config: T.unsafe(nil)); end

  # Main optimization method
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#128
  sig do
    params(
      program: T.untyped,
      trainset: T::Array[T.untyped],
      valset: T.nilable(T::Array[T.untyped])
    ).returns(::DSPy::Teleprompt::Teleprompter::OptimizationResult)
  end
  def compile(program, trainset:, valset: T.unsafe(nil)); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#98
  sig { returns(::DSPy::Teleprompt::SimpleOptimizer::OptimizerConfig) }
  def optimizer_config; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#101
  sig { returns(T.nilable(::DSPy::Propose::GroundedProposer)) }
  def proposer; end

  private

  # Apply few-shot examples to program
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#383
  sig { params(program: T.untyped, examples: T::Array[T.untyped]).returns(T.untyped) }
  def apply_few_shot_modification(program, examples); end

  # Apply instruction modification to program
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#373
  sig { params(program: T.untyped, instruction: ::String).returns(T.untyped) }
  def apply_instruction_modification(program, instruction); end

  # Apply trial configuration to program
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#355
  sig { params(program: T.untyped, config: T::Hash[::Symbol, T.untyped]).returns(T.untyped) }
  def apply_trial_configuration(program, config); end

  # Bootstrap few-shot examples from training set
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#179
  sig do
    params(
      program: T.untyped,
      trainset: T::Array[::DSPy::Example]
    ).returns(::DSPy::Teleprompt::Utils::BootstrapResult)
  end
  def bootstrap_examples(program, trainset); end

  # Build the final optimization result
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#409
  sig do
    params(
      best_trial: T.nilable(::DSPy::Teleprompt::SimpleOptimizer::TrialResult),
      all_trials: T::Array[::DSPy::Teleprompt::SimpleOptimizer::TrialResult]
    ).returns(::DSPy::Teleprompt::Teleprompter::OptimizationResult)
  end
  def build_optimization_result(best_trial, all_trials); end

  # Helper methods for program introspection
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#449
  sig { params(program: T.untyped).returns(T.nilable(::String)) }
  def extract_current_instruction(program); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#481
  sig { params(example: T.untyped).returns(T.nilable(::String)) }
  def extract_reasoning_from_example(example); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#462
  sig { params(program: T.untyped).returns(T.nilable(T.class_of(DSPy::Signature))) }
  def extract_signature_class(program); end

  # Find the best trial based on score
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#401
  sig do
    params(
      trials: T::Array[::DSPy::Teleprompt::SimpleOptimizer::TrialResult]
    ).returns(T.nilable(::DSPy::Teleprompt::SimpleOptimizer::TrialResult))
  end
  def find_best_trial(trials); end

  # Generate instruction candidates using the proposer
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#198
  sig do
    params(
      program: T.untyped,
      trainset: T::Array[::DSPy::Example],
      bootstrap_result: T.nilable(::DSPy::Teleprompt::Utils::BootstrapResult)
    ).returns(T::Array[::String])
  end
  def generate_instruction_candidates(program, trainset, bootstrap_result); end

  # Generate configurations for trials
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#276
  sig do
    params(
      instruction_candidates: T::Array[::String],
      bootstrap_result: T.nilable(::DSPy::Teleprompt::Utils::BootstrapResult)
    ).returns(T::Array[T::Hash[::Symbol, T.untyped]])
  end
  def generate_trial_configurations(instruction_candidates, bootstrap_result); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#476
  sig { params(program: T.untyped).returns(T::Boolean) }
  def respond_to_few_shot_modification?(program); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#471
  sig { params(program: T.untyped).returns(T::Boolean) }
  def respond_to_instruction_modification?(program); end

  # Run optimization trials with different configurations
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#230
  sig do
    params(
      program: T.untyped,
      evaluation_set: T::Array[::DSPy::Example],
      instruction_candidates: T::Array[::String],
      bootstrap_result: T.nilable(::DSPy::Teleprompt::Utils::BootstrapResult)
    ).returns(T::Array[::DSPy::Teleprompt::SimpleOptimizer::TrialResult])
  end
  def run_optimization_trials(program, evaluation_set, instruction_candidates, bootstrap_result); end

  # Run a single optimization trial
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#320
  sig do
    params(
      program: T.untyped,
      evaluation_set: T::Array[::DSPy::Example],
      config: T::Hash[::Symbol, T.untyped],
      trial_number: ::Integer
    ).returns(::DSPy::Teleprompt::SimpleOptimizer::TrialResult)
  end
  def run_single_trial(program, evaluation_set, config, trial_number); end
end

# Configuration specific to simple optimization
#
# source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#16
class DSPy::Teleprompt::SimpleOptimizer::OptimizerConfig < ::DSPy::Teleprompt::Teleprompter::Config
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#35
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#20
  sig { returns(::Integer) }
  def num_trials; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#20
  def num_trials=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#32
  sig { returns(::DSPy::Propose::GroundedProposer::Config) }
  def proposer_config; end

  # @return [DSPy::Propose::GroundedProposer::Config]
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#32
  def proposer_config=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#23
  sig { returns(::String) }
  def search_strategy; end

  # @return [String]
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#23
  def search_strategy=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#29
  sig { returns(T::Boolean) }
  def use_few_shot_optimization; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#29
  def use_few_shot_optimization=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#26
  sig { returns(T::Boolean) }
  def use_instruction_optimization; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#26
  def use_instruction_optimization=(_arg0); end
end

# Result of a single optimization trial
#
# source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#46
class DSPy::Teleprompt::SimpleOptimizer::TrialResult
  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#81
  sig do
    params(
      trial_number: ::Integer,
      program: T.untyped,
      instruction: ::String,
      few_shot_examples: T::Array[T.untyped],
      evaluation_result: ::DSPy::Evaluate::BatchEvaluationResult,
      score: ::Float,
      metadata: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(trial_number:, program:, instruction:, few_shot_examples:, evaluation_result:, score:, metadata:); end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#62
  sig { returns(::DSPy::Evaluate::BatchEvaluationResult) }
  def evaluation_result; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#59
  sig { returns(T::Array[T.untyped]) }
  def few_shot_examples; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#56
  sig { returns(::String) }
  def instruction; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#68
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def metadata; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#53
  sig { returns(T.untyped) }
  def program; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#65
  sig { returns(::Float) }
  def score; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#92
  sig { returns(T::Boolean) }
  def successful?; end

  # source://dspy//lib/dspy/teleprompt/simple_optimizer.rb#50
  sig { returns(::Integer) }
  def trial_number; end
end

# Base class for all DSPy teleprompters (optimizers)
# Defines the common interface and provides shared functionality for prompt optimization
#
# source://dspy//lib/dspy/teleprompt/teleprompter.rb#11
class DSPy::Teleprompt::Teleprompter
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#137
  sig do
    params(
      metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T.untyped)),
      config: T.nilable(::DSPy::Teleprompt::Teleprompter::Config)
    ).void
  end
  def initialize(metric: T.unsafe(nil), config: T.unsafe(nil)); end

  # Main optimization method - must be implemented by subclasses
  #
  # @raise [NotImplementedError]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#151
  sig do
    params(
      program: T.untyped,
      trainset: T::Array[T.untyped],
      valset: T.nilable(T::Array[T.untyped])
    ).returns(::DSPy::Teleprompt::Teleprompter::OptimizationResult)
  end
  def compile(program, trainset:, valset: T.unsafe(nil)); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#123
  sig { returns(::DSPy::Teleprompt::Teleprompter::Config) }
  def config; end

  # Create evaluator for given examples and metric
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#187
  sig { params(examples: T::Array[T.untyped]).returns(::DSPy::Evaluate) }
  def create_evaluator(examples); end

  # Ensure examples are properly typed (only DSPy::Example instances supported)
  #
  # @raise [ArgumentError]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#178
  sig do
    params(
      examples: T::Array[T.untyped],
      signature_class: T.nilable(T.class_of(DSPy::Signature))
    ).returns(T::Array[::DSPy::Example])
  end
  def ensure_typed_examples(examples, signature_class = T.unsafe(nil)); end

  # Evaluate program performance on given examples
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#207
  sig do
    params(
      program: T.untyped,
      examples: T::Array[T.untyped],
      metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T.untyped))
    ).returns(::DSPy::Evaluate::BatchEvaluationResult)
  end
  def evaluate_program(program, examples, metric: T.unsafe(nil)); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#129
  sig { returns(T.nilable(::DSPy::Evaluate)) }
  def evaluator; end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#126
  sig { returns(T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T.untyped))) }
  def metric; end

  # Save optimization results if configured
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#222
  sig { params(result: ::DSPy::Teleprompt::Teleprompter::OptimizationResult).void }
  def save_results(result); end

  # Validate optimization inputs
  #
  # @raise [ArgumentError]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#163
  sig { params(program: T.untyped, trainset: T::Array[T.untyped], valset: T.nilable(T::Array[T.untyped])).void }
  def validate_inputs(program, trainset, valset = T.unsafe(nil)); end

  protected

  # Create a default metric for examples
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#302
  sig do
    params(
      examples: T::Array[T.untyped]
    ).returns(T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean)))
  end
  def default_metric_for_examples(examples); end

  # Emit optimization events
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#328
  sig { params(event_name: ::String, payload: T::Hash[::Symbol, T.untyped]).void }
  def emit_event(event_name, payload = T.unsafe(nil)); end

  # Infer signature class from examples
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#295
  sig { params(examples: T::Array[T.untyped]).returns(T.nilable(T.class_of(DSPy::Signature))) }
  def infer_signature_class(examples); end

  # Instrument optimization steps
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#314
  sig do
    params(
      step_name: ::String,
      payload: T::Hash[::Symbol, T.untyped],
      block: T.proc.returns(T.untyped)
    ).returns(T.untyped)
  end
  def instrument_step(step_name, payload = T.unsafe(nil), &block); end

  # Validate that examples are in the correct format
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#262
  sig { params(examples: T.nilable(T::Array[T.untyped]), context: ::String).void }
  def validate_examples(examples, context); end

  # Validate a single example
  #
  # @raise [ArgumentError]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#272
  sig { params(example: T.untyped, context: ::String).void }
  def validate_single_example(example, context); end
end

# Configuration for optimization runs
#
# source://dspy//lib/dspy/teleprompt/teleprompter.rb#15
class DSPy::Teleprompt::Teleprompter::Config
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#43
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#19
  sig { returns(T.nilable(::Integer)) }
  def max_bootstrapped_examples; end

  # @return [Integer, nil]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#19
  def max_bootstrapped_examples=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#31
  sig { returns(T.nilable(::Integer)) }
  def max_errors; end

  # @return [Integer, nil]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#31
  def max_errors=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#22
  sig { returns(T.nilable(::Integer)) }
  def max_labeled_examples; end

  # @return [Integer, nil]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#22
  def max_labeled_examples=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#25
  sig { returns(T.nilable(::Integer)) }
  def num_candidate_examples; end

  # @return [Integer, nil]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#25
  def num_candidate_examples=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#28
  sig { returns(T.nilable(::Integer)) }
  def num_threads; end

  # @return [Integer, nil]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#28
  def num_threads=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#34
  sig { returns(T::Boolean) }
  def require_validation_examples; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#34
  def require_validation_examples=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#37
  sig { returns(T::Boolean) }
  def save_intermediate_results; end

  # @return [Boolean]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#37
  def save_intermediate_results=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#40
  sig { returns(T.nilable(::String)) }
  def save_path; end

  # @return [String, nil]
  #
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#40
  def save_path=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#55
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end
end

# Result of an optimization run
#
# source://dspy//lib/dspy/teleprompt/teleprompter.rb#70
class DSPy::Teleprompt::Teleprompter::OptimizationResult
  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#101
  sig do
    params(
      optimized_program: T.untyped,
      scores: T::Hash[::Symbol, T.untyped],
      history: T::Hash[::Symbol, T.untyped],
      best_score_name: T.nilable(::String),
      best_score_value: T.nilable(::Float),
      metadata: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(optimized_program:, scores:, history:, best_score_name: T.unsafe(nil), best_score_value: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#83
  sig { returns(T.nilable(::String)) }
  def best_score_name; end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#86
  sig { returns(T.nilable(::Float)) }
  def best_score_value; end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#80
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def history; end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#89
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def metadata; end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#74
  sig { returns(T.untyped) }
  def optimized_program; end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#77
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def scores; end

  # source://dspy//lib/dspy/teleprompt/teleprompter.rb#111
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def to_h; end
end

# Bootstrap utilities for MIPROv2 optimization
# Handles few-shot example generation and candidate program evaluation
#
# source://dspy//lib/dspy/teleprompt/utils.rb#12
module DSPy::Teleprompt::Utils
  class << self
    # Create candidate sets from successful examples using efficient data handling
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#293
    sig do
      params(
        successful_examples: T::Array[::DSPy::Example],
        config: ::DSPy::Teleprompt::Utils::BootstrapConfig
      ).returns(T::Array[T::Array[::DSPy::Example]])
    end
    def create_candidate_sets(successful_examples, config); end

    # Create multiple candidate sets of few-shot examples through bootstrapping
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#105
    sig do
      params(
        program: T.untyped,
        trainset: T::Array[T.untyped],
        config: ::DSPy::Teleprompt::Utils::BootstrapConfig,
        metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
      ).returns(::DSPy::Teleprompt::Utils::BootstrapResult)
    end
    def create_n_fewshot_demo_sets(program, trainset, config: T.unsafe(nil), metric: T.unsafe(nil)); end

    # Create a bootstrap example that includes the successful prediction
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#317
    sig { params(original_example: ::DSPy::Example, prediction: T.untyped).returns(::DSPy::Example) }
    def create_successful_bootstrap_example(original_example, prediction); end

    # Create default metric for examples
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#335
    sig do
      params(
        examples: T::Array[T.untyped]
      ).returns(T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean)))
    end
    def default_metric_for_examples(examples); end

    # Emit bootstrap completion event
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#345
    sig { params(statistics: T::Hash[::Symbol, T.untyped]).void }
    def emit_bootstrap_complete_event(statistics); end

    # Emit individual bootstrap example event
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#357
    sig { params(index: ::Integer, success: T::Boolean, error: T.nilable(::String)).void }
    def emit_bootstrap_example_event(index, success, error); end

    # Convert various example formats to typed examples
    #
    # @raise [ArgumentError]
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#217
    sig { params(examples: T::Array[T.untyped]).returns(T::Array[::DSPy::Example]) }
    def ensure_typed_examples(examples); end

    # Evaluate a candidate program on examples with proper error handling
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#157
    sig do
      params(
        program: T.untyped,
        examples: T::Array[T.untyped],
        config: ::DSPy::Teleprompt::Utils::BootstrapConfig,
        metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
      ).returns(::DSPy::Evaluate::BatchEvaluationResult)
    end
    def eval_candidate_program(program, examples, config: T.unsafe(nil), metric: T.unsafe(nil)); end

    # Full evaluation on all examples
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#200
    sig do
      params(
        program: T.untyped,
        examples: T::Array[T.untyped],
        config: ::DSPy::Teleprompt::Utils::BootstrapConfig,
        metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
      ).returns(::DSPy::Evaluate::BatchEvaluationResult)
    end
    def eval_candidate_program_full(program, examples, config, metric); end

    # Minibatch evaluation for large datasets
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#175
    sig do
      params(
        program: T.untyped,
        examples: T::Array[T.untyped],
        config: ::DSPy::Teleprompt::Utils::BootstrapConfig,
        metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
      ).returns(::DSPy::Evaluate::BatchEvaluationResult)
    end
    def eval_candidate_program_minibatch(program, examples, config, metric); end

    # Generate successful examples through program execution
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#232
    sig do
      params(
        program: T.untyped,
        examples: T::Array[::DSPy::Example],
        config: ::DSPy::Teleprompt::Utils::BootstrapConfig,
        metric: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
      ).returns([T::Array[::DSPy::Example], T::Array[::DSPy::Example]])
    end
    def generate_successful_examples(program, examples, config, metric); end

    # Infer signature class from examples
    #
    # source://dspy//lib/dspy/teleprompt/utils.rb#367
    sig { params(examples: T::Array[T.untyped]).returns(T.nilable(T.class_of(DSPy::Signature))) }
    def infer_signature_class(examples); end
  end
end

# Configuration for bootstrap operations
#
# source://dspy//lib/dspy/teleprompt/utils.rb#16
class DSPy::Teleprompt::Utils::BootstrapConfig
  # source://dspy//lib/dspy/teleprompt/utils.rb#41
  sig { void }
  def initialize; end

  # source://dspy//lib/dspy/teleprompt/utils.rb#20
  sig { returns(::Integer) }
  def max_bootstrapped_examples; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/utils.rb#20
  def max_bootstrapped_examples=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/utils.rb#29
  sig { returns(::Integer) }
  def max_errors; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/utils.rb#29
  def max_errors=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/utils.rb#23
  sig { returns(::Integer) }
  def max_labeled_examples; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/utils.rb#23
  def max_labeled_examples=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/utils.rb#38
  sig { returns(::Integer) }
  def minibatch_size; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/utils.rb#38
  def minibatch_size=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/utils.rb#26
  sig { returns(::Integer) }
  def num_candidate_sets; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/utils.rb#26
  def num_candidate_sets=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/utils.rb#32
  sig { returns(::Integer) }
  def num_threads; end

  # @return [Integer]
  #
  # source://dspy//lib/dspy/teleprompt/utils.rb#32
  def num_threads=(_arg0); end

  # source://dspy//lib/dspy/teleprompt/utils.rb#35
  sig { returns(::Float) }
  def success_threshold; end

  # @return [Float]
  #
  # source://dspy//lib/dspy/teleprompt/utils.rb#35
  def success_threshold=(_arg0); end
end

# Result of bootstrap operation
#
# source://dspy//lib/dspy/teleprompt/utils.rb#53
class DSPy::Teleprompt::Utils::BootstrapResult
  # source://dspy//lib/dspy/teleprompt/utils.rb#76
  sig do
    params(
      candidate_sets: T::Array[T::Array[::DSPy::Example]],
      successful_examples: T::Array[::DSPy::Example],
      failed_examples: T::Array[::DSPy::Example],
      statistics: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(candidate_sets:, successful_examples:, failed_examples:, statistics:); end

  # source://dspy//lib/dspy/teleprompt/utils.rb#57
  sig { returns(T::Array[T::Array[::DSPy::Example]]) }
  def candidate_sets; end

  # source://dspy//lib/dspy/teleprompt/utils.rb#63
  sig { returns(T::Array[::DSPy::Example]) }
  def failed_examples; end

  # source://dspy//lib/dspy/teleprompt/utils.rb#66
  sig { returns(T::Hash[::Symbol, T.untyped]) }
  def statistics; end

  # source://dspy//lib/dspy/teleprompt/utils.rb#84
  sig { returns(::Float) }
  def success_rate; end

  # source://dspy//lib/dspy/teleprompt/utils.rb#60
  sig { returns(T::Array[::DSPy::Example]) }
  def successful_examples; end

  # source://dspy//lib/dspy/teleprompt/utils.rb#91
  sig { returns(::Integer) }
  def total_examples; end
end

# Base class for ReAct thought generation - will be customized per input type
#
# source://dspy//lib/dspy/re_act.rb#32
class DSPy::ThoughtBase < ::DSPy::Signature; end

# Define the tools available to the agent
#
# source://dspy//lib/dspy/tools/base.rb#7
module DSPy::Tools; end

# Base class for all Sorbet-based tools with DSL support
#
# source://dspy//lib/dspy/tools/base.rb#9
class DSPy::Tools::Base
  # source://dspy//lib/dspy/tools/base.rb#139
  sig { returns(::String) }
  def description; end

  # Dynamic call method for ReAct agent - parses JSON arguments and calls the typed method
  #
  # source://dspy//lib/dspy/tools/base.rb#157
  sig { params(args_json: T.untyped).returns(T.untyped) }
  def dynamic_call(args_json); end

  # Instance methods that tools can use
  #
  # source://dspy//lib/dspy/tools/base.rb#134
  sig { returns(::String) }
  def name; end

  # Get the JSON schema string for the tool, formatted for LLM consumption
  #
  # source://dspy//lib/dspy/tools/base.rb#145
  sig { returns(::String) }
  def schema; end

  protected

  # Convert argument to the expected type based on JSON schema
  #
  # source://dspy//lib/dspy/tools/base.rb#202
  sig { params(value: T.untyped, schema: T::Hash[::Symbol, T.untyped]).returns(T.untyped) }
  def convert_argument_type(value, schema); end

  class << self
    # Get the JSON schema for the call method based on its Sorbet signature
    #
    # source://dspy//lib/dspy/tools/base.rb#33
    sig { returns(T::Hash[::Symbol, T.untyped]) }
    def call_schema; end

    # DSL method to set tool description
    #
    # source://dspy//lib/dspy/tools/base.rb#27
    sig { params(description: ::String).void }
    def tool_description(description); end

    # @return [String, nil]
    #
    # source://dspy//lib/dspy/tools/base.rb#17
    def tool_description_value; end

    # DSL method to set tool name
    #
    # source://dspy//lib/dspy/tools/base.rb#21
    sig { params(name: ::String).void }
    def tool_name(name); end

    # source://dspy//lib/dspy/tools/base.rb#17
    sig { returns(T.nilable(::String)) }
    def tool_name_value; end

    private

    # Convert Sorbet types to JSON Schema types
    #
    # source://dspy//lib/dspy/tools/base.rb#92
    sig { params(sorbet_type: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
    def sorbet_type_to_json_schema(sorbet_type); end
  end
end

# source://dspy//lib/dspy/tools.rb#9
class DSPy::Tools::Tool
  # @return [Tool] a new instance of Tool
  #
  # source://dspy//lib/dspy/tools.rb#12
  def initialize(name, description); end

  # @raise [NotImplementedError]
  #
  # source://dspy//lib/dspy/tools.rb#17
  def call(input); end

  # Returns the value of attribute description.
  #
  # source://dspy//lib/dspy/tools.rb#10
  def description; end

  # Returns the value of attribute name.
  #
  # source://dspy//lib/dspy/tools.rb#10
  def name; end
end

# Base class for multi-method tool classes where each method can be exposed as an individual tool
# Similar to Rails controllers where each action is exposed as an endpoint
#
# source://dspy//lib/dspy/tools/toolset.rb#10
class DSPy::Tools::Toolset
  class << self
    # source://dspy//lib/dspy/tools/toolset.rb#18
    sig { returns(T::Hash[::Symbol, T::Hash[::Symbol, ::String]]) }
    def exposed_tools; end

    # Generate schema for a specific method using Sorbet signatures
    #
    # source://dspy//lib/dspy/tools/toolset.rb#51
    sig { params(method_name: ::Symbol).returns(T::Hash[::Symbol, T.untyped]) }
    def schema_for_method(method_name); end

    # Get all exposed tools as individual tool instances
    #
    # source://dspy//lib/dspy/tools/toolset.rb#42
    sig { returns(T::Array[::DSPy::Tools::Toolset::ToolProxy]) }
    def to_tools; end

    # DSL method to expose a method as a tool
    #
    # source://dspy//lib/dspy/tools/toolset.rb#22
    sig { params(method_name: ::Symbol, tool_name: T.nilable(::String), description: T.nilable(::String)).void }
    def tool(method_name, tool_name: T.unsafe(nil), description: T.unsafe(nil)); end

    # DSL method to set the toolset name prefix
    #
    # source://dspy//lib/dspy/tools/toolset.rb#32
    sig { params(name: T.nilable(::String)).returns(::String) }
    def toolset_name(name = T.unsafe(nil)); end

    private

    # Convert Sorbet types to JSON Schema types (extracted from Base)
    #
    # source://dspy//lib/dspy/tools/toolset.rb#96
    sig { params(sorbet_type: T.untyped).returns(T::Hash[::Symbol, T.untyped]) }
    def sorbet_type_to_json_schema(sorbet_type); end
  end
end

# Inner class that wraps a method as a tool, compatible with DSPy::Tools::Base interface
#
# source://dspy//lib/dspy/tools/toolset.rb#145
class DSPy::Tools::Toolset::ToolProxy < ::DSPy::Tools::Base
  # source://dspy//lib/dspy/tools/toolset.rb#149
  sig do
    params(
      instance: ::DSPy::Tools::Toolset,
      method_name: ::Symbol,
      tool_name: ::String,
      description: ::String
    ).void
  end
  def initialize(instance, method_name, tool_name, description); end

  # The main call method that tools must implement
  #
  # source://dspy//lib/dspy/tools/toolset.rb#179
  sig { params(kwargs: T.untyped).returns(T.untyped) }
  def call(**kwargs); end

  # source://dspy//lib/dspy/tools/toolset.rb#162
  sig { override.returns(::String) }
  def description; end

  # source://dspy//lib/dspy/tools/toolset.rb#184
  sig { override.params(args_json: T.untyped).returns(T.untyped) }
  def dynamic_call(args_json); end

  # source://dspy//lib/dspy/tools/toolset.rb#157
  sig { override.returns(::String) }
  def name; end

  # source://dspy//lib/dspy/tools/toolset.rb#167
  sig { override.returns(::String) }
  def schema; end
end

# source://dspy//lib/dspy/type_serializer.rb#6
class DSPy::TypeSerializer
  class << self
    # Serialize a value, injecting _type fields for T::Struct instances
    #
    # source://dspy//lib/dspy/type_serializer.rb#11
    sig { params(value: T.untyped).returns(T.untyped) }
    def serialize(value); end

    # source://dspy//lib/dspy/type_serializer.rb#27
    sig { params(struct: ::T::Struct).returns(T::Hash[::String, T.untyped]) }
    def serialize_struct(struct); end
  end
end

# source://dspy//lib/dspy/version.rb#4
DSPy::VERSION = T.let(T.unsafe(nil), String)

# source://dspy//lib/dspy/errors.rb#6
class DSPy::ValidationError < ::DSPy::Error; end
